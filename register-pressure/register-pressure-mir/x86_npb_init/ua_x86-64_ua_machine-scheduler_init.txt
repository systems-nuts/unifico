Before MISched:
# Machine code for function main: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=4, align=4, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=4, align=4, at location [SP+8]
  fi#6: size=4, align=4, at location [SP+8]
  fi#7: size=4, align=4, at location [SP+8]
  fi#8: size=4, align=4, at location [SP+8]
  fi#9: size=8, align=8, at location [SP+8]
  fi#10: size=8, align=8, at location [SP+8]
  fi#11: size=8, align=8, at location [SP+8]
  fi#12: size=1, align=1, at location [SP+8]
  fi#13: size=4, align=4, at location [SP+8]
  fi#14: size=4, align=4, at location [SP+8]
  fi#15: size=8, align=8, at location [SP+8]
  fi#16: size=88, align=16, at location [SP+8]
  fi#17: size=88, align=16, at location [SP+8]
  fi#18: size=8, align=8, at location [SP+8]
  fi#19: size=4, align=4, at location [SP+8]
Constant Pool:
  cp#0: 5.000000e-01, align=8
  cp#1: 7.000000e+00, align=8
  cp#2: 4.000000e-02, align=8
  cp#3: 1.000000e+06, align=8
  cp#4: 1.000000e+02, align=8
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
  MOV32mr %stack.1.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.2.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  MOV64mi32 %stack.11.nelt_tot, 1, $noreg, 0, $noreg, 0 :: (store 8 into %ir.nelt_tot)
  MOV32mi %stack.13.ifmortar, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.ifmortar)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str
  $rsi = MOV32ri64 @.str.1
  CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %4:gr64 = COPY killed $rax
  MOV64mr %stack.18.fp, 1, $noreg, 0, $noreg, %4:gr64 :: (store 8 into %ir.fp)
  TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
  JCC_1 %bb.2, 4, implicit killed $eflags
  JMP_1 %bb.1

bb.1.if.then:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
  MOV64mi32 %stack.17.t_names, 1, $noreg, 8, $noreg, @.str.2 :: (store 8 into %ir.arrayidx)
  MOV64mi32 %stack.17.t_names, 1, $noreg, 16, $noreg, @.str.3 :: (store 8 into %ir.arrayidx1, align 16)
  MOV64mi32 %stack.17.t_names, 1, $noreg, 24, $noreg, @.str.4 :: (store 8 into %ir.arrayidx2)
  MOV64mi32 %stack.17.t_names, 1, $noreg, 32, $noreg, @.str.5 :: (store 8 into %ir.arrayidx3, align 16)
  MOV64mi32 %stack.17.t_names, 1, $noreg, 40, $noreg, @.str.6 :: (store 8 into %ir.arrayidx4)
  MOV64mi32 %stack.17.t_names, 1, $noreg, 48, $noreg, @.str.7 :: (store 8 into %ir.arrayidx5, align 16)
  MOV64mi32 %stack.17.t_names, 1, $noreg, 56, $noreg, @.str.8 :: (store 8 into %ir.arrayidx6)
  MOV64mi32 %stack.17.t_names, 1, $noreg, 64, $noreg, @.str.9 :: (store 8 into %ir.arrayidx7, align 16)
  MOV64mi32 %stack.17.t_names, 1, $noreg, 72, $noreg, @.str.10 :: (store 8 into %ir.arrayidx8)
  MOV64mi32 %stack.17.t_names, 1, $noreg, 80, $noreg, @.str.11 :: (store 8 into %ir.arrayidx9, align 16)
  %5:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @fclose, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  JMP_1 %bb.3

bb.2.if.else:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  MOV32mi $rip, 1, $noreg, @timeron, $noreg, 0 :: (store 4 into @timeron)

bb.3.if.end:
; predecessors: %bb.2, %bb.1
  successors: %bb.4(0x50000000), %bb.11(0x30000000); %bb.4(62.50%), %bb.11(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.12
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.13
  $rsi = MOV32ri64 @.str.1
  CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %13:gr64 = COPY killed $rax
  MOV64mr %stack.18.fp, 1, $noreg, 0, $noreg, %13:gr64 :: (store 8 into %ir.fp)
  TEST64rr %13:gr64, %13:gr64, implicit-def $eflags
  JCC_1 %bb.11, 4, implicit killed $eflags
  JMP_1 %bb.4

bb.4.if.then14:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.14
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %23:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %23:gr64
  $rsi = MOV32ri64 @.str.15
  $rdx = MOV32ri64 @fre
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %26:gr32 = COPY killed $eax
  MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %26:gr32 :: (store 4 into %ir.result)

bb.5.while.cond:
; predecessors: %bb.4, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %27:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %27:gr64
  CALL64pcrel32 @fgetc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %28:gr32 = COPY killed $eax
  CMP32ri8 %28:gr32, 10, implicit-def $eflags
  JCC_1 %bb.5, 5, implicit killed $eflags
  JMP_1 %bb.6

bb.6.while.end:
; predecessors: %bb.5
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %30:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %30:gr64
  $rsi = MOV32ri64 @.str.15
  $rdx = MOV32ri64 @niter
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %35:gr32 = COPY killed $eax
  MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %35:gr32 :: (store 4 into %ir.result)

bb.7.while.cond20:
; predecessors: %bb.6, %bb.7
  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)

  %36:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %36:gr64
  CALL64pcrel32 @fgetc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:gr32 = COPY killed $eax
  CMP32ri8 %37:gr32, 10, implicit-def $eflags
  JCC_1 %bb.7, 5, implicit killed $eflags
  JMP_1 %bb.8

bb.8.while.end24:
; predecessors: %bb.7
  successors: %bb.9(0x80000000); %bb.9(100.00%)

  %39:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %39:gr64
  $rsi = MOV32ri64 @.str.15
  $rdx = MOV32ri64 @nmxh
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %44:gr32 = COPY killed $eax
  MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %44:gr32 :: (store 4 into %ir.result)

bb.9.while.cond26:
; predecessors: %bb.8, %bb.9
  successors: %bb.9(0x7c000000), %bb.10(0x04000000); %bb.9(96.88%), %bb.10(3.12%)

  %45:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %45:gr64
  CALL64pcrel32 @fgetc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %46:gr32 = COPY killed $eax
  CMP32ri8 %46:gr32, 10, implicit-def $eflags
  JCC_1 %bb.9, 5, implicit killed $eflags
  JMP_1 %bb.10

bb.10.while.end30:
; predecessors: %bb.9
  successors: %bb.12(0x80000000); %bb.12(100.00%)

  %48:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %48:gr64
  $rsi = MOV32ri64 @.str.16
  $rdx = MOV32ri64 @alpha
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %53:gr32 = COPY killed $eax
  MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %53:gr32 :: (store 4 into %ir.result)
  MOV8mi %stack.12.Class, 1, $noreg, 0, $noreg, 85 :: (store 1 into %ir.Class)
  %54:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %54:gr64
  CALL64pcrel32 @fclose, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  JMP_1 %bb.12

bb.11.if.else33:
; predecessors: %bb.3
  successors: %bb.12(0x80000000); %bb.12(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.17
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi $rip, 1, $noreg, @fre, $noreg, 5 :: (store 4 into @fre)
  MOV32mi $rip, 1, $noreg, @niter, $noreg, 200 :: (store 4 into @niter)
  MOV32mi $rip, 1, $noreg, @nmxh, $noreg, 10 :: (store 4 into @nmxh)
  %18:gr64 = MOV64ri 4590140797810047451
  MOV64mr $rip, 1, $noreg, @alpha, $noreg, %18:gr64 :: (store 8 into @alpha)
  MOV8mi %stack.12.Class, 1, $noreg, 0, $noreg, 66 :: (store 1 into %ir.Class)

bb.12.if.end35:
; predecessors: %bb.11, %bb.10
  successors: %bb.13(0x80000000); %bb.13(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %56:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %57:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  $xmm0 = COPY %56:fr64
  $xmm1 = COPY %57:fr64
  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %59:fr64 = COPY killed $xmm0
  MOVSDmr $rip, 1, $noreg, @dlmin, $noreg, %59:fr64 :: (store 8 into @dlmin)
  %59:fr64 = MULSDrm %59:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  MOVSDmr $rip, 1, $noreg, @dtime, $noreg, %59:fr64 :: (store 8 into @dtime)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.18
  $esi = MOV32ri 7
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %65:gr32 = MOV32rm $rip, 1, $noreg, @fre, $noreg :: (dereferenceable load 4 from @fre)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.19
  $esi = COPY %65:gr32
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %68:gr32 = MOV32rm $rip, 1, $noreg, @niter, $noreg :: (dereferenceable load 4 from @niter)
  %69:fr64 = MOVSDrm_alt $rip, 1, $noreg, @dtime, $noreg :: (dereferenceable load 8 from @dtime)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.20
  $esi = COPY %68:gr32
  $xmm0 = COPY %69:fr64
  $al = MOV8ri 1
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %73:gr32 = MOV32rm $rip, 1, $noreg, @nmxh, $noreg :: (dereferenceable load 4 from @nmxh)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.21
  $esi = COPY %73:gr32
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %76:fr64 = MOVSDrm_alt $rip, 1, $noreg, @alpha, $noreg :: (dereferenceable load 8 from @alpha)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.22
  $xmm0 = COPY %76:fr64
  $al = MOV8ri 1
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @top_constants, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

bb.13.for.cond:
; predecessors: %bb.12, %bb.14
  successors: %bb.14(0x7c000000), %bb.15(0x04000000); %bb.14(96.88%), %bb.15(3.12%)

  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 10, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.15, 15, implicit killed $eflags
  JMP_1 %bb.14

bb.14.for.body:
; predecessors: %bb.13
  successors: %bb.13(0x80000000); %bb.13(100.00%)

  %240:gr32 = MOV32rm %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %240:gr32
  CALL64pcrel32 @timer_clear, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  JMP_1 %bb.13

bb.15.for.end:
; predecessors: %bb.13
  successors: %bb.16(0x50000000), %bb.17(0x30000000); %bb.16(62.50%), %bb.17(37.50%)

  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
  JCC_1 %bb.17, 4, implicit killed $eflags
  JMP_1 %bb.16

bb.16.if.then43:
; predecessors: %bb.15
  successors: %bb.17(0x80000000); %bb.17(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 2
  CALL64pcrel32 @timer_start, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.17.if.end44:
; predecessors: %bb.15, %bb.16
  successors: %bb.18(0x50000000), %bb.19(0x30000000); %bb.18(62.50%), %bb.19(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @create_initial_grid, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %84:gr32 = MOV32rm $rip, 1, $noreg, @ntot, $noreg :: (dereferenceable load 4 from @ntot)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @ta1
  $esi = COPY %84:gr32
  $xmm0 = FsFLD0SD
  CALL64pcrel32 @r_init, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  undef %89.sub_32bit:gr64_nosp = MOV32rm $rip, 1, $noreg, @nelt, $noreg :: (dereferenceable load 4 from @nelt)
  %89.sub_32bit:gr64_nosp = SHL32ri %89.sub_32bit:gr64_nosp(tied-def 0), 3, implicit-def dead $eflags
  %91:gr32 = LEA64_32r %89:gr64_nosp, 2, %89:gr64_nosp, 0, $noreg
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @sje
  $esi = COPY %91:gr32
  $edx = MOV32ri -1
  CALL64pcrel32 @nr_init, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @coef, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @geom1, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @setdef, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @setpcmo_pre, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mi32 $rip, 1, $noreg, @time, $noreg, 0 :: (store 8 into @time)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @mortar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @prepwork, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %94:gr64 = LEA64r %stack.13.ifmortar, 1, $noreg, 0, $noreg
  $rdi = COPY %94:gr64
  $esi = MOV32r0 implicit-def dead $eflags
  CALL64pcrel32 @adaptation, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
  JCC_1 %bb.19, 4, implicit killed $eflags
  JMP_1 %bb.18

bb.18.if.then47:
; predecessors: %bb.17
  successors: %bb.19(0x80000000); %bb.19(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 2
  CALL64pcrel32 @timer_stop, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.19.if.end48:
; predecessors: %bb.17, %bb.18
  successors: %bb.20(0x80000000); %bb.20(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 1
  CALL64pcrel32 @timer_clear, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mi32 $rip, 1, $noreg, @time, $noreg, 0 :: (store 8 into @time)
  MOV32mi %stack.3.step, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.step)
  %201:gr64 = LEA64r %stack.13.ifmortar, 1, $noreg, 0, $noreg

bb.20.for.cond49:
; predecessors: %bb.19, %bb.64
  successors: %bb.21(0x7c000000), %bb.65(0x04000000); %bb.21(96.88%), %bb.65(3.12%)

  %97:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  CMP32rm %97:gr32, $rip, 1, $noreg, @niter, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @niter)
  JCC_1 %bb.65, 15, implicit killed $eflags
  JMP_1 %bb.21

bb.21.for.body51:
; predecessors: %bb.20
  successors: %bb.22(0x40000000), %bb.28(0x40000000); %bb.22(50.00%), %bb.28(50.00%)

  CMP32mi8 %stack.3.step, 1, $noreg, 0, $noreg, 1, implicit-def $eflags :: (dereferenceable load 4 from %ir.step)
  JCC_1 %bb.28, 5, implicit killed $eflags
  JMP_1 %bb.22

bb.22.if.then53:
; predecessors: %bb.21
  successors: %bb.23(0x80000000); %bb.23(100.00%)

  %163:gr32 = MOV32rm $rip, 1, $noreg, @ntot, $noreg :: (dereferenceable load 4 from @ntot)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @ta1
  $esi = COPY %163:gr32
  $xmm0 = FsFLD0SD
  CALL64pcrel32 @r_init, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mi32 $rip, 1, $noreg, @time, $noreg, 0 :: (store 8 into @time)
  MOV64mi32 %stack.11.nelt_tot, 1, $noreg, 0, $noreg, 0 :: (store 8 into %ir.nelt_tot)
  MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

bb.23.for.cond54:
; predecessors: %bb.22, %bb.26
  successors: %bb.24(0x7c000000), %bb.27(0x04000000); %bb.24(96.88%), %bb.27(3.12%)

  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 10, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.27, 15, implicit killed $eflags
  JMP_1 %bb.24

bb.24.for.body56:
; predecessors: %bb.23
  successors: %bb.25(0x40000000), %bb.26(0x40000000); %bb.25(50.00%), %bb.26(50.00%)

  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 2, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.26, 4, implicit killed $eflags
  JMP_1 %bb.25

bb.25.if.then58:
; predecessors: %bb.24
  successors: %bb.26(0x80000000); %bb.26(100.00%)

  %239:gr32 = MOV32rm %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %239:gr32
  CALL64pcrel32 @timer_clear, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.26.if.end59:
; predecessors: %bb.24, %bb.25
  successors: %bb.23(0x80000000); %bb.23(100.00%)

  INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  JMP_1 %bb.23

bb.27.for.end62:
; predecessors: %bb.23
  successors: %bb.28(0x80000000); %bb.28(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 1
  CALL64pcrel32 @timer_start, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.28.if.end63:
; predecessors: %bb.21, %bb.27
  successors: %bb.29(0x50000000), %bb.30(0x30000000); %bb.29(62.50%), %bb.30(37.50%)

  %169:gr32 = MOV32rm %stack.13.ifmortar, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ifmortar)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %169:gr32
  CALL64pcrel32 @convect, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
  JCC_1 %bb.30, 4, implicit killed $eflags
  JMP_1 %bb.29

bb.29.if.then65:
; predecessors: %bb.28
  successors: %bb.30(0x80000000); %bb.30(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 9
  CALL64pcrel32 @timer_start, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.30.if.end66:
; predecessors: %bb.28, %bb.29
  successors: %bb.31(0x80000000); %bb.31(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @tmort
  $rsi = MOV32ri64 @ta1
  CALL64pcrel32 @transf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi %stack.4.ie, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.ie)

bb.31.for.cond67:
; predecessors: %bb.30, %bb.32
  successors: %bb.32(0x7c000000), %bb.33(0x04000000); %bb.32(96.88%), %bb.33(3.12%)

  %173:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  CMP32rm %173:gr32, $rip, 1, $noreg, @nelt, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @nelt)
  JCC_1 %bb.33, 13, implicit killed $eflags
  JMP_1 %bb.32

bb.32.for.body69:
; predecessors: %bb.31
  successors: %bb.31(0x80000000); %bb.31(100.00%)

  %232:gr64_nosp = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  %233:gr64 = IMUL64rri32 %232:gr64_nosp, 1000, implicit-def dead $eflags
  %234:gr64 = LEA64r %233:gr64, 1, $noreg, @ta2, $noreg
  %235:gr64 = LEA64r %233:gr64, 1, $noreg, @ta1, $noreg
  %236:gr32 = MOV32rm $noreg, 4, %232:gr64_nosp, @size_e, $noreg :: (load 4 from %ir.arrayidx75)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %234:gr64
  $rsi = COPY %235:gr64
  $edx = COPY %236:gr32
  CALL64pcrel32 @laplacian, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  INC32m %stack.4.ie, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.ie), (dereferenceable load 4 from %ir.ie)
  JMP_1 %bb.31

bb.33.for.end78:
; predecessors: %bb.31
  successors: %bb.34(0x80000000); %bb.34(100.00%)

  MOV32mi %stack.4.ie, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.ie)

bb.34.for.cond79:
; predecessors: %bb.33, %bb.44
  successors: %bb.35(0x7c000000), %bb.45(0x04000000); %bb.35(96.88%), %bb.45(3.12%)

  %175:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  CMP32rm %175:gr32, $rip, 1, $noreg, @nelt, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @nelt)
  JCC_1 %bb.45, 13, implicit killed $eflags
  JMP_1 %bb.35

bb.35.for.body81:
; predecessors: %bb.34
  successors: %bb.36(0x80000000); %bb.36(100.00%)

  MOV32mi %stack.8.k, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.k)

bb.36.for.cond82:
; predecessors: %bb.35, %bb.43
  successors: %bb.37(0x7c000000), %bb.44(0x04000000); %bb.37(96.88%), %bb.44(3.12%)

  CMP32mi8 %stack.8.k, 1, $noreg, 0, $noreg, 4, implicit-def $eflags :: (dereferenceable load 4 from %ir.k)
  JCC_1 %bb.44, 15, implicit killed $eflags
  JMP_1 %bb.37

bb.37.for.body84:
; predecessors: %bb.36
  successors: %bb.38(0x80000000); %bb.38(100.00%)

  MOV32mi %stack.7.j, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.j)

bb.38.for.cond85:
; predecessors: %bb.37, %bb.42
  successors: %bb.39(0x7c000000), %bb.43(0x04000000); %bb.39(96.88%), %bb.43(3.12%)

  CMP32mi8 %stack.7.j, 1, $noreg, 0, $noreg, 4, implicit-def $eflags :: (dereferenceable load 4 from %ir.j)
  JCC_1 %bb.43, 15, implicit killed $eflags
  JMP_1 %bb.39

bb.39.for.body87:
; predecessors: %bb.38
  successors: %bb.40(0x80000000); %bb.40(100.00%)

  MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.40.for.cond88:
; predecessors: %bb.39, %bb.41
  successors: %bb.41(0x7c000000), %bb.42(0x04000000); %bb.41(96.88%), %bb.42(3.12%)

  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 4, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.42, 15, implicit killed $eflags
  JMP_1 %bb.41

bb.41.for.body90:
; predecessors: %bb.40
  successors: %bb.40(0x80000000); %bb.40(100.00%)

  %221:gr64 = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  %222:gr64 = IMUL64rri32 %221:gr64, 1000, implicit-def dead $eflags
  %223:gr64 = MOVSX64rm32 %stack.8.k, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.k)
  %228:gr64 = IMUL64rri32 %223:gr64, 200, implicit-def dead $eflags
  %228:gr64 = ADD64rr %228:gr64(tied-def 0), %222:gr64, implicit-def dead $eflags
  %225:gr64_nosp = MOVSX64rm32 %stack.7.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
  %226:gr64_nosp = LEA64r %225:gr64_nosp, 4, %225:gr64_nosp, 0, $noreg
  %227:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %229:gr64 = LEA64r %228:gr64, 8, %226:gr64_nosp, 0, $noreg
  %231:fr64 = MOVSDrm_alt %229:gr64, 8, %227:gr64_nosp, @trhs, $noreg :: (load 8 from %ir.arrayidx98)
  %231:fr64 = SUBSDrm %231:fr64(tied-def 0), %229:gr64, 8, %227:gr64_nosp, @ta2, $noreg :: (load 8 from %ir.arrayidx106)
  MOVSDmr %229:gr64, 8, %227:gr64_nosp, @trhs, $noreg, %231:fr64 :: (store 8 into %ir.arrayidx114)
  INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  JMP_1 %bb.40

bb.42.for.end117:
; predecessors: %bb.40
  successors: %bb.38(0x80000000); %bb.38(100.00%)

  INC32m %stack.7.j, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.j), (dereferenceable load 4 from %ir.j)
  JMP_1 %bb.38

bb.43.for.end120:
; predecessors: %bb.38
  successors: %bb.36(0x80000000); %bb.36(100.00%)

  INC32m %stack.8.k, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.k), (dereferenceable load 4 from %ir.k)
  JMP_1 %bb.36

bb.44.for.end123:
; predecessors: %bb.36
  successors: %bb.34(0x80000000); %bb.34(100.00%)

  INC32m %stack.4.ie, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.ie), (dereferenceable load 4 from %ir.ie)
  JMP_1 %bb.34

bb.45.for.end126:
; predecessors: %bb.34
  successors: %bb.46(0x50000000), %bb.47(0x30000000); %bb.46(62.50%), %bb.47(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @rmor
  $rsi = MOV32ri64 @trhs
  CALL64pcrel32 @transfb, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
  JCC_1 %bb.47, 4, implicit killed $eflags
  JMP_1 %bb.46

bb.46.if.then128:
; predecessors: %bb.45
  successors: %bb.47(0x80000000); %bb.47(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 9
  CALL64pcrel32 @timer_stop, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.47.if.end129:
; predecessors: %bb.45, %bb.46
  successors: %bb.48(0x80000000); %bb.48(100.00%)

  MOV32mi %stack.4.ie, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.ie)

bb.48.for.cond130:
; predecessors: %bb.47, %bb.54
  successors: %bb.49(0x7c000000), %bb.55(0x04000000); %bb.49(96.88%), %bb.55(3.12%)

  %180:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  CMP32rm %180:gr32, $rip, 1, $noreg, @nelt, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @nelt)
  JCC_1 %bb.55, 13, implicit killed $eflags
  JMP_1 %bb.49

bb.49.for.body132:
; predecessors: %bb.48
  successors: %bb.50(0x80000000); %bb.50(100.00%)

  MOV32mi %stack.5.iside, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.iside)

bb.50.for.cond133:
; predecessors: %bb.49, %bb.53
  successors: %bb.51(0x7c000000), %bb.54(0x04000000); %bb.51(96.88%), %bb.54(3.12%)

  CMP32mi8 %stack.5.iside, 1, $noreg, 0, $noreg, 5, implicit-def $eflags :: (dereferenceable load 4 from %ir.iside)
  JCC_1 %bb.54, 15, implicit killed $eflags
  JMP_1 %bb.51

bb.51.for.body135:
; predecessors: %bb.50
  successors: %bb.52(0x30000000), %bb.53(0x50000000); %bb.52(37.50%), %bb.53(62.50%)

  %206:gr64_nosp = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  %207:gr64_nosp = LEA64r %206:gr64_nosp, 2, %206:gr64_nosp, 0, $noreg
  %209:gr64 = MOVSX64rm32 %stack.5.iside, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.iside)
  %209:gr64 = SHL64ri %209:gr64(tied-def 0), 2, implicit-def dead $eflags
  CMP32mi8 %209:gr64, 8, %207:gr64_nosp, @cbc, $noreg, 0, implicit-def $eflags :: (load 4 from %ir.arrayidx139)
  JCC_1 %bb.53, 5, implicit killed $eflags
  JMP_1 %bb.52

bb.52.if.then141:
; predecessors: %bb.51
  successors: %bb.53(0x80000000); %bb.53(100.00%)

  %210:gr64 = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  %211:gr64 = IMUL64rri32 %210:gr64, 1000, implicit-def dead $eflags
  %212:gr64 = LEA64r %211:gr64, 1, $noreg, @trhs, $noreg
  %213:gr32 = MOV32rm %stack.5.iside, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.iside)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %212:gr64
  $esi = COPY %213:gr32
  $xmm0 = FsFLD0SD
  CALL64pcrel32 @facev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.53.if.end145:
; predecessors: %bb.51, %bb.52
  successors: %bb.50(0x80000000); %bb.50(100.00%)

  INC32m %stack.5.iside, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.iside), (dereferenceable load 4 from %ir.iside)
  JMP_1 %bb.50

bb.54.for.end148:
; predecessors: %bb.50
  successors: %bb.48(0x80000000); %bb.48(100.00%)

  INC32m %stack.4.ie, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.ie), (dereferenceable load 4 from %ir.ie)
  JMP_1 %bb.48

bb.55.for.end151:
; predecessors: %bb.48
  successors: %bb.56(0x50000000), %bb.57(0x30000000); %bb.56(62.50%), %bb.57(37.50%)

  %182:gr32 = MOV32rm $rip, 1, $noreg, @nmor, $noreg :: (dereferenceable load 4 from @nmor)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @rmor
  $rsi = MOV32ri64 @tmmor
  $edx = COPY %182:gr32
  CALL64pcrel32 @col2, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %185:gr32 = MOV32rm %stack.13.ifmortar, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ifmortar)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %185:gr32
  CALL64pcrel32 @diffusion, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
  JCC_1 %bb.57, 4, implicit killed $eflags
  JMP_1 %bb.56

bb.56.if.then153:
; predecessors: %bb.55
  successors: %bb.57(0x80000000); %bb.57(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 10
  CALL64pcrel32 @timer_start, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.57.if.end154:
; predecessors: %bb.55, %bb.56
  successors: %bb.58(0x50000000), %bb.59(0x30000000); %bb.58(62.50%), %bb.59(37.50%)

  %187:gr32 = MOV32rm $rip, 1, $noreg, @ntot, $noreg :: (dereferenceable load 4 from @ntot)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @ta1
  $rsi = MOV32ri64 @t
  $edx = COPY %187:gr32
  CALL64pcrel32 @add2, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
  JCC_1 %bb.59, 4, implicit killed $eflags
  JMP_1 %bb.58

bb.58.if.then156:
; predecessors: %bb.57
  successors: %bb.59(0x80000000); %bb.59(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 10
  CALL64pcrel32 @timer_stop, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.59.if.end157:
; predecessors: %bb.57, %bb.58
  successors: %bb.60(0x50000000), %bb.63(0x30000000); %bb.60(62.50%), %bb.63(37.50%)

  %192:fr64 = MOVSDrm_alt $rip, 1, $noreg, @time, $noreg :: (dereferenceable load 8 from @time)
  %192:fr64 = ADDSDrm %192:fr64(tied-def 0), $rip, 1, $noreg, @dtime, $noreg :: (dereferenceable load 8 from @dtime)
  MOVSDmr $rip, 1, $noreg, @time, $noreg, %192:fr64 :: (store 8 into @time)
  CMP32mi8 %stack.3.step, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.step)
  JCC_1 %bb.63, 4, implicit killed $eflags
  JMP_1 %bb.60

bb.60.land.lhs.true:
; predecessors: %bb.59
  successors: %bb.61(0x40000000), %bb.63(0x40000000); %bb.61(50.00%), %bb.63(50.00%)

  %193:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  %194:gr32 = MOV32rm $rip, 1, $noreg, @fre, $noreg :: (dereferenceable load 4 from @fre)
  $eax = COPY %193:gr32
  CDQ implicit-def $eax, implicit-def $edx, implicit killed $eax
  IDIV32r %194:gr32, implicit-def $eax, implicit-def dead $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
  %196:gr32 = COPY killed $eax
  %196:gr32 = nsw IMUL32rr %196:gr32(tied-def 0), %194:gr32, implicit-def dead $eflags
  CMP32rr %196:gr32, %193:gr32, implicit-def $eflags
  JCC_1 %bb.63, 5, implicit killed $eflags
  JMP_1 %bb.61

bb.61.if.then161:
; predecessors: %bb.60
  successors: %bb.62(0x40000000), %bb.64(0x40000000); %bb.62(50.00%), %bb.64(50.00%)

  %198:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  CMP32rm %198:gr32, $rip, 1, $noreg, @niter, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @niter)
  JCC_1 %bb.64, 4, implicit killed $eflags
  JMP_1 %bb.62

bb.62.if.then163:
; predecessors: %bb.61
  successors: %bb.64(0x80000000); %bb.64(100.00%)

  %200:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %201:gr64
  $esi = COPY %200:gr32
  CALL64pcrel32 @adaptation, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  JMP_1 %bb.64

bb.63.if.else165:
; predecessors: %bb.59, %bb.60
  successors: %bb.64(0x80000000); %bb.64(100.00%)

  MOV32mi %stack.13.ifmortar, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.ifmortar)

bb.64.if.end166:
; predecessors: %bb.63, %bb.61, %bb.62
  successors: %bb.20(0x80000000); %bb.20(100.00%)

  %203:fr64 = CVTSI2SDrm $rip, 1, $noreg, @nelt, $noreg :: (dereferenceable load 4 from @nelt)
  %203:fr64 = ADDSDrm %203:fr64(tied-def 0), %stack.11.nelt_tot, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.nelt_tot)
  MOVSDmr %stack.11.nelt_tot, 1, $noreg, 0, $noreg, %203:fr64 :: (store 8 into %ir.nelt_tot)
  INC32m %stack.3.step, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.step), (dereferenceable load 4 from %ir.step)
  JMP_1 %bb.20

bb.65.for.end170:
; predecessors: %bb.20
  successors: %bb.66(0x50000000), %bb.78(0x30000000); %bb.66(62.50%), %bb.78(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 1
  CALL64pcrel32 @timer_stop, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 1
  CALL64pcrel32 @timer_read, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %100:fr64 = COPY killed $xmm0
  MOVSDmr %stack.10.tmax, 1, $noreg, 0, $noreg, %100:fr64 :: (store 8 into %ir.tmax)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %101:gr64 = LEA64r %stack.12.Class, 1, $noreg, 0, $noreg
  %102:gr64 = LEA64r %stack.14.verified, 1, $noreg, 0, $noreg
  $rdi = COPY %101:gr64
  $rsi = COPY %102:gr64
  CALL64pcrel32 @verify, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %104:gr32 = IMUL32rmi8 $rip, 1, $noreg, @nmxh, $noreg, 125, implicit-def dead $eflags :: (dereferenceable load 4 from @nmxh)
  %104:gr32 = ADD32ri8 %104:gr32(tied-def 0), 125, implicit-def dead $eflags
  %109:fr64 = CVTSI2SDrr %104:gr32
  %109:fr64 = MULSDrm %109:fr64(tied-def 0), %stack.11.nelt_tot, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.nelt_tot)
  %107:fr64 = MOVSDrm_alt %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  %108:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %108:fr64 = MULSDrr %108:fr64(tied-def 0), %107:fr64
  %109:fr64 = DIVSDrr %109:fr64(tied-def 0), %108:fr64
  MOVSDmr %stack.9.mflops, 1, $noreg, 0, $noreg, %109:fr64 :: (store 8 into %ir.mflops)
  %110:gr32 = MOVSX32rm8 %stack.12.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
  %111:gr32 = MOV32rm $rip, 1, $noreg, @niter, $noreg :: (dereferenceable load 4 from @niter)
  undef %245.sub_32bit:gr64_with_sub_8bit = MOV32rm %stack.14.verified, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.verified)
  ADJCALLSTACKDOWN64 88, 0, 88, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.23
  $esi = COPY %110:gr32
  $edx = MOV32ri 7
  $ecx = MOV32ri 0
  $r8d = MOV32ri 0
  $r9d = COPY %111:gr32
  $xmm0 = COPY %107:fr64
  $xmm1 = COPY %109:fr64
  PUSH64i32 @.str.33, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.32, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.31, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.30, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.29, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.28, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.27, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.26, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.25, implicit-def $rsp, implicit $rsp
  PUSH64r %245:gr64_with_sub_8bit, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.24, implicit-def $rsp, implicit $rsp
  CALL64pcrel32 @print_results, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $r8d, implicit killed $r9d, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 88, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
  JCC_1 %bb.78, 4, implicit killed $eflags
  JMP_1 %bb.66

bb.66.if.then179:
; predecessors: %bb.65
  successors: %bb.67(0x80000000); %bb.67(100.00%)

  MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

bb.67.for.cond180:
; predecessors: %bb.66, %bb.68
  successors: %bb.68(0x7c000000), %bb.69(0x04000000); %bb.68(96.88%), %bb.69(3.12%)

  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 10, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.69, 15, implicit killed $eflags
  JMP_1 %bb.68

bb.68.for.body183:
; predecessors: %bb.67
  successors: %bb.67(0x80000000); %bb.67(100.00%)

  %158:gr32 = MOV32rm %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %158:gr32
  CALL64pcrel32 @timer_read, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %159:fr64 = COPY killed $xmm0
  %160:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOVSDmr %stack.16.trecs, 8, %160:gr64_nosp, 0, $noreg, %159:fr64 :: (store 8 into %ir.arrayidx186)
  INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  JMP_1 %bb.67

bb.69.for.end189:
; predecessors: %bb.67
  successors: %bb.70(0x50000000), %bb.71(0x30000000); %bb.70(62.50%), %bb.71(37.50%)

  %119:fr64 = MOVSDrm_alt %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  %120:fr64 = FsFLD0SD
  UCOMISDrr %119:fr64, %120:fr64, implicit-def $eflags
  JCC_1 %bb.71, 5, implicit $eflags
  JCC_1 %bb.71, 10, implicit killed $eflags
  JMP_1 %bb.70

bb.70.if.then192:
; predecessors: %bb.69
  successors: %bb.71(0x80000000); %bb.71(100.00%)

  %121:gr64 = MOV64ri 4607182418800017408
  MOV64mr %stack.10.tmax, 1, $noreg, 0, $noreg, %121:gr64 :: (store 8 into %ir.tmax)

bb.71.if.end193:
; predecessors: %bb.69, %bb.70
  successors: %bb.72(0x80000000); %bb.72(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.34
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
  %241:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)

bb.72.for.cond195:
; predecessors: %bb.71, %bb.77
  successors: %bb.73(0x7c000000), %bb.78(0x04000000); %bb.73(96.88%), %bb.78(3.12%)

  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 10, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.78, 15, implicit killed $eflags
  JMP_1 %bb.73

bb.73.for.body198:
; predecessors: %bb.72
  successors: %bb.74(0x40000000), %bb.75(0x40000000); %bb.74(50.00%), %bb.75(50.00%)

  %129:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %130:gr64 = MOV64rm %stack.17.t_names, 8, %129:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx200)
  %131:fr64 = MOVSDrm_alt %stack.16.trecs, 8, %129:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx204)
  %133:fr64 = COPY %131:fr64
  %133:fr64 = MULSDrr %133:fr64(tied-def 0), %241:fr64
  %133:fr64 = DIVSDrm %133:fr64(tied-def 0), %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.35
  $rsi = COPY %130:gr64
  $xmm0 = COPY %131:fr64
  $xmm1 = COPY %133:fr64
  $al = MOV8ri 2
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 4, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.75, 5, implicit killed $eflags
  JMP_1 %bb.74

bb.74.if.then210:
; predecessors: %bb.73
  successors: %bb.77(0x80000000); %bb.77(100.00%)

  %151:fr64 = MOVSDrm_alt %stack.16.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx211)
  %151:fr64 = SUBSDrm %151:fr64(tied-def 0), %stack.16.trecs, 1, $noreg, 32, $noreg :: (dereferenceable load 8 from %ir.arrayidx212, align 16)
  MOVSDmr %stack.15.t2, 1, $noreg, 0, $noreg, %151:fr64 :: (store 8 into %ir.t2)
  %153:fr64 = COPY %151:fr64
  %153:fr64 = MULSDrr %153:fr64(tied-def 0), %241:fr64
  %153:fr64 = DIVSDrm %153:fr64(tied-def 0), %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.36
  $rsi = MOV32ri64 @.str.37
  $xmm0 = COPY %151:fr64
  $xmm1 = COPY %153:fr64
  $al = MOV8ri 2
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  JMP_1 %bb.77

bb.75.if.else217:
; predecessors: %bb.73
  successors: %bb.76(0x40000000), %bb.77(0x40000000); %bb.76(50.00%), %bb.77(50.00%)

  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 7, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.77, 5, implicit killed $eflags
  JMP_1 %bb.76

bb.76.if.then220:
; predecessors: %bb.75
  successors: %bb.77(0x80000000); %bb.77(100.00%)

  %143:fr64 = MOVSDrm_alt %stack.16.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx221)
  %143:fr64 = SUBSDrm %143:fr64(tied-def 0), %stack.16.trecs, 1, $noreg, 48, $noreg :: (dereferenceable load 8 from %ir.arrayidx222, align 16)
  %143:fr64 = SUBSDrm %143:fr64(tied-def 0), %stack.16.trecs, 1, $noreg, 56, $noreg :: (dereferenceable load 8 from %ir.arrayidx224)
  MOVSDmr %stack.15.t2, 1, $noreg, 0, $noreg, %143:fr64 :: (store 8 into %ir.t2)
  %145:fr64 = COPY %143:fr64
  %145:fr64 = MULSDrr %145:fr64(tied-def 0), %241:fr64
  %145:fr64 = DIVSDrm %145:fr64(tied-def 0), %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.36
  $rsi = MOV32ri64 @.str.38
  $xmm0 = COPY %143:fr64
  $xmm1 = COPY %145:fr64
  $al = MOV8ri 2
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.77.if.end230:
; predecessors: %bb.75, %bb.76, %bb.74
  successors: %bb.72(0x80000000); %bb.72(100.00%)

  INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  JMP_1 %bb.72

bb.78.if.end234:
; predecessors: %bb.65, %bb.72

  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, killed $eax

# End machine code for function main.

********** MI Scheduling **********
main:%bb.0 entry
  From: %4:gr64 = COPY killed $rax
    To: JCC_1 %bb.2, 4, implicit killed $eflags
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %4:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(2): Data Latency=0 Reg=%4
    SU(1): Data Latency=0 Reg=%4
  Single Issue       : false;
SU(1):   MOV64mr %stack.18.fp, 1, $noreg, 0, $noreg, %4:gr64 :: (store 8 into %ir.fp)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%4
  Single Issue       : false;
SU(2):   TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%4
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.2, 4, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %stack.18.fp, 1, $noreg, 0, $noreg, %4:gr64 :: (store 8 into %ir.fp)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %4:gr64 = COPY killed $rax
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %4:gr64 = COPY killed $rax
SU(1):   MOV64mr %stack.18.fp, 1, $noreg, 0, $noreg, %4:gr64 :: (store 8 into %ir.fp)
SU(2):   TEST64rr %4:gr64, %4:gr64, implicit-def $eflags

********** MI Scheduling **********
main:%bb.0 entry
  From: $rdi = MOV32ri64 @.str
    To: CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.1
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   $rdi = MOV32ri64 @.str
SU(1):   $rsi = MOV32ri64 @.str.1

********** MI Scheduling **********
main:%bb.0 entry
  From: %1:gr64 = COPY $rsi
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 7
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %1:gr64 = COPY $rsi
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(4): Data Latency=0 Reg=%1
  Single Issue       : false;
SU(1):   %0:gr32 = COPY $edi
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(3): Data Latency=0 Reg=%0
  Single Issue       : false;
SU(2):   MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(3):   MOV32mr %stack.1.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Data Latency=0 Reg=%0
  Single Issue       : false;
SU(4):   MOV64mr %stack.2.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%1
  Single Issue       : false;
SU(5):   MOV64mi32 %stack.11.nelt_tot, 1, $noreg, 0, $noreg, 0 :: (store 8 into %ir.nelt_tot)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(6):   MOV32mi %stack.13.ifmortar, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.ifmortar)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 5 4 3 2 
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) MOV32mi %stack.13.ifmortar, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.ifmortar)
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 5 4 3 
  Cand SU(2) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) MOV64mi32 %stack.11.nelt_tot, 1, $noreg, 0, $noreg, 0 :: (store 8 into %ir.nelt_tot)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 4 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) MOV64mr %stack.2.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 0 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) MOV32mr %stack.1.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  Ready @0c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 0 1 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
  Ready @1c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %0:gr32 = COPY $edi
  Ready @1c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %1:gr64 = COPY $rsi
  Ready @1c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %1:gr64 = COPY $rsi
SU(1):   %0:gr32 = COPY $edi
SU(2):   MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
SU(3):   MOV32mr %stack.1.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
SU(4):   MOV64mr %stack.2.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
SU(5):   MOV64mi32 %stack.11.nelt_tot, 1, $noreg, 0, $noreg, 0 :: (store 8 into %ir.nelt_tot)
SU(6):   MOV32mi %stack.13.ifmortar, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.ifmortar)

********** MI Scheduling **********
main:%bb.1 if.then
  From: MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 12
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GR16=2
Live In: 
Live Out: %5 
Live Thru: 
  LiveReg: %5
Top Pressure:

Bottom Pressure:
GR16=2
Excess PSets: 
SU(0):   MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : 
  Single Issue       : false;
SU(1):   MOV64mi32 %stack.17.t_names, 1, $noreg, 8, $noreg, @.str.2 :: (store 8 into %ir.arrayidx)
  # preds left       : 0
  # succs left       : 9
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(2):   MOV64mi32 %stack.17.t_names, 1, $noreg, 16, $noreg, @.str.3 :: (store 8 into %ir.arrayidx1, align 16)
  # preds left       : 1
  # succs left       : 8
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(3):   MOV64mi32 %stack.17.t_names, 1, $noreg, 24, $noreg, @.str.4 :: (store 8 into %ir.arrayidx2)
  # preds left       : 2
  # succs left       : 7
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(4):   MOV64mi32 %stack.17.t_names, 1, $noreg, 32, $noreg, @.str.5 :: (store 8 into %ir.arrayidx3, align 16)
  # preds left       : 3
  # succs left       : 6
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(5):   MOV64mi32 %stack.17.t_names, 1, $noreg, 40, $noreg, @.str.6 :: (store 8 into %ir.arrayidx4)
  # preds left       : 4
  # succs left       : 5
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(6):   MOV64mi32 %stack.17.t_names, 1, $noreg, 48, $noreg, @.str.7 :: (store 8 into %ir.arrayidx5, align 16)
  # preds left       : 5
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   MOV64mi32 %stack.17.t_names, 1, $noreg, 56, $noreg, @.str.8 :: (store 8 into %ir.arrayidx6)
  # preds left       : 6
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(8):   MOV64mi32 %stack.17.t_names, 1, $noreg, 64, $noreg, @.str.9 :: (store 8 into %ir.arrayidx7, align 16)
  # preds left       : 7
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(9):   MOV64mi32 %stack.17.t_names, 1, $noreg, 72, $noreg, @.str.10 :: (store 8 into %ir.arrayidx8)
  # preds left       : 8
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(10): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(10):   MOV64mi32 %stack.17.t_names, 1, $noreg, 80, $noreg, @.str.11 :: (store 8 into %ir.arrayidx9, align 16)
  # preds left       : 9
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(11):   %5:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(11): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 10 0 11 
  Cand SU(10) ORDER                              
  Cand SU(11) ORDER                              
Pick Bot ORDER     
Scheduling SU(11) %5:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
Bottom Pressure:

  Ready @3c
  BotQ.A BotLatency SU(11) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 10 0 
  Cand SU(10) ORDER                              
Pick Bot ORDER     
Scheduling SU(10) MOV64mi32 %stack.17.t_names, 1, $noreg, 80, $noreg, @.str.11 :: (store 8 into %ir.arrayidx9, align 16)
Bottom Pressure:

  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 9 
  Cand SU(0) ORDER                              
  Cand SU(9) ORDER                              
Pick Bot ORDER     
Scheduling SU(9) MOV64mi32 %stack.17.t_names, 1, $noreg, 72, $noreg, @.str.10 :: (store 8 into %ir.arrayidx8)
Bottom Pressure:

  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 8 
  Cand SU(0) ORDER                              
  Cand SU(8) ORDER                              
Pick Bot ORDER     
Scheduling SU(8) MOV64mi32 %stack.17.t_names, 1, $noreg, 64, $noreg, @.str.9 :: (store 8 into %ir.arrayidx7, align 16)
Bottom Pressure:

  Ready @0c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 7 
  Cand SU(0) ORDER                              
  Cand SU(7) ORDER                              
Pick Bot ORDER     
Scheduling SU(7) MOV64mi32 %stack.17.t_names, 1, $noreg, 56, $noreg, @.str.8 :: (store 8 into %ir.arrayidx6)
Bottom Pressure:

  Ready @1c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 6 
  Cand SU(0) ORDER                              
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) MOV64mi32 %stack.17.t_names, 1, $noreg, 48, $noreg, @.str.7 :: (store 8 into %ir.arrayidx5, align 16)
Bottom Pressure:

  Ready @1c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 5 
  Cand SU(0) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) MOV64mi32 %stack.17.t_names, 1, $noreg, 40, $noreg, @.str.6 :: (store 8 into %ir.arrayidx4)
Bottom Pressure:

  Ready @1c
BotQ.A @1c
  Retired: 7
  Executed: 1c
  Critical: 1c, 7 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 4 
  Cand SU(0) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) MOV64mi32 %stack.17.t_names, 1, $noreg, 32, $noreg, @.str.5 :: (store 8 into %ir.arrayidx3, align 16)
Bottom Pressure:

  Ready @1c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 2c
  Critical: 2c, 8 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 
  Cand SU(0) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) MOV64mi32 %stack.17.t_names, 1, $noreg, 24, $noreg, @.str.4 :: (store 8 into %ir.arrayidx2)
Bottom Pressure:

  Ready @2c
BotQ.A @2c
  Retired: 9
  Executed: 2c
  Critical: 2c, 9 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 
  Cand SU(0) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) MOV64mi32 %stack.17.t_names, 1, $noreg, 16, $noreg, @.str.3 :: (store 8 into %ir.arrayidx1, align 16)
Bottom Pressure:

  Ready @2c
BotQ.A @2c
  Retired: 10
  Executed: 2c
  Critical: 2c, 10 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) MOV64mi32 %stack.17.t_names, 1, $noreg, 8, $noreg, @.str.2 :: (store 8 into %ir.arrayidx)
Bottom Pressure:

  Ready @2c
BotQ.A @2c
  Retired: 11
  Executed: 2c
  Critical: 2c, 11 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
Bottom Pressure:

  Ready @2c
  *** Max MOps 4 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 12
  Executed: 3c
  Critical: 3c, 12 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.1 ***
SU(0):   MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
SU(1):   MOV64mi32 %stack.17.t_names, 1, $noreg, 8, $noreg, @.str.2 :: (store 8 into %ir.arrayidx)
SU(2):   MOV64mi32 %stack.17.t_names, 1, $noreg, 16, $noreg, @.str.3 :: (store 8 into %ir.arrayidx1, align 16)
SU(3):   MOV64mi32 %stack.17.t_names, 1, $noreg, 24, $noreg, @.str.4 :: (store 8 into %ir.arrayidx2)
SU(4):   MOV64mi32 %stack.17.t_names, 1, $noreg, 32, $noreg, @.str.5 :: (store 8 into %ir.arrayidx3, align 16)
SU(5):   MOV64mi32 %stack.17.t_names, 1, $noreg, 40, $noreg, @.str.6 :: (store 8 into %ir.arrayidx4)
SU(6):   MOV64mi32 %stack.17.t_names, 1, $noreg, 48, $noreg, @.str.7 :: (store 8 into %ir.arrayidx5, align 16)
SU(7):   MOV64mi32 %stack.17.t_names, 1, $noreg, 56, $noreg, @.str.8 :: (store 8 into %ir.arrayidx6)
SU(8):   MOV64mi32 %stack.17.t_names, 1, $noreg, 64, $noreg, @.str.9 :: (store 8 into %ir.arrayidx7, align 16)
SU(9):   MOV64mi32 %stack.17.t_names, 1, $noreg, 72, $noreg, @.str.10 :: (store 8 into %ir.arrayidx8)
SU(10):   MOV64mi32 %stack.17.t_names, 1, $noreg, 80, $noreg, @.str.11 :: (store 8 into %ir.arrayidx9, align 16)
SU(11):   %5:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)

********** MI Scheduling **********
main:%bb.3 if.end
  From: %13:gr64 = COPY killed $rax
    To: JCC_1 %bb.11, 4, implicit killed $eflags
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %13:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(2): Data Latency=0 Reg=%13
    SU(1): Data Latency=0 Reg=%13
  Single Issue       : false;
SU(1):   MOV64mr %stack.18.fp, 1, $noreg, 0, $noreg, %13:gr64 :: (store 8 into %ir.fp)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%13
  Single Issue       : false;
SU(2):   TEST64rr %13:gr64, %13:gr64, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%13
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.11, 4, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) TEST64rr %13:gr64, %13:gr64, implicit-def $eflags
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %stack.18.fp, 1, $noreg, 0, $noreg, %13:gr64 :: (store 8 into %ir.fp)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %13:gr64 = COPY killed $rax
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.3 ***
SU(0):   %13:gr64 = COPY killed $rax
SU(1):   MOV64mr %stack.18.fp, 1, $noreg, 0, $noreg, %13:gr64 :: (store 8 into %ir.fp)
SU(2):   TEST64rr %13:gr64, %13:gr64, implicit-def $eflags

********** MI Scheduling **********
main:%bb.3 if.end
  From: $rdi = MOV32ri64 @.str.13
    To: CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.13
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.1
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.13
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.3 ***
SU(0):   $rdi = MOV32ri64 @.str.13
SU(1):   $rsi = MOV32ri64 @.str.1

********** MI Scheduling **********
main:%bb.3 if.end
  From: $rdi = MOV32ri64 @.str.12
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.12
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.12
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.3 ***
SU(0):   $rdi = MOV32ri64 @.str.12
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.4 if.then14
  From: %26:gr32 = COPY killed $eax
    To: End RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %26:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Data Latency=0 Reg=%26
  Single Issue       : false;
SU(1):   MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %26:gr32 :: (store 4 into %ir.result)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%26
  Single Issue       : false;
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %26:gr32 :: (store 4 into %ir.result)
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %26:gr32 = COPY killed $eax
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   %26:gr32 = COPY killed $eax
SU(1):   MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %26:gr32 :: (store 4 into %ir.result)

********** MI Scheduling **********
main:%bb.4 if.then14
  From: $rdi = COPY %23:gr64
    To: CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %23:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.15
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $rdx = MOV32ri64 @fre
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(3):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=1 Artificial
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 1 0 
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 1 
  Cand SU(0) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(0) $rdi = COPY %23:gr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $rdx = MOV32ri64 @fre
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) $rsi = MOV32ri64 @.str.15
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(1):   $rsi = MOV32ri64 @.str.15
SU(2):   $rdx = MOV32ri64 @fre
SU(0):   $rdi = COPY %23:gr64
SU(3):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.4 if.then14
  From: $rdi = MOV32ri64 @.str.14
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.14
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.14
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   $rdi = MOV32ri64 @.str.14
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.5 while.cond
  From: %28:gr32 = COPY killed $eax
    To: JCC_1 %bb.5, 5, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %28:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%28
  Single Issue       : false;
SU(1):   CMP32ri8 %28:gr32, 10, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%28
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.5, 5, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32ri8 %28:gr32, 10, implicit-def $eflags
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %28:gr32 = COPY killed $eax
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.5 ***
SU(0):   %28:gr32 = COPY killed $eax
SU(1):   CMP32ri8 %28:gr32, 10, implicit-def $eflags

********** MI Scheduling **********
main:%bb.6 while.end
  From: %35:gr32 = COPY killed $eax
    To: End RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %35:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Data Latency=0 Reg=%35
  Single Issue       : false;
SU(1):   MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %35:gr32 :: (store 4 into %ir.result)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%35
  Single Issue       : false;
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %35:gr32 :: (store 4 into %ir.result)
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %35:gr32 = COPY killed $eax
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(0):   %35:gr32 = COPY killed $eax
SU(1):   MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %35:gr32 :: (store 4 into %ir.result)

********** MI Scheduling **********
main:%bb.6 while.end
  From: $rdi = COPY %30:gr64
    To: CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %30:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.15
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $rdx = MOV32ri64 @niter
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(3):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=1 Artificial
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 1 0 
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 1 
  Cand SU(0) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(0) $rdi = COPY %30:gr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $rdx = MOV32ri64 @niter
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) $rsi = MOV32ri64 @.str.15
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(1):   $rsi = MOV32ri64 @.str.15
SU(2):   $rdx = MOV32ri64 @niter
SU(0):   $rdi = COPY %30:gr64
SU(3):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.7 while.cond20
  From: %37:gr32 = COPY killed $eax
    To: JCC_1 %bb.7, 5, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %37:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%37
  Single Issue       : false;
SU(1):   CMP32ri8 %37:gr32, 10, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%37
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.7, 5, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32ri8 %37:gr32, 10, implicit-def $eflags
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %37:gr32 = COPY killed $eax
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.7 ***
SU(0):   %37:gr32 = COPY killed $eax
SU(1):   CMP32ri8 %37:gr32, 10, implicit-def $eflags

********** MI Scheduling **********
main:%bb.8 while.end24
  From: %44:gr32 = COPY killed $eax
    To: End RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %44:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Data Latency=0 Reg=%44
  Single Issue       : false;
SU(1):   MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %44:gr32 :: (store 4 into %ir.result)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%44
  Single Issue       : false;
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %44:gr32 :: (store 4 into %ir.result)
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %44:gr32 = COPY killed $eax
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.8 ***
SU(0):   %44:gr32 = COPY killed $eax
SU(1):   MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %44:gr32 :: (store 4 into %ir.result)

********** MI Scheduling **********
main:%bb.8 while.end24
  From: $rdi = COPY %39:gr64
    To: CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %39:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.15
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $rdx = MOV32ri64 @nmxh
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(3):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=1 Artificial
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 1 0 
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 1 
  Cand SU(0) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(0) $rdi = COPY %39:gr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $rdx = MOV32ri64 @nmxh
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) $rsi = MOV32ri64 @.str.15
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.8 ***
SU(1):   $rsi = MOV32ri64 @.str.15
SU(2):   $rdx = MOV32ri64 @nmxh
SU(0):   $rdi = COPY %39:gr64
SU(3):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.9 while.cond26
  From: %46:gr32 = COPY killed $eax
    To: JCC_1 %bb.9, 5, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %46:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%46
  Single Issue       : false;
SU(1):   CMP32ri8 %46:gr32, 10, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%46
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.9, 5, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32ri8 %46:gr32, 10, implicit-def $eflags
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %46:gr32 = COPY killed $eax
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.9 ***
SU(0):   %46:gr32 = COPY killed $eax
SU(1):   CMP32ri8 %46:gr32, 10, implicit-def $eflags

********** MI Scheduling **********
main:%bb.10 while.end30
  From: %53:gr32 = COPY killed $eax
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %53:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Data Latency=0 Reg=%53
  Single Issue       : false;
SU(1):   MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %53:gr32 :: (store 4 into %ir.result)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%53
  Single Issue       : false;
SU(2):   MOV8mi %stack.12.Class, 1, $noreg, 0, $noreg, 85 :: (store 1 into %ir.Class)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(3):   %54:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 3 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %54:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  Ready @3c
  BotQ.A BotLatency SU(3) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) MOV8mi %stack.12.Class, 1, $noreg, 0, $noreg, 85 :: (store 1 into %ir.Class)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %53:gr32 :: (store 4 into %ir.result)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %53:gr32 = COPY killed $eax
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(0):   %53:gr32 = COPY killed $eax
SU(1):   MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %53:gr32 :: (store 4 into %ir.result)
SU(2):   MOV8mi %stack.12.Class, 1, $noreg, 0, $noreg, 85 :: (store 1 into %ir.Class)
SU(3):   %54:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)

********** MI Scheduling **********
main:%bb.10 while.end30
  From: $rdi = COPY %48:gr64
    To: CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %48:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.16
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $rdx = MOV32ri64 @alpha
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(3):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=1 Artificial
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 1 0 
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 1 
  Cand SU(0) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(0) $rdi = COPY %48:gr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $rdx = MOV32ri64 @alpha
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) $rsi = MOV32ri64 @.str.16
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(1):   $rsi = MOV32ri64 @.str.16
SU(2):   $rdx = MOV32ri64 @alpha
SU(0):   $rdi = COPY %48:gr64
SU(3):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.11 if.else33
  From: MOV32mi $rip, 1, $noreg, @fre, $noreg, 5 :: (store 4 into @fre)
    To: End RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV32mi $rip, 1, $noreg, @fre, $noreg, 5 :: (store 4 into @fre)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   MOV32mi $rip, 1, $noreg, @niter, $noreg, 200 :: (store 4 into @niter)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(2):   MOV32mi $rip, 1, $noreg, @nmxh, $noreg, 10 :: (store 4 into @nmxh)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(3):   %18:gr64 = MOV64ri 4590140797810047451
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(4): Data Latency=1 Reg=%18
  Single Issue       : false;
SU(4):   MOV64mr $rip, 1, $noreg, @alpha, $noreg, %18:gr64 :: (store 8 into @alpha)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(3): Data Latency=1 Reg=%18
  Single Issue       : false;
SU(5):   MOV8mi %stack.12.Class, 1, $noreg, 0, $noreg, 66 :: (store 1 into %ir.Class)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 4 2 1 0 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) MOV8mi %stack.12.Class, 1, $noreg, 0, $noreg, 66 :: (store 1 into %ir.Class)
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 4 2 1 
  Cand SU(0) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) MOV64mr $rip, 1, $noreg, @alpha, $noreg, %18:gr64 :: (store 8 into @alpha)
  Ready @0c
  BotQ.A TopLatency SU(4) 1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 3 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %18:gr64 = MOV64ri 4590140797810047451
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) MOV32mi $rip, 1, $noreg, @nmxh, $noreg, 10 :: (store 4 into @nmxh)
  Ready @0c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) MOV32mi $rip, 1, $noreg, @niter, $noreg, 200 :: (store 4 into @niter)
  Ready @1c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV32mi $rip, 1, $noreg, @fre, $noreg, 5 :: (store 4 into @fre)
  Ready @1c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.11 ***
SU(0):   MOV32mi $rip, 1, $noreg, @fre, $noreg, 5 :: (store 4 into @fre)
SU(1):   MOV32mi $rip, 1, $noreg, @niter, $noreg, 200 :: (store 4 into @niter)
SU(2):   MOV32mi $rip, 1, $noreg, @nmxh, $noreg, 10 :: (store 4 into @nmxh)
SU(3):   %18:gr64 = MOV64ri 4590140797810047451
SU(4):   MOV64mr $rip, 1, $noreg, @alpha, $noreg, %18:gr64 :: (store 8 into @alpha)
SU(5):   MOV8mi %stack.12.Class, 1, $noreg, 0, $noreg, 66 :: (store 1 into %ir.Class)

********** MI Scheduling **********
main:%bb.11 if.else33
  From: $rdi = MOV32ri64 @.str.17
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.17
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.17
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.11 ***
SU(0):   $rdi = MOV32ri64 @.str.17
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.12 if.end35
  From: $rdi = MOV32ri64 @.str.22
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.22
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $xmm0 = COPY %76:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $al = MOV8ri 1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) $al = MOV8ri 1
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $xmm0 = COPY %76:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.22
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.12 ***
SU(0):   $rdi = MOV32ri64 @.str.22
SU(1):   $xmm0 = COPY %76:fr64
SU(2):   $al = MOV8ri 1

********** MI Scheduling **********
main:%bb.12 if.end35
  From: $rdi = MOV32ri64 @.str.21
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.21
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %73:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %73:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.21
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.12 ***
SU(0):   $rdi = MOV32ri64 @.str.21
SU(1):   $esi = COPY %73:gr32
SU(2):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.12 if.end35
  From: $rdi = MOV32ri64 @.str.20
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.20
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %68:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %69:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $al = MOV8ri 1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=1 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 1 0 
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) $al = MOV8ri 1
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 1 
  Cand SU(0) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) $xmm0 = COPY %69:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %68:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.20
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.12 ***
SU(0):   $rdi = MOV32ri64 @.str.20
SU(1):   $esi = COPY %68:gr32
SU(2):   $xmm0 = COPY %69:fr64
SU(3):   $al = MOV8ri 1

********** MI Scheduling **********
main:%bb.12 if.end35
  From: %68:gr32 = MOV32rm $rip, 1, $noreg, @niter, $noreg :: (dereferenceable load 4 from @niter)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %68:gr32 = MOV32rm $rip, 1, $noreg, @niter, $noreg :: (dereferenceable load 4 from @niter)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
SU(1):   %69:fr64 = MOVSDrm_alt $rip, 1, $noreg, @dtime, $noreg :: (dereferenceable load 8 from @dtime)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=3 Artificial
    SU(0): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %69:fr64 = MOVSDrm_alt $rip, 1, $noreg, @dtime, $noreg :: (dereferenceable load 8 from @dtime)
  Ready @3c
  BotQ.A BotLatency SU(1) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %68:gr32 = MOV32rm $rip, 1, $noreg, @niter, $noreg :: (dereferenceable load 4 from @niter)
  Ready @3c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.12 ***
SU(0):   %68:gr32 = MOV32rm $rip, 1, $noreg, @niter, $noreg :: (dereferenceable load 4 from @niter)
SU(1):   %69:fr64 = MOVSDrm_alt $rip, 1, $noreg, @dtime, $noreg :: (dereferenceable load 8 from @dtime)

********** MI Scheduling **********
main:%bb.12 if.end35
  From: $rdi = MOV32ri64 @.str.19
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.19
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %65:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %65:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.19
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.12 ***
SU(0):   $rdi = MOV32ri64 @.str.19
SU(1):   $esi = COPY %65:gr32
SU(2):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.12 if.end35
  From: $rdi = MOV32ri64 @.str.18
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.18
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = MOV32ri 7
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = MOV32ri 7
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.18
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.12 ***
SU(0):   $rdi = MOV32ri64 @.str.18
SU(1):   $esi = MOV32ri 7
SU(2):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.12 if.end35
  From: %59:fr64 = COPY killed $xmm0
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %59:fr64 = COPY killed $xmm0
  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 4
  Successors:
    SU(2): Data Latency=0 Reg=%59
    SU(1): Data Latency=0 Reg=%59
    SU(2): Out  Latency=0
  Single Issue       : false;
SU(1):   MOVSDmr $rip, 1, $noreg, @dlmin, $noreg, %59:fr64 :: (store 8 into @dlmin)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 4
  Predecessors:
    SU(0): Data Latency=0 Reg=%59
  Successors:
    SU(2): Anti Latency=0
  Single Issue       : false;
SU(2):   %59:fr64 = MULSDrm %59:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 4
  Predecessors:
    SU(1): Anti Latency=0
    SU(0): Data Latency=0 Reg=%59
    SU(0): Out  Latency=0
  Successors:
    SU(3): Data Latency=4 Reg=%59
  Single Issue       : false;
SU(3):   MOVSDmr $rip, 1, $noreg, @dtime, $noreg, %59:fr64 :: (store 8 into @dtime)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(2): Data Latency=4 Reg=%59
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 4
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOVSDmr $rip, 1, $noreg, @dtime, $noreg, %59:fr64 :: (store 8 into @dtime)
  Ready @0c
  BotQ.A TopLatency SU(3) 4c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %59:fr64 = MULSDrm %59:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  Ready @4c
  BotQ.A BotLatency SU(2) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOVSDmr $rip, 1, $noreg, @dlmin, $noreg, %59:fr64 :: (store 8 into @dlmin)
  Ready @4c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %59:fr64 = COPY killed $xmm0
  Ready @4c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.12 ***
SU(0):   %59:fr64 = COPY killed $xmm0
SU(1):   MOVSDmr $rip, 1, $noreg, @dlmin, $noreg, %59:fr64 :: (store 8 into @dlmin)
SU(2):   %59:fr64 = MULSDrm %59:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
SU(3):   MOVSDmr $rip, 1, $noreg, @dtime, $noreg, %59:fr64 :: (store 8 into @dtime)

********** MI Scheduling **********
main:%bb.12 if.end35
  From: %56:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
    To: CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %56:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 4
  Successors:
    SU(2): Data Latency=4 Reg=%56
  Single Issue       : false;
SU(1):   %57:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=4 Reg=%57
  Single Issue       : false;
SU(2):   $xmm0 = COPY %56:fr64
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(0): Data Latency=4 Reg=%56
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $xmm1 = COPY %57:fr64
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Data Latency=4 Reg=%57
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 4
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) $xmm1 = COPY %57:fr64
  Ready @0c
  BotQ.A TopLatency SU(3) 4c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) $xmm0 = COPY %56:fr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %57:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  Ready @4c
  BotQ.A BotLatency SU(1) 4c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %56:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  Ready @4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.12 ***
SU(0):   %56:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
SU(1):   %57:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
SU(2):   $xmm0 = COPY %56:fr64
SU(3):   $xmm1 = COPY %57:fr64

********** MI Scheduling **********
main:%bb.17 if.end44
  From: %94:gr64 = LEA64r %stack.13.ifmortar, 1, $noreg, 0, $noreg
    To: CALL64pcrel32 @adaptation, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %94:gr64 = LEA64r %stack.13.ifmortar, 1, $noreg, 0, $noreg
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=1 Reg=%94
  Single Issue       : false;
SU(1):   $rdi = COPY %94:gr64
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(0): Data Latency=1 Reg=%94
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $esi = MOV32r0 implicit-def dead $eflags
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @adaptation, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $esi = MOV32r0 implicit-def dead $eflags
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) $rdi = COPY %94:gr64
  Ready @0c
  BotQ.A TopLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %94:gr64 = LEA64r %stack.13.ifmortar, 1, $noreg, 0, $noreg
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.17 ***
SU(0):   %94:gr64 = LEA64r %stack.13.ifmortar, 1, $noreg, 0, $noreg
SU(1):   $rdi = COPY %94:gr64
SU(2):   $esi = MOV32r0 implicit-def dead $eflags

********** MI Scheduling **********
main:%bb.17 if.end44
  From: $rdi = MOV32ri64 @sje
    To: CALL64pcrel32 @nr_init, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @sje
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %91:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $edx = MOV32ri -1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @nr_init, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) $edx = MOV32ri -1
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %91:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @sje
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.17 ***
SU(0):   $rdi = MOV32ri64 @sje
SU(1):   $esi = COPY %91:gr32
SU(2):   $edx = MOV32ri -1

********** MI Scheduling **********
main:%bb.17 if.end44
  From: undef %89.sub_32bit:gr64_nosp = MOV32rm $rip, 1, $noreg, @nelt, $noreg :: (dereferenceable load 4 from @nelt)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   undef %89.sub_32bit:gr64_nosp = MOV32rm $rip, 1, $noreg, @nelt, $noreg :: (dereferenceable load 4 from @nelt)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
    SU(1): Data Latency=4 Reg=%89
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %89.sub_32bit:gr64_nosp = SHL32ri %89.sub_32bit:gr64_nosp(tied-def 0), 3, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(0): Data Latency=4 Reg=%89
    SU(0): Out  Latency=0
  Successors:
    SU(2): Data Latency=1 Reg=%89
  Single Issue       : false;
SU(2):   %91:gr32 = LEA64_32r %89:gr64_nosp, 2, %89:gr64_nosp, 0, $noreg
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%89
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 5
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %91:gr32 = LEA64_32r %89:gr64_nosp, 2, %89:gr64_nosp, 0, $noreg
  Ready @0c
  BotQ.A TopLatency SU(2) 5c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %89.sub_32bit:gr64_nosp = SHL32ri %89.sub_32bit:gr64_nosp(tied-def 0), 3, implicit-def dead $eflags
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) undef %89.sub_32bit:gr64_nosp = MOV32rm $rip, 1, $noreg, @nelt, $noreg :: (dereferenceable load 4 from @nelt)
  Ready @5c
  BotQ.A BotLatency SU(0) 5c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.17 ***
SU(0):   undef %89.sub_32bit:gr64_nosp = MOV32rm $rip, 1, $noreg, @nelt, $noreg :: (dereferenceable load 4 from @nelt)
SU(1):   %89.sub_32bit:gr64_nosp = SHL32ri %89.sub_32bit:gr64_nosp(tied-def 0), 3, implicit-def dead $eflags
SU(2):   %91:gr32 = LEA64_32r %89:gr64_nosp, 2, %89:gr64_nosp, 0, $noreg

********** MI Scheduling **********
main:%bb.17 if.end44
  From: $rdi = MOV32ri64 @ta1
    To: CALL64pcrel32 @r_init, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @ta1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %84:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = FsFLD0SD
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @r_init, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %84:gr32
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 0 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $xmm0 = FsFLD0SD
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @ta1
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.17 ***
SU(0):   $rdi = MOV32ri64 @ta1
SU(2):   $xmm0 = FsFLD0SD
SU(1):   $esi = COPY %84:gr32

********** MI Scheduling **********
main:%bb.19 if.end48
  From: MOV64mi32 $rip, 1, $noreg, @time, $noreg, 0 :: (store 8 into @time)
    To: End RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV64mi32 $rip, 1, $noreg, @time, $noreg, 0 :: (store 8 into @time)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   MOV32mi %stack.3.step, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.step)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(2):   %201:gr64 = LEA64r %stack.13.ifmortar, 1, $noreg, 0, $noreg
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %201:gr64 = LEA64r %stack.13.ifmortar, 1, $noreg, 0, $noreg
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) MOV32mi %stack.3.step, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.step)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV64mi32 $rip, 1, $noreg, @time, $noreg, 0 :: (store 8 into @time)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.19 ***
SU(0):   MOV64mi32 $rip, 1, $noreg, @time, $noreg, 0 :: (store 8 into @time)
SU(1):   MOV32mi %stack.3.step, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.step)
SU(2):   %201:gr64 = LEA64r %stack.13.ifmortar, 1, $noreg, 0, $noreg

********** MI Scheduling **********
main:%bb.20 for.cond49
  From: %97:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
    To: JCC_1 %bb.65, 15, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %97:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 8
  Successors:
    SU(1): Data Latency=4 Reg=%97
  Single Issue       : false;
SU(1):   CMP32rm %97:gr32, $rip, 1, $noreg, @niter, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @niter)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 4
  Predecessors:
    SU(0): Data Latency=4 Reg=%97
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.65, 15, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=4 Artificial
Critical Path(GS-RR ): 8
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32rm %97:gr32, $rip, 1, $noreg, @niter, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @niter)
  Ready @4c
  BotQ.A TopLatency SU(1) 4c
  BotQ.A BotLatency SU(1) 4c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %97:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  Ready @8c
  BotQ.A BotLatency SU(0) 8c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.20 ***
SU(0):   %97:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
SU(1):   CMP32rm %97:gr32, $rip, 1, $noreg, @niter, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @niter)

********** MI Scheduling **********
main:%bb.22 if.then53
  From: MOV64mi32 $rip, 1, $noreg, @time, $noreg, 0 :: (store 8 into @time)
    To: End RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV64mi32 $rip, 1, $noreg, @time, $noreg, 0 :: (store 8 into @time)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   MOV64mi32 %stack.11.nelt_tot, 1, $noreg, 0, $noreg, 0 :: (store 8 into %ir.nelt_tot)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(2):   MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) MOV64mi32 %stack.11.nelt_tot, 1, $noreg, 0, $noreg, 0 :: (store 8 into %ir.nelt_tot)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV64mi32 $rip, 1, $noreg, @time, $noreg, 0 :: (store 8 into @time)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.22 ***
SU(0):   MOV64mi32 $rip, 1, $noreg, @time, $noreg, 0 :: (store 8 into @time)
SU(1):   MOV64mi32 %stack.11.nelt_tot, 1, $noreg, 0, $noreg, 0 :: (store 8 into %ir.nelt_tot)
SU(2):   MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

********** MI Scheduling **********
main:%bb.22 if.then53
  From: $rdi = MOV32ri64 @ta1
    To: CALL64pcrel32 @r_init, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @ta1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %163:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = FsFLD0SD
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @r_init, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %163:gr32
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 0 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $xmm0 = FsFLD0SD
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @ta1
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.22 ***
SU(0):   $rdi = MOV32ri64 @ta1
SU(2):   $xmm0 = FsFLD0SD
SU(1):   $esi = COPY %163:gr32

********** MI Scheduling **********
main:%bb.30 if.end66
  From: $rdi = MOV32ri64 @tmort
    To: CALL64pcrel32 @transf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @tmort
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @ta1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @transf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @ta1
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @tmort
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.30 ***
SU(0):   $rdi = MOV32ri64 @tmort
SU(1):   $rsi = MOV32ri64 @ta1

********** MI Scheduling **********
main:%bb.31 for.cond67
  From: %173:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
    To: JCC_1 %bb.33, 13, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %173:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 8
  Successors:
    SU(1): Data Latency=4 Reg=%173
  Single Issue       : false;
SU(1):   CMP32rm %173:gr32, $rip, 1, $noreg, @nelt, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @nelt)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 4
  Predecessors:
    SU(0): Data Latency=4 Reg=%173
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.33, 13, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=4 Artificial
Critical Path(GS-RR ): 8
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32rm %173:gr32, $rip, 1, $noreg, @nelt, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @nelt)
  Ready @4c
  BotQ.A TopLatency SU(1) 4c
  BotQ.A BotLatency SU(1) 4c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %173:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  Ready @8c
  BotQ.A BotLatency SU(0) 8c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.31 ***
SU(0):   %173:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
SU(1):   CMP32rm %173:gr32, $rip, 1, $noreg, @nelt, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @nelt)

********** MI Scheduling **********
main:%bb.32 for.body69
  From: $rdi = COPY %234:gr64
    To: CALL64pcrel32 @laplacian, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %234:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %235:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $edx = COPY %236:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @laplacian, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $edx = COPY %236:gr32
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = COPY %235:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = COPY %234:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.32 ***
SU(0):   $rdi = COPY %234:gr64
SU(1):   $rsi = COPY %235:gr64
SU(2):   $edx = COPY %236:gr32

********** MI Scheduling **********
main:%bb.32 for.body69
  From: %232:gr64_nosp = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %232:gr64_nosp = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 7
  Successors:
    SU(4): Data Latency=4 Reg=%232
    SU(1): Data Latency=4 Reg=%232
  Single Issue       : false;
SU(1):   %233:gr64 = IMUL64rri32 %232:gr64_nosp, 1000, implicit-def dead $eflags
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(0): Data Latency=4 Reg=%232
  Successors:
    SU(3): Data Latency=1 Reg=%233
    SU(2): Data Latency=1 Reg=%233
  Single Issue       : false;
SU(2):   %234:gr64 = LEA64r %233:gr64, 1, $noreg, @ta2, $noreg
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%233
  Single Issue       : false;
SU(3):   %235:gr64 = LEA64r %233:gr64, 1, $noreg, @ta1, $noreg
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%233
  Single Issue       : false;
SU(4):   %236:gr32 = MOV32rm $noreg, 4, %232:gr64_nosp, @size_e, $noreg :: (load 4 from %ir.arrayidx75)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 3
  Predecessors:
    SU(0): Data Latency=4 Reg=%232
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 7
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 7
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 4 
  Cand SU(3) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %236:gr32 = MOV32rm $noreg, 4, %232:gr64_nosp, @size_e, $noreg :: (load 4 from %ir.arrayidx75)
  Ready @3c
  BotQ.A TopLatency SU(4) 4c
  BotQ.A BotLatency SU(4) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %235:gr64 = LEA64r %233:gr64, 1, $noreg, @ta1, $noreg
  Ready @0c
  BotQ.A TopLatency SU(3) 5c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %234:gr64 = LEA64r %233:gr64, 1, $noreg, @ta2, $noreg
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %233:gr64 = IMUL64rri32 %232:gr64_nosp, 1000, implicit-def dead $eflags
  Ready @1c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %232:gr64_nosp = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  Ready @7c
  BotQ.A BotLatency SU(0) 7c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.32 ***
SU(0):   %232:gr64_nosp = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
SU(1):   %233:gr64 = IMUL64rri32 %232:gr64_nosp, 1000, implicit-def dead $eflags
SU(2):   %234:gr64 = LEA64r %233:gr64, 1, $noreg, @ta2, $noreg
SU(3):   %235:gr64 = LEA64r %233:gr64, 1, $noreg, @ta1, $noreg
SU(4):   %236:gr32 = MOV32rm $noreg, 4, %232:gr64_nosp, @size_e, $noreg :: (load 4 from %ir.arrayidx75)

********** MI Scheduling **********
main:%bb.34 for.cond79
  From: %175:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
    To: JCC_1 %bb.45, 13, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %175:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 8
  Successors:
    SU(1): Data Latency=4 Reg=%175
  Single Issue       : false;
SU(1):   CMP32rm %175:gr32, $rip, 1, $noreg, @nelt, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @nelt)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 4
  Predecessors:
    SU(0): Data Latency=4 Reg=%175
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.45, 13, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=4 Artificial
Critical Path(GS-RR ): 8
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32rm %175:gr32, $rip, 1, $noreg, @nelt, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @nelt)
  Ready @4c
  BotQ.A TopLatency SU(1) 4c
  BotQ.A BotLatency SU(1) 4c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %175:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  Ready @8c
  BotQ.A BotLatency SU(0) 8c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.34 ***
SU(0):   %175:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
SU(1):   CMP32rm %175:gr32, $rip, 1, $noreg, @nelt, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @nelt)

********** MI Scheduling **********
main:%bb.41 for.body90
  From: %221:gr64 = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
    To: JMP_1 %bb.40
 RegionInstrs: 13
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: FR32=1
FR32X=1
GR16=6
Live In: 
Live Out: 
Live Thru: 
Top Pressure:

Bottom Pressure:

Excess PSets: 
SU(0):   %221:gr64 = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 15
  Successors:
    SU(1): Data Latency=4 Reg=%221
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(1):   %222:gr64 = IMUL64rri32 %221:gr64, 1000, implicit-def dead $eflags
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 11
  Predecessors:
    SU(0): Data Latency=4 Reg=%221
  Successors:
    SU(4): Data Latency=1 Reg=%222
  Pressure Diff      : 
  Single Issue       : false;
SU(2):   %223:gr64 = MOVSX64rm32 %stack.8.k, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.k)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 15
  Successors:
    SU(3): Data Latency=4 Reg=%223
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(3):   %228:gr64 = IMUL64rri32 %223:gr64, 200, implicit-def dead $eflags
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 11
  Predecessors:
    SU(2): Data Latency=4 Reg=%223
  Successors:
    SU(4): Data Latency=1 Reg=%228
    SU(4): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(4):   %228:gr64 = ADD64rr %228:gr64(tied-def 0), %222:gr64, implicit-def dead $eflags
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 10
  Predecessors:
    SU(3): Data Latency=1 Reg=%228
    SU(3): Out  Latency=0
    SU(1): Data Latency=1 Reg=%222
  Successors:
    SU(8): Data Latency=1 Reg=%228
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(5):   %225:gr64_nosp = MOVSX64rm32 %stack.7.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 14
  Successors:
    SU(6): Data Latency=4 Reg=%225
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(6):   %226:gr64_nosp = LEA64r %225:gr64_nosp, 4, %225:gr64_nosp, 0, $noreg
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 10
  Predecessors:
    SU(5): Data Latency=4 Reg=%225
  Successors:
    SU(8): Data Latency=1 Reg=%226
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   %227:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 12
  Successors:
    SU(11): Data Latency=4 Reg=%227
    SU(10): Data Latency=4 Reg=%227
    SU(9): Data Latency=4 Reg=%227
    SU(12): Ord  Latency=0 Memory
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(8):   %229:gr64 = LEA64r %228:gr64, 8, %226:gr64_nosp, 0, $noreg
  # preds left       : 2
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 9
  Predecessors:
    SU(4): Data Latency=1 Reg=%228
    SU(6): Data Latency=1 Reg=%226
  Successors:
    SU(11): Data Latency=1 Reg=%229
    SU(10): Data Latency=1 Reg=%229
    SU(9): Data Latency=1 Reg=%229
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(9):   %231:fr64 = MOVSDrm_alt %229:gr64, 8, %227:gr64_nosp, @trhs, $noreg :: (load 8 from %ir.arrayidx98)
  # preds left       : 2
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 4
  Depth              : 7
  Height             : 8
  Predecessors:
    SU(8): Data Latency=1 Reg=%229
    SU(7): Data Latency=4 Reg=%227
  Successors:
    SU(10): Data Latency=4 Reg=%231
    SU(10): Out  Latency=0
    SU(11): Ord  Latency=0 Memory
  Pressure Diff      : FR32 -1    FR32X -1    GR16 4
  Single Issue       : false;
SU(10):   %231:fr64 = SUBSDrm %231:fr64(tied-def 0), %229:gr64, 8, %227:gr64_nosp, @ta2, $noreg :: (load 8 from %ir.arrayidx106)
  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 11
  Height             : 4
  Predecessors:
    SU(9): Data Latency=4 Reg=%231
    SU(9): Out  Latency=0
    SU(8): Data Latency=1 Reg=%229
    SU(7): Data Latency=4 Reg=%227
  Successors:
    SU(11): Data Latency=4 Reg=%231
  Pressure Diff      : GR16 4
  Single Issue       : false;
SU(11):   MOVSDmr %229:gr64, 8, %227:gr64_nosp, @trhs, $noreg, %231:fr64 :: (store 8 into %ir.arrayidx114)
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 15
  Height             : 0
  Predecessors:
    SU(10): Data Latency=4 Reg=%231
    SU(9): Ord  Latency=0 Memory
    SU(8): Data Latency=1 Reg=%229
    SU(7): Data Latency=4 Reg=%227
  Pressure Diff      : FR32 1    FR32X 1    GR16 4
  Single Issue       : false;
SU(12):   INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Predecessors:
    SU(7): Ord  Latency=0 Memory
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : 
  Single Issue       : false;
ExitSU:   JMP_1 %bb.40
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(12): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 15
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 11 12 
  Cand SU(11) ORDER                              
  Cand SU(12) ORDER                              
Pick Bot ORDER     
Scheduling SU(12) INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
Bottom Pressure:

  Ready @3c
  BotQ.A BotLatency SU(12) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 11 
Scheduling SU(11) MOVSDmr %229:gr64, 8, %227:gr64_nosp, @trhs, $noreg, %231:fr64 :: (store 8 into %ir.arrayidx114)
Bottom Pressure:
FR32=1
FR32X=1
GR16=4
  LiveReg: %229
  UpdateRegP: SU(9) %231:fr64 = MOVSDrm_alt %229:gr64, 8, %227:gr64_nosp, @trhs, $noreg :: (load 8 from %ir.arrayidx98)
              to FR32 -1    FR32X -1    GR16 2
  UpdateRegP: SU(10) %231:fr64 = SUBSDrm %231:fr64(tied-def 0), %229:gr64, 8, %227:gr64_nosp, @ta2, $noreg :: (load 8 from %ir.arrayidx106)
              to GR16 2
  UpdateRegP: SU(11) MOVSDmr %229:gr64, 8, %227:gr64_nosp, @trhs, $noreg, %231:fr64 :: (store 8 into %ir.arrayidx114)
              to FR32 1    FR32X 1    GR16 2
  LiveReg: %227
  UpdateRegP: SU(9) %231:fr64 = MOVSDrm_alt %229:gr64, 8, %227:gr64_nosp, @trhs, $noreg :: (load 8 from %ir.arrayidx98)
              to FR32 -1    FR32X -1
  UpdateRegP: SU(10) %231:fr64 = SUBSDrm %231:fr64(tied-def 0), %229:gr64, 8, %227:gr64_nosp, @ta2, $noreg :: (load 8 from %ir.arrayidx106)
              to 
  UpdateRegP: SU(11) MOVSDmr %229:gr64, 8, %227:gr64_nosp, @trhs, $noreg, %231:fr64 :: (store 8 into %ir.arrayidx114)
              to FR32 1    FR32X 1
  LiveReg: %231
  UpdateRegP: SU(11) MOVSDmr %229:gr64, 8, %227:gr64_nosp, @trhs, $noreg, %231:fr64 :: (store 8 into %ir.arrayidx114)
              to 
  Ready @0c
  BotQ.A TopLatency SU(11) 15c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 10 
Scheduling SU(10) %231:fr64 = SUBSDrm %231:fr64(tied-def 0), %229:gr64, 8, %227:gr64_nosp, @ta2, $noreg :: (load 8 from %ir.arrayidx106)
Bottom Pressure:
FR32=1
FR32X=1
GR16=4
  LiveReg: %231
  UpdateRegP: SU(10) %231:fr64 = SUBSDrm %231:fr64(tied-def 0), %229:gr64, 8, %227:gr64_nosp, @ta2, $noreg :: (load 8 from %ir.arrayidx106)
              to FR32 -1    FR32X -1
  Ready @4c
  BotQ.A BotLatency SU(10) 4c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 9 
Scheduling SU(9) %231:fr64 = MOVSDrm_alt %229:gr64, 8, %227:gr64_nosp, @trhs, $noreg :: (load 8 from %ir.arrayidx98)
Bottom Pressure:
GR16=4
  Ready @8c
  BotQ.A BotLatency SU(9) 8c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 7 
  Cand SU(8) ORDER                              
Pick Bot ORDER     
Scheduling SU(8) %229:gr64 = LEA64r %228:gr64, 8, %226:gr64_nosp, 0, $noreg
Bottom Pressure:
GR16=6
  LiveReg: %228
  UpdateRegP: SU(8) %229:gr64 = LEA64r %228:gr64, 8, %226:gr64_nosp, 0, $noreg
              to 
  LiveReg: %226
  UpdateRegP: SU(8) %229:gr64 = LEA64r %228:gr64, 8, %226:gr64_nosp, 0, $noreg
              to GR16 -2
  Ready @9c
  BotQ.A BotLatency SU(8) 9c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 9c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 4 6 
  Cand SU(7) ORDER                              
Pick Bot REG-MAX   
Scheduling SU(7) %227:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
Bottom Pressure:
GR16=4
  Ready @12c
  BotQ.A BotLatency SU(7) 12c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 4 
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) %226:gr64_nosp = LEA64r %225:gr64_nosp, 4, %225:gr64_nosp, 0, $noreg
Bottom Pressure:
GR16=4
  LiveReg: %225
  UpdateRegP: SU(6) %226:gr64_nosp = LEA64r %225:gr64_nosp, 4, %225:gr64_nosp, 0, $noreg
              to GR16 -2
  Ready @10c
BotQ.A @1c
  Retired: 7
  Executed: 1c
  Critical: 1c, 7 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 5 
  Cand SU(4) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %225:gr64_nosp = MOVSX64rm32 %stack.7.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
Bottom Pressure:
GR16=2
  Ready @14c
  BotQ.A BotLatency SU(5) 14c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 2c
  Critical: 2c, 8 MOps
  ExpectedLatency: 14c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) %228:gr64 = ADD64rr %228:gr64(tied-def 0), %222:gr64, implicit-def dead $eflags
Bottom Pressure:
GR16=4
  LiveReg: %228
  UpdateRegP: SU(4) %228:gr64 = ADD64rr %228:gr64(tied-def 0), %222:gr64, implicit-def dead $eflags
              to 
  LiveReg: %222
  UpdateRegP: SU(4) %228:gr64 = ADD64rr %228:gr64(tied-def 0), %222:gr64, implicit-def dead $eflags
              to GR16 -2
  Ready @10c
BotQ.A @2c
  Retired: 9
  Executed: 2c
  Critical: 2c, 9 MOps
  ExpectedLatency: 14c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 1 
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %228:gr64 = IMUL64rri32 %223:gr64, 200, implicit-def dead $eflags
Bottom Pressure:
GR16=4
  LiveReg: %223
  UpdateRegP: SU(3) %228:gr64 = IMUL64rri32 %223:gr64, 200, implicit-def dead $eflags
              to GR16 -2
  Ready @11c
BotQ.A @2c
  Retired: 10
  Executed: 2c
  Critical: 2c, 10 MOps
  ExpectedLatency: 14c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %223:gr64 = MOVSX64rm32 %stack.8.k, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.k)
Bottom Pressure:
GR16=2
  Ready @15c
  BotQ.A BotLatency SU(2) 15c
BotQ.A @2c
  Retired: 11
  Executed: 2c
  Critical: 2c, 11 MOps
  ExpectedLatency: 15c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %222:gr64 = IMUL64rri32 %221:gr64, 1000, implicit-def dead $eflags
Bottom Pressure:
GR16=2
  LiveReg: %221
  UpdateRegP: SU(1) %222:gr64 = IMUL64rri32 %221:gr64, 1000, implicit-def dead $eflags
              to GR16 -2
  Ready @11c
  *** Max MOps 4 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 12
  Executed: 3c
  Critical: 3c, 12 MOps
  ExpectedLatency: 15c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %221:gr64 = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
Bottom Pressure:

  Ready @15c
BotQ.A @3c
  Retired: 13
  Executed: 3c
  Critical: 3c, 13 MOps
  ExpectedLatency: 15c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.41 ***
SU(0):   %221:gr64 = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
SU(1):   %222:gr64 = IMUL64rri32 %221:gr64, 1000, implicit-def dead $eflags
SU(2):   %223:gr64 = MOVSX64rm32 %stack.8.k, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.k)
SU(3):   %228:gr64 = IMUL64rri32 %223:gr64, 200, implicit-def dead $eflags
SU(4):   %228:gr64 = ADD64rr %228:gr64(tied-def 0), %222:gr64, implicit-def dead $eflags
SU(5):   %225:gr64_nosp = MOVSX64rm32 %stack.7.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
SU(6):   %226:gr64_nosp = LEA64r %225:gr64_nosp, 4, %225:gr64_nosp, 0, $noreg
SU(7):   %227:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
SU(8):   %229:gr64 = LEA64r %228:gr64, 8, %226:gr64_nosp, 0, $noreg
SU(9):   %231:fr64 = MOVSDrm_alt %229:gr64, 8, %227:gr64_nosp, @trhs, $noreg :: (load 8 from %ir.arrayidx98)
SU(10):   %231:fr64 = SUBSDrm %231:fr64(tied-def 0), %229:gr64, 8, %227:gr64_nosp, @ta2, $noreg :: (load 8 from %ir.arrayidx106)
SU(11):   MOVSDmr %229:gr64, 8, %227:gr64_nosp, @trhs, $noreg, %231:fr64 :: (store 8 into %ir.arrayidx114)
SU(12):   INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)

********** MI Scheduling **********
main:%bb.45 for.end126
  From: $rdi = MOV32ri64 @rmor
    To: CALL64pcrel32 @transfb, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @rmor
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @trhs
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @transfb, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @trhs
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @rmor
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.45 ***
SU(0):   $rdi = MOV32ri64 @rmor
SU(1):   $rsi = MOV32ri64 @trhs

********** MI Scheduling **********
main:%bb.48 for.cond130
  From: %180:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
    To: JCC_1 %bb.55, 13, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %180:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 8
  Successors:
    SU(1): Data Latency=4 Reg=%180
  Single Issue       : false;
SU(1):   CMP32rm %180:gr32, $rip, 1, $noreg, @nelt, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @nelt)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 4
  Predecessors:
    SU(0): Data Latency=4 Reg=%180
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.55, 13, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=4 Artificial
Critical Path(GS-RR ): 8
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32rm %180:gr32, $rip, 1, $noreg, @nelt, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @nelt)
  Ready @4c
  BotQ.A TopLatency SU(1) 4c
  BotQ.A BotLatency SU(1) 4c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %180:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  Ready @8c
  BotQ.A BotLatency SU(0) 8c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.48 ***
SU(0):   %180:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
SU(1):   CMP32rm %180:gr32, $rip, 1, $noreg, @nelt, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @nelt)

********** MI Scheduling **********
main:%bb.51 for.body135
  From: %206:gr64_nosp = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
    To: JCC_1 %bb.53, 5, implicit killed $eflags
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %206:gr64_nosp = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 9
  Successors:
    SU(1): Data Latency=4 Reg=%206
  Single Issue       : false;
SU(1):   %207:gr64_nosp = LEA64r %206:gr64_nosp, 2, %206:gr64_nosp, 0, $noreg
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 5
  Predecessors:
    SU(0): Data Latency=4 Reg=%206
  Successors:
    SU(4): Data Latency=1 Reg=%207
  Single Issue       : false;
SU(2):   %209:gr64 = MOVSX64rm32 %stack.5.iside, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.iside)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 9
  Successors:
    SU(3): Data Latency=4 Reg=%209
    SU(3): Out  Latency=0
  Single Issue       : false;
SU(3):   %209:gr64 = SHL64ri %209:gr64(tied-def 0), 2, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 5
  Predecessors:
    SU(2): Data Latency=4 Reg=%209
    SU(2): Out  Latency=0
  Successors:
    SU(4): Data Latency=1 Reg=%209
    SU(4): Out  Latency=0
  Single Issue       : false;
SU(4):   CMP32mi8 %209:gr64, 8, %207:gr64_nosp, @cbc, $noreg, 0, implicit-def $eflags :: (load 4 from %ir.arrayidx139)
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 5
  Height             : 4
  Predecessors:
    SU(3): Data Latency=1 Reg=%209
    SU(3): Out  Latency=0
    SU(1): Data Latency=1 Reg=%207
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.53, 5, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 9
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=4 Artificial
Critical Path(GS-RR ): 9
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) CMP32mi8 %209:gr64, 8, %207:gr64_nosp, @cbc, $noreg, 0, implicit-def $eflags :: (load 4 from %ir.arrayidx139)
  Ready @4c
  BotQ.A TopLatency SU(4) 5c
  BotQ.A BotLatency SU(4) 4c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 1 
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %209:gr64 = SHL64ri %209:gr64(tied-def 0), 2, implicit-def dead $eflags
  Ready @5c
  BotQ.A BotLatency SU(3) 5c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %209:gr64 = MOVSX64rm32 %stack.5.iside, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.iside)
  Ready @9c
  BotQ.A BotLatency SU(2) 9c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 9c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %207:gr64_nosp = LEA64r %206:gr64_nosp, 2, %206:gr64_nosp, 0, $noreg
  Ready @5c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 9c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %206:gr64_nosp = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  Ready @9c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 9c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.51 ***
SU(0):   %206:gr64_nosp = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
SU(1):   %207:gr64_nosp = LEA64r %206:gr64_nosp, 2, %206:gr64_nosp, 0, $noreg
SU(2):   %209:gr64 = MOVSX64rm32 %stack.5.iside, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.iside)
SU(3):   %209:gr64 = SHL64ri %209:gr64(tied-def 0), 2, implicit-def dead $eflags
SU(4):   CMP32mi8 %209:gr64, 8, %207:gr64_nosp, @cbc, $noreg, 0, implicit-def $eflags :: (load 4 from %ir.arrayidx139)

********** MI Scheduling **********
main:%bb.52 if.then141
  From: $rdi = COPY %212:gr64
    To: CALL64pcrel32 @facev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %212:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %213:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = FsFLD0SD
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @facev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %213:gr32
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 0 
  Cand SU(2) ORDER                              
  Cand SU(0) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(0) $rdi = COPY %212:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) $xmm0 = FsFLD0SD
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.52 ***
SU(2):   $xmm0 = FsFLD0SD
SU(0):   $rdi = COPY %212:gr64
SU(1):   $esi = COPY %213:gr32

********** MI Scheduling **********
main:%bb.52 if.then141
  From: %210:gr64 = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %210:gr64 = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
    SU(1): Data Latency=4 Reg=%210
  Single Issue       : false;
SU(1):   %211:gr64 = IMUL64rri32 %210:gr64, 1000, implicit-def dead $eflags
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(0): Data Latency=4 Reg=%210
  Successors:
    SU(2): Data Latency=1 Reg=%211
  Single Issue       : false;
SU(2):   %212:gr64 = LEA64r %211:gr64, 1, $noreg, @trhs, $noreg
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%211
  Single Issue       : false;
SU(3):   %213:gr32 = MOV32rm %stack.5.iside, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.iside)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 5
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %213:gr32 = MOV32rm %stack.5.iside, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.iside)
  Ready @3c
  BotQ.A BotLatency SU(3) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %212:gr64 = LEA64r %211:gr64, 1, $noreg, @trhs, $noreg
  Ready @0c
  BotQ.A TopLatency SU(2) 5c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %211:gr64 = IMUL64rri32 %210:gr64, 1000, implicit-def dead $eflags
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %210:gr64 = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
  Ready @5c
  BotQ.A BotLatency SU(0) 5c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.52 ***
SU(0):   %210:gr64 = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
SU(1):   %211:gr64 = IMUL64rri32 %210:gr64, 1000, implicit-def dead $eflags
SU(2):   %212:gr64 = LEA64r %211:gr64, 1, $noreg, @trhs, $noreg
SU(3):   %213:gr32 = MOV32rm %stack.5.iside, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.iside)

********** MI Scheduling **********
main:%bb.55 for.end151
  From: $rdi = MOV32ri64 @rmor
    To: CALL64pcrel32 @col2, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @rmor
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @tmmor
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $edx = COPY %182:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @col2, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) $edx = COPY %182:gr32
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @tmmor
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @rmor
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.55 ***
SU(0):   $rdi = MOV32ri64 @rmor
SU(1):   $rsi = MOV32ri64 @tmmor
SU(2):   $edx = COPY %182:gr32

********** MI Scheduling **********
main:%bb.57 if.end154
  From: $rdi = MOV32ri64 @ta1
    To: CALL64pcrel32 @add2, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @ta1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @t
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $edx = COPY %187:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @add2, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) $edx = COPY %187:gr32
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @t
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @ta1
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.57 ***
SU(0):   $rdi = MOV32ri64 @ta1
SU(1):   $rsi = MOV32ri64 @t
SU(2):   $edx = COPY %187:gr32

********** MI Scheduling **********
main:%bb.59 if.end157
  From: %192:fr64 = MOVSDrm_alt $rip, 1, $noreg, @time, $noreg :: (dereferenceable load 8 from @time)
    To: JCC_1 %bb.63, 4, implicit killed $eflags
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %192:fr64 = MOVSDrm_alt $rip, 1, $noreg, @time, $noreg :: (dereferenceable load 8 from @time)
  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 8
  Successors:
    SU(1): Data Latency=4 Reg=%192
    SU(1): Out  Latency=0
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(1):   %192:fr64 = ADDSDrm %192:fr64(tied-def 0), $rip, 1, $noreg, @dtime, $noreg :: (dereferenceable load 8 from @dtime)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 4
  Predecessors:
    SU(0): Data Latency=4 Reg=%192
    SU(0): Out  Latency=0
  Successors:
    SU(2): Data Latency=4 Reg=%192
  Single Issue       : false;
SU(2):   MOVSDmr $rip, 1, $noreg, @time, $noreg, %192:fr64 :: (store 8 into @time)
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Data Latency=4 Reg=%192
    SU(0): Ord  Latency=0 Memory
  Single Issue       : false;
SU(3):   CMP32mi8 %stack.3.step, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.step)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 4
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.63, 4, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=4 Artificial
Critical Path(GS-RR ): 8
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) CMP32mi8 %stack.3.step, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.step)
  Ready @4c
  BotQ.A BotLatency SU(3) 4c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOVSDmr $rip, 1, $noreg, @time, $noreg, %192:fr64 :: (store 8 into @time)
  Ready @0c
  BotQ.A TopLatency SU(2) 8c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %192:fr64 = ADDSDrm %192:fr64(tied-def 0), $rip, 1, $noreg, @dtime, $noreg :: (dereferenceable load 8 from @dtime)
  Ready @4c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %192:fr64 = MOVSDrm_alt $rip, 1, $noreg, @time, $noreg :: (dereferenceable load 8 from @time)
  Ready @8c
  BotQ.A BotLatency SU(0) 8c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.59 ***
SU(0):   %192:fr64 = MOVSDrm_alt $rip, 1, $noreg, @time, $noreg :: (dereferenceable load 8 from @time)
SU(1):   %192:fr64 = ADDSDrm %192:fr64(tied-def 0), $rip, 1, $noreg, @dtime, $noreg :: (dereferenceable load 8 from @dtime)
SU(2):   MOVSDmr $rip, 1, $noreg, @time, $noreg, %192:fr64 :: (store 8 into @time)
SU(3):   CMP32mi8 %stack.3.step, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.step)

********** MI Scheduling **********
main:%bb.60 land.lhs.true
  From: %193:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
    To: JCC_1 %bb.63, 5, implicit killed $eflags
 RegionInstrs: 8
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Global memory object and new barrier chain: SU(4).
Max Pressure: GR8_ABCD_H+GR32_BSI=2
GR8_ABCD_L+GR32_BSI=2
GR8_NOREX=4
GR32_TC=4
GR32_BPSP+GR32_TC=4
GR64_NOREX=4
GR64_TCW64=4
GR32_BPSP+GR64_TCW64=4
GR8=4
GR8+GR32_DIBP=4
GR8+GR32_BSI=4
GR64_TC+GR64_TCW64=4
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=4
GR8+GR64_NOREX=4
GR64_TC=4
GR8+GR64_TCW64=4
GR8+GR64_TC=4
GR16=8
Live In: 
Live Out: 
Live Thru: 
Top Pressure:

Bottom Pressure:

Excess PSets: 
SU(0):   %193:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 8
  Successors:
    SU(7): Data Latency=4 Reg=%193
    SU(2): Data Latency=4 Reg=%193
    SU(4): Ord  Latency=0 Barrier
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(1):   %194:gr32 = MOV32rm $rip, 1, $noreg, @fre, $noreg :: (dereferenceable load 4 from @fre)
  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 7
  Successors:
    SU(6): Data Latency=4 Reg=%194
    SU(4): Data Latency=4 Reg=%194
    SU(4): Ord  Latency=0 Barrier
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(2):   $eax = COPY %193:gr32
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 4
  Predecessors:
    SU(0): Data Latency=4 Reg=%193
  Successors:
    SU(3): Out  Latency=0
    SU(3): Data Latency=0 Reg=$eax
  Pressure Diff      : GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -2    GR32_TC -2    GR32_BPSP+GR32_TC -2    GR64_NOREX -2    GR64_TCW64 -2    GR32_BPSP+GR64_TCW64 -2    GR8 -2    GR8+GR32_DIBP -2    GR8+GR32_BSI -2    GR64_TC+GR64_TCW64 -2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -2    GR8+GR64_NOREX -2    GR64_TC -2    GR8+GR64_TCW64 -2
  Single Issue       : false;
SU(3):   CDQ implicit-def $eax, implicit-def $edx, implicit killed $eax
  # preds left       : 2
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 4
  Predecessors:
    SU(2): Out  Latency=0
    SU(2): Data Latency=0 Reg=$eax
  Successors:
    SU(4): Out  Latency=0
    SU(4): Data Latency=1 Reg=$eax
    SU(4): Out  Latency=0
    SU(4): Data Latency=1 Reg=$edx
  Pressure Diff      : GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -2    GR32_TC -2    GR32_BPSP+GR32_TC -2    GR64_NOREX -2    GR64_TCW64 -2    GR32_BPSP+GR64_TCW64 -2    GR8 -2    GR8+GR32_DIBP -2    GR8+GR32_BSI -2    GR64_TC+GR64_TCW64 -2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -2    GR8+GR64_NOREX -2    GR64_TC -2    GR8+GR64_TCW64 -2
  Single Issue       : false;
SU(4):   IDIV32r %194:gr32, implicit-def $eax, implicit-def dead $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
  # preds left       : 7
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 3
  Predecessors:
    SU(3): Out  Latency=0
    SU(3): Data Latency=1 Reg=$eax
    SU(3): Out  Latency=0
    SU(3): Data Latency=1 Reg=$edx
    SU(1): Data Latency=4 Reg=%194
    SU(1): Ord  Latency=0 Barrier
    SU(0): Ord  Latency=0 Barrier
  Successors:
    SU(5): Data Latency=1 Reg=$eax
    SU(7): Out  Latency=0
  Pressure Diff      : GR8_ABCD_H+GR32_BSI 1    GR8_ABCD_L+GR32_BSI 1    GR8_NOREX 2    GR32_TC 2    GR32_BPSP+GR32_TC 2    GR64_NOREX 2    GR64_TCW64 2    GR32_BPSP+GR64_TCW64 2    GR8 2    GR8+GR32_DIBP 2    GR8+GR32_BSI 2    GR64_TC+GR64_TCW64 2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit 2    GR8+GR64_NOREX 2    GR64_TC 2    GR8+GR64_TCW64 2
  Single Issue       : false;
SU(5):   %196:gr32 = COPY killed $eax
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1 Reg=$eax
  Successors:
    SU(6): Data Latency=0 Reg=%196
    SU(6): Out  Latency=0
  Pressure Diff      : GR8_ABCD_H+GR32_BSI 1    GR8_ABCD_L+GR32_BSI 1    GR8_NOREX 2    GR32_TC 2    GR32_BPSP+GR32_TC 2    GR64_NOREX 2    GR64_TCW64 2    GR32_BPSP+GR64_TCW64 2    GR8 2    GR8+GR32_DIBP 2    GR8+GR32_BSI 2    GR64_TC+GR64_TCW64 2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit 2    GR8+GR64_NOREX 2    GR64_TC 2    GR8+GR64_TCW64 2
  Single Issue       : false;
SU(6):   %196:gr32 = nsw IMUL32rr %196:gr32(tied-def 0), %194:gr32, implicit-def dead $eflags
  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 2
  Predecessors:
    SU(5): Data Latency=0 Reg=%196
    SU(5): Out  Latency=0
    SU(1): Data Latency=4 Reg=%194
  Successors:
    SU(7): Data Latency=1 Reg=%196
    SU(7): Out  Latency=0
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(7):   CMP32rr %196:gr32, %193:gr32, implicit-def $eflags
  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 1
  Predecessors:
    SU(6): Data Latency=1 Reg=%196
    SU(6): Out  Latency=0
    SU(4): Out  Latency=0
    SU(0): Data Latency=4 Reg=%193
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Pressure Diff      : GR16 4
  Single Issue       : false;
ExitSU:   JCC_1 %bb.63, 5, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(7): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 8
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 
Scheduling SU(7) CMP32rr %196:gr32, %193:gr32, implicit-def $eflags
Bottom Pressure:
GR16=4
  LiveReg: %196
  UpdateRegP: SU(7) CMP32rr %196:gr32, %193:gr32, implicit-def $eflags
              to GR16 2
  LiveReg: %193
  UpdateRegP: SU(2) $eax = COPY %193:gr32
              to GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -2    GR32_TC -2    GR32_BPSP+GR32_TC -2    GR64_NOREX -2    GR64_TCW64 -2    GR32_BPSP+GR64_TCW64 -2    GR8 -2    GR8+GR32_DIBP -2    GR8+GR32_BSI -2    GR64_TC+GR64_TCW64 -2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -2    GR8+GR64_NOREX -2    GR64_TC -2    GR8+GR64_TCW64 -2
  UpdateRegP: SU(7) CMP32rr %196:gr32, %193:gr32, implicit-def $eflags
              to 
  Ready @1c
  BotQ.A TopLatency SU(7) 7c
  BotQ.A BotLatency SU(7) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 
Scheduling SU(6) %196:gr32 = nsw IMUL32rr %196:gr32(tied-def 0), %194:gr32, implicit-def dead $eflags
Bottom Pressure:
GR16=6
  LiveReg: %196
  UpdateRegP: SU(6) %196:gr32 = nsw IMUL32rr %196:gr32(tied-def 0), %194:gr32, implicit-def dead $eflags
              to 
  LiveReg: %194
  UpdateRegP: SU(4) IDIV32r %194:gr32, implicit-def $eax, implicit-def dead $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
              to GR8_ABCD_H+GR32_BSI 1    GR8_ABCD_L+GR32_BSI 1    GR8_NOREX 2    GR32_TC 2    GR32_BPSP+GR32_TC 2    GR64_NOREX 2    GR64_TCW64 2    GR32_BPSP+GR64_TCW64 2    GR8 2    GR8+GR32_DIBP 2    GR8+GR32_BSI 2    GR64_TC+GR64_TCW64 2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit 2    GR8+GR64_NOREX 2    GR64_TC 2    GR8+GR64_TCW64 2
  UpdateRegP: SU(6) %196:gr32 = nsw IMUL32rr %196:gr32(tied-def 0), %194:gr32, implicit-def dead $eflags
              to GR16 -2
  Ready @2c
  BotQ.A BotLatency SU(6) 2c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 
Scheduling SU(5) %196:gr32 = COPY killed $eax
Bottom Pressure:
GR8_ABCD_H+GR32_BSI=1
GR8_ABCD_L+GR32_BSI=1
GR8_NOREX=2
GR32_TC=2
GR32_BPSP+GR32_TC=2
GR64_NOREX=2
GR64_TCW64=2
GR32_BPSP+GR64_TCW64=2
GR8=2
GR8+GR32_DIBP=2
GR8+GR32_BSI=2
GR64_TC+GR64_TCW64=2
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=2
GR8+GR64_NOREX=2
GR64_TC=2
GR8+GR64_TCW64=2
GR8+GR64_TC=2
GR16=6
  Ready @2c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) IDIV32r %194:gr32, implicit-def $eax, implicit-def dead $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
Bottom Pressure:
GR8_ABCD_H+GR32_BSI=2
GR8_ABCD_L+GR32_BSI=2
GR8_NOREX=4
GR32_TC=4
GR32_BPSP+GR32_TC=4
GR64_NOREX=4
GR64_TCW64=4
GR32_BPSP+GR64_TCW64=4
GR8=4
GR8+GR32_DIBP=4
GR8+GR32_BSI=4
GR64_TC+GR64_TCW64=4
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=4
GR8+GR64_NOREX=4
GR64_TC=4
GR8+GR64_TCW64=4
GR8+GR64_TC=4
GR16=8
  GR8_NOREX: 4 <= 6(+ 0 livethru)
  Ready @3c
  BotQ.A BotLatency SU(4) 3c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
  Rescheduling physreg copy SU(5):   %196:gr32 = COPY killed $eax
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 1 
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) CDQ implicit-def $eax, implicit-def $edx, implicit $eax
Bottom Pressure:
GR8_ABCD_H+GR32_BSI=1
GR8_ABCD_L+GR32_BSI=1
GR8_NOREX=2
GR32_TC=2
GR32_BPSP+GR32_TC=2
GR64_NOREX=2
GR64_TCW64=2
GR32_BPSP+GR64_TCW64=2
GR8=2
GR8+GR32_DIBP=2
GR8+GR32_BSI=2
GR64_TC+GR64_TCW64=2
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=2
GR8+GR64_NOREX=2
GR64_TC=2
GR8+GR64_TCW64=2
GR8+GR64_TC=2
GR16=6
  GR8_NOREX: 4 <= 6(+ 0 livethru)
  Ready @4c
  BotQ.A BotLatency SU(3) 4c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) $eax = COPY %193:gr32
Bottom Pressure:
GR16=4
  GR8_NOREX: 4 <= 6(+ 0 livethru)
  Ready @4c
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %194:gr32 = MOV32rm $rip, 1, $noreg, @fre, $noreg :: (dereferenceable load 4 from @fre)
Bottom Pressure:
GR16=2
  Ready @7c
  BotQ.A BotLatency SU(1) 7c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %193:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
Bottom Pressure:

  Ready @8c
  BotQ.A BotLatency SU(0) 8c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.60 ***
SU(0):   %193:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
SU(1):   %194:gr32 = MOV32rm $rip, 1, $noreg, @fre, $noreg :: (dereferenceable load 4 from @fre)
SU(2):   $eax = COPY %193:gr32
SU(3):   CDQ implicit-def $eax, implicit-def $edx, implicit $eax
SU(4):   IDIV32r %194:gr32, implicit-def $eax, implicit-def dead $edx, implicit-def dead $eflags, implicit $eax, implicit killed $edx
SU(5):   %196:gr32 = COPY $eax
SU(6):   %196:gr32 = nsw IMUL32rr %196:gr32(tied-def 0), %194:gr32, implicit-def dead $eflags
SU(7):   CMP32rr %196:gr32, %193:gr32, implicit-def $eflags

********** MI Scheduling **********
main:%bb.61 if.then161
  From: %198:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
    To: JCC_1 %bb.64, 4, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %198:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 8
  Successors:
    SU(1): Data Latency=4 Reg=%198
  Single Issue       : false;
SU(1):   CMP32rm %198:gr32, $rip, 1, $noreg, @niter, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @niter)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 4
  Predecessors:
    SU(0): Data Latency=4 Reg=%198
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.64, 4, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=4 Artificial
Critical Path(GS-RR ): 8
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32rm %198:gr32, $rip, 1, $noreg, @niter, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @niter)
  Ready @4c
  BotQ.A TopLatency SU(1) 4c
  BotQ.A BotLatency SU(1) 4c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %198:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  Ready @8c
  BotQ.A BotLatency SU(0) 8c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.61 ***
SU(0):   %198:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
SU(1):   CMP32rm %198:gr32, $rip, 1, $noreg, @niter, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @niter)

********** MI Scheduling **********
main:%bb.62 if.then163
  From: $rdi = COPY %201:gr64
    To: CALL64pcrel32 @adaptation, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %201:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %200:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @adaptation, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $esi = COPY %200:gr32
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = COPY %201:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.62 ***
SU(0):   $rdi = COPY %201:gr64
SU(1):   $esi = COPY %200:gr32

********** MI Scheduling **********
main:%bb.64 if.end166
  From: %203:fr64 = CVTSI2SDrm $rip, 1, $noreg, @nelt, $noreg :: (dereferenceable load 4 from @nelt)
    To: JMP_1 %bb.20
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %203:fr64 = CVTSI2SDrm $rip, 1, $noreg, @nelt, $noreg :: (dereferenceable load 4 from @nelt)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 8
  Successors:
    SU(1): Data Latency=4 Reg=%203
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %203:fr64 = ADDSDrm %203:fr64(tied-def 0), %stack.11.nelt_tot, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.nelt_tot)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 4
  Predecessors:
    SU(0): Data Latency=4 Reg=%203
    SU(0): Out  Latency=0
  Successors:
    SU(2): Data Latency=4 Reg=%203
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOVSDmr %stack.11.nelt_tot, 1, $noreg, 0, $noreg, %203:fr64 :: (store 8 into %ir.nelt_tot)
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Data Latency=4 Reg=%203
    SU(1): Ord  Latency=0 Memory
  Single Issue       : false;
SU(3):   INC32m %stack.3.step, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.step), (dereferenceable load 4 from %ir.step)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   JMP_1 %bb.20
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 8
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) INC32m %stack.3.step, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.step), (dereferenceable load 4 from %ir.step)
  Ready @3c
  BotQ.A BotLatency SU(3) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOVSDmr %stack.11.nelt_tot, 1, $noreg, 0, $noreg, %203:fr64 :: (store 8 into %ir.nelt_tot)
  Ready @0c
  BotQ.A TopLatency SU(2) 8c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %203:fr64 = ADDSDrm %203:fr64(tied-def 0), %stack.11.nelt_tot, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.nelt_tot)
  Ready @4c
  BotQ.A BotLatency SU(1) 4c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %203:fr64 = CVTSI2SDrm $rip, 1, $noreg, @nelt, $noreg :: (dereferenceable load 4 from @nelt)
  Ready @8c
  BotQ.A BotLatency SU(0) 8c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.64 ***
SU(0):   %203:fr64 = CVTSI2SDrm $rip, 1, $noreg, @nelt, $noreg :: (dereferenceable load 4 from @nelt)
SU(1):   %203:fr64 = ADDSDrm %203:fr64(tied-def 0), %stack.11.nelt_tot, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.nelt_tot)
SU(2):   MOVSDmr %stack.11.nelt_tot, 1, $noreg, 0, $noreg, %203:fr64 :: (store 8 into %ir.nelt_tot)
SU(3):   INC32m %stack.3.step, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.step), (dereferenceable load 4 from %ir.step)

********** MI Scheduling **********
main:%bb.65 for.end170
  From: $rdi = MOV32ri64 @.str.23
    To: PUSH64i32 @.str.33, implicit-def $rsp, implicit $rsp
 RegionInstrs: 8
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=6
GR32_BPSP+GR64_TCW64=6
GR8=8
GR8+GR32_DIBP=8
GR8+GR32_BSI=8
GR64_TC+GR64_TCW64=8
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=8
GR8+GR64_NOREX=8
GR64_TC=8
GR8+GR64_TCW64=8
GR8+GR64_TC=8
FR32X=2
GR16=9
Live In: %109 %107 %111 %110 
Live Out: XMM1 XMM0 R9B R9BH R9WH R8B R8BH R8WH CH CL HCX DH DL HDX SIL SIH HSI DIL DIH HDI 
Live Thru: 
Top Pressure:
FR32=2
FR32X=2
GR16=4
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=6
GR32_BPSP+GR64_TCW64=6
GR8=8
GR8+GR32_DIBP=8
GR8+GR32_BSI=8
GR64_TC+GR64_TCW64=8
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=8
GR8+GR64_NOREX=8
GR64_TC=8
GR8+GR64_TCW64=8
GR8+GR64_TC=8
FR32X=2
GR16=8
Excess PSets: 
SU(0):   $rdi = MOV32ri64 @.str.23
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR32_BPSP -1    GR32_SIDI -1    GR32_DIBP+GR32_SIDI -1    GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR64_NOREX -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1    GR16 -1
  Single Issue       : false;
SU(1):   $esi = COPY %110:gr32
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR32_BSI -1    GR32_SIDI -1    GR32_DIBP+GR32_SIDI -1    GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -1    GR64_NOREX -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1
  Single Issue       : false;
SU(2):   $edx = MOV32ri 7
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -2    GR32_TC -2    GR32_BPSP+GR32_TC -2    GR64_NOREX -2    GR64_TCW64 -2    GR32_BPSP+GR64_TCW64 -2    GR8 -2    GR8+GR32_DIBP -2    GR8+GR32_BSI -2    GR64_TC+GR64_TCW64 -2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -2    GR8+GR64_NOREX -2    GR64_TC -2    GR8+GR64_TCW64 -2
  Single Issue       : false;
SU(3):   $ecx = MOV32ri 0
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR32_BSI -2    GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -2    GR32_TC -2    GR32_BPSP+GR32_TC -2    GR64_NOREX -2    GR64_TCW64 -2    GR32_BPSP+GR64_TCW64 -2    GR8 -2    GR8+GR32_DIBP -2    GR8+GR32_BSI -2    GR64_TC+GR64_TCW64 -2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -2    GR8+GR64_NOREX -2    GR64_TC -2
  Single Issue       : false;
SU(4):   $r8d = MOV32ri 0
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR64_TCW64 -1    GR32_BPSP+GR64_TCW64 -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1    GR16 -1
  Single Issue       : false;
SU(5):   $r9d = COPY %111:gr32
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR64_TCW64 -1    GR32_BPSP+GR64_TCW64 -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1    GR16 1
  Single Issue       : false;
SU(6):   $xmm0 = COPY %107:fr64
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   $xmm1 = COPY %109:fr64
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : 
  Single Issue       : false;
ExitSU:   PUSH64i32 @.str.33, implicit-def $rsp, implicit $rsp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 6 5 4 3 2 1 0 
  Cand SU(7) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(7) $xmm1 = COPY %109:fr64
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=6
GR32_BPSP+GR64_TCW64=6
GR8=8
GR8+GR32_DIBP=8
GR8+GR32_BSI=8
GR64_TC+GR64_TCW64=8
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=8
GR8+GR64_NOREX=8
GR64_TC=8
GR8+GR64_TCW64=8
GR8+GR64_TC=8
FR32X=2
GR16=8
  LiveReg: %109
  UpdateRegP: SU(7) $xmm1 = COPY %109:fr64
              to FR32 -1    FR32X -1
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 6 5 4 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(6) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(6) $xmm0 = COPY %107:fr64
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=6
GR32_BPSP+GR64_TCW64=6
GR8=8
GR8+GR32_DIBP=8
GR8+GR32_BSI=8
GR64_TC+GR64_TCW64=8
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=8
GR8+GR64_NOREX=8
GR64_TC=8
GR8+GR64_TCW64=8
GR8+GR64_TC=8
FR32X=2
GR16=8
  LiveReg: %107
  UpdateRegP: SU(6) $xmm0 = COPY %107:fr64
              to FR32 -1    FR32X -1
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 5 4 3 2 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) $r9d = COPY %111:gr32
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=5
GR32_BPSP+GR64_TCW64=5
GR8=7
GR8+GR32_DIBP=7
GR8+GR32_BSI=7
GR64_TC+GR64_TCW64=7
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=7
GR8+GR64_NOREX=7
GR64_TC=7
GR8+GR64_TCW64=7
GR8+GR64_TC=7
FR32X=2
GR16=9
  LiveReg: %111
  UpdateRegP: SU(5) $r9d = COPY %111:gr32
              to GR64_TCW64 -1    GR32_BPSP+GR64_TCW64 -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1    GR16 -1
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 4 3 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) $r8d = MOV32ri 0
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=4
GR32_BPSP+GR64_TCW64=4
GR8=6
GR8+GR32_DIBP=6
GR8+GR32_BSI=6
GR64_TC+GR64_TCW64=6
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=6
GR8+GR64_NOREX=6
GR64_TC=6
GR8+GR64_TCW64=6
GR8+GR64_TC=6
FR32X=2
GR16=8
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 3 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) $ecx = MOV32ri 0
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=1
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=2
GR8_ABCD_L+GR32_BSI=2
GR8_NOREX=3
GR32_TC=2
GR32_BPSP+GR32_TC=2
FR32=2
GR64_NOREX=4
GR64_TCW64=2
GR32_BPSP+GR64_TCW64=2
GR8=4
GR8+GR32_DIBP=4
GR8+GR32_BSI=4
GR64_TC+GR64_TCW64=4
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=4
GR8+GR64_NOREX=4
GR64_TC=4
GR8+GR64_TCW64=4
GR8+GR64_TC=4
FR32X=2
GR16=6
  GR8_NOREX: 5 <= 6(+ 0 livethru)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $edx = MOV32ri 7
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=1
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=1
GR8_ABCD_L+GR32_BSI=1
GR8_NOREX=1
FR32=2
GR64_NOREX=2
GR8=2
GR8+GR32_DIBP=2
GR8+GR32_BSI=2
GR64_TC+GR64_TCW64=2
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=2
GR8+GR64_NOREX=2
GR64_TC=2
GR8+GR64_TCW64=2
GR8+GR64_TC=2
FR32X=2
GR16=4
  GR8_NOREX: 5 <= 6(+ 0 livethru)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %110:gr32
Bottom Pressure:
GR32_BPSP=1
GR32_SIDI=1
GR32_DIBP+GR32_SIDI=1
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
FR32=2
GR64_NOREX=1
GR8=1
GR8+GR32_DIBP=1
GR8+GR32_BSI=1
GR64_TC+GR64_TCW64=1
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8+GR64_NOREX=1
GR64_TC=1
GR8+GR64_TCW64=1
GR8+GR64_TC=1
FR32X=2
GR16=5
  GR32_DIBP+GR32_SIDI: 2 <= 4(+ 0 livethru)
  GR8_NOREX: 5 <= 6(+ 0 livethru)
  LiveReg: %110
  UpdateRegP: SU(1) $esi = COPY %110:gr32
              to GR32_BSI -1    GR32_SIDI -1    GR32_DIBP+GR32_SIDI -1    GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -1    GR64_NOREX -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.23
Bottom Pressure:
FR32=2
FR32X=2
GR16=4
  GR32_BPSP: 1 <= 2(+ 0 livethru)
  GR32_DIBP+GR32_SIDI: 2 <= 4(+ 0 livethru)
  Ready @0c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.65 ***
SU(0):   $rdi = MOV32ri64 @.str.23
SU(1):   $esi = COPY %110:gr32
SU(2):   $edx = MOV32ri 7
SU(3):   $ecx = MOV32ri 0
SU(4):   $r8d = MOV32ri 0
SU(5):   $r9d = COPY %111:gr32
SU(6):   $xmm0 = COPY %107:fr64
SU(7):   $xmm1 = COPY %109:fr64

********** MI Scheduling **********
main:%bb.65 for.end170
  From: %104:gr32 = IMUL32rmi8 $rip, 1, $noreg, @nmxh, $noreg, 125, implicit-def dead $eflags :: (dereferenceable load 4 from @nmxh)
    To: ADJCALLSTACKDOWN64 88, 0, 88, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 12
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: FR32=3
FR32X=3
GR16=6
Live In: 
Live Out: %245 %111 %110 %109 %107 
Live Thru: 
  LiveReg: %245
  LiveReg: %111
  LiveReg: %110
  LiveReg: %109
  UpdateRegP: SU(8) MOVSDmr %stack.9.mflops, 1, $noreg, 0, $noreg, %109:fr64 :: (store 8 into %ir.mflops)
              to 
  LiveReg: %107
  UpdateRegP: SU(6) %108:fr64 = MULSDrr %108:fr64(tied-def 0), %107:fr64
              to 
Top Pressure:

Bottom Pressure:
FR32=2
FR32X=2
GR16=6
Excess PSets: 
SU(0):   %104:gr32 = IMUL32rmi8 $rip, 1, $noreg, @nmxh, $noreg, 125, implicit-def dead $eflags :: (dereferenceable load 4 from @nmxh)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 20
  Successors:
    SU(1): Data Latency=4 Reg=%104
    SU(1): Out  Latency=0
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(1):   %104:gr32 = ADD32ri8 %104:gr32(tied-def 0), 125, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 16
  Predecessors:
    SU(0): Data Latency=4 Reg=%104
    SU(0): Out  Latency=0
  Successors:
    SU(2): Data Latency=1 Reg=%104
  Pressure Diff      : 
  Single Issue       : false;
SU(2):   %109:fr64 = CVTSI2SDrr %104:gr32
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 15
  Predecessors:
    SU(1): Data Latency=1 Reg=%104
  Successors:
    SU(3): Data Latency=1 Reg=%109
    SU(3): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1    GR16 2
  Single Issue       : false;
SU(3):   %109:fr64 = MULSDrm %109:fr64(tied-def 0), %stack.11.nelt_tot, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.nelt_tot)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 6
  Height             : 14
  Predecessors:
    SU(2): Data Latency=1 Reg=%109
    SU(2): Out  Latency=0
  Successors:
    SU(7): Data Latency=4 Reg=%109
    SU(7): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(4):   %107:fr64 = MOVSDrm_alt %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 15
  Successors:
    SU(6): Data Latency=4 Reg=%107
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(5):   %108:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 15
  Successors:
    SU(6): Data Latency=4 Reg=%108
    SU(6): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(6):   %108:fr64 = MULSDrr %108:fr64(tied-def 0), %107:fr64
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 11
  Predecessors:
    SU(5): Data Latency=4 Reg=%108
    SU(5): Out  Latency=0
    SU(4): Data Latency=4 Reg=%107
  Successors:
    SU(7): Data Latency=1 Reg=%108
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   %109:fr64 = DIVSDrr %109:fr64(tied-def 0), %108:fr64
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 10
  Depth              : 10
  Height             : 10
  Predecessors:
    SU(3): Data Latency=4 Reg=%109
    SU(6): Data Latency=1 Reg=%108
    SU(3): Out  Latency=0
  Successors:
    SU(8): Data Latency=10 Reg=%109
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(8):   MOVSDmr %stack.9.mflops, 1, $noreg, 0, $noreg, %109:fr64 :: (store 8 into %ir.mflops)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 20
  Height             : 0
  Predecessors:
    SU(7): Data Latency=10 Reg=%109
  Pressure Diff      : 
  Single Issue       : false;
SU(9):   %110:gr32 = MOVSX32rm8 %stack.12.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(10):   %111:gr32 = MOV32rm $rip, 1, $noreg, @niter, $noreg :: (dereferenceable load 4 from @niter)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(11):   undef %245.sub_32bit:gr64_with_sub_8bit = MOV32rm %stack.14.verified, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.verified)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 88, 0, 88, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(11): Ord  Latency=3 Artificial
    SU(10): Ord  Latency=3 Artificial
    SU(9): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 20
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 11 10 9 
  Cand SU(8) ORDER                              
  Cand SU(11) ORDER                              
Pick Bot ORDER     
Scheduling SU(11) undef %245.sub_32bit:gr64_with_sub_8bit = MOV32rm %stack.14.verified, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.verified)
Bottom Pressure:
FR32=2
FR32X=2
GR16=4
  Ready @3c
  BotQ.A BotLatency SU(11) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 9 10 
  Cand SU(8) ORDER                              
  Cand SU(9) ORDER                              
  Cand SU(10) ORDER                              
Pick Bot ORDER     
Scheduling SU(10) %111:gr32 = MOV32rm $rip, 1, $noreg, @niter, $noreg :: (dereferenceable load 4 from @niter)
Bottom Pressure:
FR32=2
FR32X=2
GR16=2
  Ready @3c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 9 
  Cand SU(8) ORDER                              
  Cand SU(9) ORDER                              
Pick Bot ORDER     
Scheduling SU(9) %110:gr32 = MOVSX32rm8 %stack.12.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
Bottom Pressure:
FR32=2
FR32X=2
  Ready @3c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 
Scheduling SU(8) MOVSDmr %stack.9.mflops, 1, $noreg, 0, $noreg, %109:fr64 :: (store 8 into %ir.mflops)
Bottom Pressure:
FR32=2
FR32X=2
  Ready @0c
  BotQ.A TopLatency SU(8) 20c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 
Scheduling SU(7) %109:fr64 = DIVSDrr %109:fr64(tied-def 0), %108:fr64
Bottom Pressure:
FR32=3
FR32X=3
  LiveReg: %109
  UpdateRegP: SU(7) %109:fr64 = DIVSDrr %109:fr64(tied-def 0), %108:fr64
              to 
  LiveReg: %108
  UpdateRegP: SU(7) %109:fr64 = DIVSDrr %109:fr64(tied-def 0), %108:fr64
              to FR32 -1    FR32X -1
  Ready @10c
  BotQ.A BotLatency SU(7) 10c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 10c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 3 
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) %108:fr64 = MULSDrr %108:fr64(tied-def 0), %107:fr64
Bottom Pressure:
FR32=3
FR32X=3
  LiveReg: %108
  UpdateRegP: SU(6) %108:fr64 = MULSDrr %108:fr64(tied-def 0), %107:fr64
              to FR32 -1    FR32X -1
  Ready @11c
  BotQ.A BotLatency SU(6) 11c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 11c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 5 4 
  Cand SU(3) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %108:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
Bottom Pressure:
FR32=2
FR32X=2
  Ready @15c
  BotQ.A BotLatency SU(5) 15c
BotQ.A @1c
  Retired: 7
  Executed: 1c
  Critical: 1c, 7 MOps
  ExpectedLatency: 15c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 4 
  Cand SU(3) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %107:fr64 = MOVSDrm_alt %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
Bottom Pressure:
FR32=1
FR32X=1
  Ready @15c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 2c
  Critical: 2c, 8 MOps
  ExpectedLatency: 15c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) %109:fr64 = MULSDrm %109:fr64(tied-def 0), %stack.11.nelt_tot, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.nelt_tot)
Bottom Pressure:
FR32=1
FR32X=1
  LiveReg: %109
  UpdateRegP: SU(3) %109:fr64 = MULSDrm %109:fr64(tied-def 0), %stack.11.nelt_tot, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.nelt_tot)
              to FR32 -1    FR32X -1
  Ready @14c
BotQ.A @2c
  Retired: 9
  Executed: 2c
  Critical: 2c, 9 MOps
  ExpectedLatency: 15c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %109:fr64 = CVTSI2SDrr %104:gr32
Bottom Pressure:
GR16=2
  LiveReg: %104
  UpdateRegP: SU(2) %109:fr64 = CVTSI2SDrr %104:gr32
              to FR32 -1    FR32X -1
  Ready @15c
BotQ.A @2c
  Retired: 10
  Executed: 2c
  Critical: 2c, 10 MOps
  ExpectedLatency: 15c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %104:gr32 = ADD32ri8 %104:gr32(tied-def 0), 125, implicit-def dead $eflags
Bottom Pressure:
GR16=2
  LiveReg: %104
  UpdateRegP: SU(1) %104:gr32 = ADD32ri8 %104:gr32(tied-def 0), 125, implicit-def dead $eflags
              to GR16 -2
  Ready @16c
  BotQ.A BotLatency SU(1) 16c
BotQ.A @2c
  Retired: 11
  Executed: 2c
  Critical: 2c, 11 MOps
  ExpectedLatency: 16c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %104:gr32 = IMUL32rmi8 $rip, 1, $noreg, @nmxh, $noreg, 125, implicit-def dead $eflags :: (dereferenceable load 4 from @nmxh)
Bottom Pressure:

  Ready @20c
  BotQ.A BotLatency SU(0) 20c
  *** Max MOps 4 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 12
  Executed: 3c
  Critical: 3c, 12 MOps
  ExpectedLatency: 20c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.65 ***
SU(0):   %104:gr32 = IMUL32rmi8 $rip, 1, $noreg, @nmxh, $noreg, 125, implicit-def dead $eflags :: (dereferenceable load 4 from @nmxh)
SU(1):   %104:gr32 = ADD32ri8 %104:gr32(tied-def 0), 125, implicit-def dead $eflags
SU(2):   %109:fr64 = CVTSI2SDrr %104:gr32
SU(3):   %109:fr64 = MULSDrm %109:fr64(tied-def 0), %stack.11.nelt_tot, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.nelt_tot)
SU(4):   %107:fr64 = MOVSDrm_alt %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
SU(5):   %108:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
SU(6):   %108:fr64 = MULSDrr %108:fr64(tied-def 0), %107:fr64
SU(7):   %109:fr64 = DIVSDrr %109:fr64(tied-def 0), %108:fr64
SU(8):   MOVSDmr %stack.9.mflops, 1, $noreg, 0, $noreg, %109:fr64 :: (store 8 into %ir.mflops)
SU(9):   %110:gr32 = MOVSX32rm8 %stack.12.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
SU(10):   %111:gr32 = MOV32rm $rip, 1, $noreg, @niter, $noreg :: (dereferenceable load 4 from @niter)
SU(11):   undef %245.sub_32bit:gr64_with_sub_8bit = MOV32rm %stack.14.verified, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.verified)

********** MI Scheduling **********
main:%bb.65 for.end170
  From: %101:gr64 = LEA64r %stack.12.Class, 1, $noreg, 0, $noreg
    To: CALL64pcrel32 @verify, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %101:gr64 = LEA64r %stack.12.Class, 1, $noreg, 0, $noreg
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(2): Data Latency=1 Reg=%101
  Single Issue       : false;
SU(1):   %102:gr64 = LEA64r %stack.14.verified, 1, $noreg, 0, $noreg
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(3): Data Latency=1 Reg=%102
  Single Issue       : false;
SU(2):   $rdi = COPY %101:gr64
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(0): Data Latency=1 Reg=%101
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $rsi = COPY %102:gr64
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%102
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @verify, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) $rsi = COPY %102:gr64
  Ready @0c
  BotQ.A TopLatency SU(3) 1c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) $rdi = COPY %101:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %102:gr64 = LEA64r %stack.14.verified, 1, $noreg, 0, $noreg
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %101:gr64 = LEA64r %stack.12.Class, 1, $noreg, 0, $noreg
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.65 ***
SU(0):   %101:gr64 = LEA64r %stack.12.Class, 1, $noreg, 0, $noreg
SU(1):   %102:gr64 = LEA64r %stack.14.verified, 1, $noreg, 0, $noreg
SU(2):   $rdi = COPY %101:gr64
SU(3):   $rsi = COPY %102:gr64

********** MI Scheduling **********
main:%bb.65 for.end170
  From: %100:fr64 = COPY killed $xmm0
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %100:fr64 = COPY killed $xmm0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Data Latency=0 Reg=%100
  Single Issue       : false;
SU(1):   MOVSDmr %stack.10.tmax, 1, $noreg, 0, $noreg, %100:fr64 :: (store 8 into %ir.tmax)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%100
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOVSDmr %stack.10.tmax, 1, $noreg, 0, $noreg, %100:fr64 :: (store 8 into %ir.tmax)
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %100:fr64 = COPY killed $xmm0
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.65 ***
SU(0):   %100:fr64 = COPY killed $xmm0
SU(1):   MOVSDmr %stack.10.tmax, 1, $noreg, 0, $noreg, %100:fr64 :: (store 8 into %ir.tmax)

********** MI Scheduling **********
main:%bb.68 for.body183
  From: %159:fr64 = COPY killed $xmm0
    To: JMP_1 %bb.67
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %159:fr64 = COPY killed $xmm0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(2): Data Latency=0 Reg=%159
  Single Issue       : false;
SU(1):   %160:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 4
  Successors:
    SU(2): Data Latency=4 Reg=%160
    SU(3): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOVSDmr %stack.16.trecs, 8, %160:gr64_nosp, 0, $noreg, %159:fr64 :: (store 8 into %ir.arrayidx186)
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Data Latency=4 Reg=%160
    SU(0): Data Latency=0 Reg=%159
  Single Issue       : false;
SU(3):   INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Predecessors:
    SU(1): Ord  Latency=0 Memory
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   JMP_1 %bb.67
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 4
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  Ready @3c
  BotQ.A BotLatency SU(3) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOVSDmr %stack.16.trecs, 8, %160:gr64_nosp, 0, $noreg, %159:fr64 :: (store 8 into %ir.arrayidx186)
  Ready @0c
  BotQ.A TopLatency SU(2) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) %160:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  Ready @4c
  BotQ.A BotLatency SU(1) 4c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %159:fr64 = COPY killed $xmm0
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.68 ***
SU(0):   %159:fr64 = COPY killed $xmm0
SU(1):   %160:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
SU(2):   MOVSDmr %stack.16.trecs, 8, %160:gr64_nosp, 0, $noreg, %159:fr64 :: (store 8 into %ir.arrayidx186)
SU(3):   INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)

********** MI Scheduling **********
main:%bb.69 for.end189
  From: %119:fr64 = MOVSDrm_alt %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
    To: JCC_1 %bb.71, 5, implicit $eflags
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %119:fr64 = MOVSDrm_alt %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=4 Reg=%119
  Single Issue       : false;
SU(1):   %120:fr64 = FsFLD0SD
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(2): Data Latency=1 Reg=%120
  Single Issue       : false;
SU(2):   UCOMISDrr %119:fr64, %120:fr64, implicit-def $eflags
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(1): Data Latency=1 Reg=%120
    SU(0): Data Latency=4 Reg=%119
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.71, 5, implicit $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 5
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) UCOMISDrr %119:fr64, %120:fr64, implicit-def $eflags
  Ready @1c
  BotQ.A TopLatency SU(2) 4c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %120:fr64 = FsFLD0SD
  Ready @2c
  BotQ.A BotLatency SU(1) 2c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %119:fr64 = MOVSDrm_alt %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @5c
  BotQ.A BotLatency SU(0) 5c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.69 ***
SU(0):   %119:fr64 = MOVSDrm_alt %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
SU(1):   %120:fr64 = FsFLD0SD
SU(2):   UCOMISDrr %119:fr64, %120:fr64, implicit-def $eflags

********** MI Scheduling **********
main:%bb.70 if.then192
  From: %121:gr64 = MOV64ri 4607182418800017408
    To: End RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %121:gr64 = MOV64ri 4607182418800017408
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=1 Reg=%121
  Single Issue       : false;
SU(1):   MOV64mr %stack.10.tmax, 1, $noreg, 0, $noreg, %121:gr64 :: (store 8 into %ir.tmax)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(0): Data Latency=1 Reg=%121
  Single Issue       : false;
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %stack.10.tmax, 1, $noreg, 0, $noreg, %121:gr64 :: (store 8 into %ir.tmax)
  Ready @0c
  BotQ.A TopLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %121:gr64 = MOV64ri 4607182418800017408
  Ready @1c
  BotQ.A BotLatency SU(0) 1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.70 ***
SU(0):   %121:gr64 = MOV64ri 4607182418800017408
SU(1):   MOV64mr %stack.10.tmax, 1, $noreg, 0, $noreg, %121:gr64 :: (store 8 into %ir.tmax)

********** MI Scheduling **********
main:%bb.71 if.end193
  From: MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
    To: End RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   %241:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %241:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
  Ready @3c
  BotQ.A BotLatency SU(1) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.71 ***
SU(0):   MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
SU(1):   %241:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)

********** MI Scheduling **********
main:%bb.71 if.end193
  From: $rdi = MOV32ri64 @.str.34
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.34
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.34
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.71 ***
SU(0):   $rdi = MOV32ri64 @.str.34
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.73 for.body198
  From: $rdi = MOV32ri64 @.str.35
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.35
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %130:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %131:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $xmm1 = COPY %133:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   $al = MOV8ri 2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) $al = MOV8ri 2
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $xmm1 = COPY %133:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $xmm0 = COPY %131:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $rsi = COPY %130:gr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.35
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.73 ***
SU(0):   $rdi = MOV32ri64 @.str.35
SU(1):   $rsi = COPY %130:gr64
SU(2):   $xmm0 = COPY %131:fr64
SU(3):   $xmm1 = COPY %133:fr64
SU(4):   $al = MOV8ri 2

********** MI Scheduling **********
main:%bb.73 for.body198
  From: %129:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %129:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 12
  Successors:
    SU(2): Data Latency=4 Reg=%129
    SU(1): Data Latency=4 Reg=%129
  Single Issue       : false;
SU(1):   %130:gr64 = MOV64rm %stack.17.t_names, 8, %129:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx200)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 3
  Predecessors:
    SU(0): Data Latency=4 Reg=%129
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
SU(2):   %131:fr64 = MOVSDrm_alt %stack.16.trecs, 8, %129:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx204)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 8
  Predecessors:
    SU(0): Data Latency=4 Reg=%129
  Successors:
    SU(3): Data Latency=4 Reg=%131
  Single Issue       : false;
SU(3):   %133:fr64 = COPY %131:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(2): Data Latency=4 Reg=%131
  Successors:
    SU(4): Data Latency=0 Reg=%133
    SU(4): Out  Latency=0
  Single Issue       : false;
SU(4):   %133:fr64 = MULSDrr %133:fr64(tied-def 0), %241:fr64
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(3): Data Latency=0 Reg=%133
    SU(3): Out  Latency=0
  Successors:
    SU(5): Data Latency=1 Reg=%133
    SU(5): Out  Latency=0
  Single Issue       : false;
SU(5):   %133:fr64 = DIVSDrm %133:fr64(tied-def 0), %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 9
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1 Reg=%133
    SU(4): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=3 Artificial
    SU(1): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 12
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 1 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %133:fr64 = DIVSDrm %133:fr64(tied-def 0), %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @3c
  BotQ.A TopLatency SU(5) 9c
  BotQ.A BotLatency SU(5) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 4 
  Cand SU(1) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %133:fr64 = MULSDrr %133:fr64(tied-def 0), %241:fr64
  Ready @4c
  BotQ.A BotLatency SU(4) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 3 
  Cand SU(1) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %133:fr64 = COPY %131:fr64
  Ready @4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %131:fr64 = MOVSDrm_alt %stack.16.trecs, 8, %129:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx204)
  Ready @8c
  BotQ.A BotLatency SU(2) 8c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %130:gr64 = MOV64rm %stack.17.t_names, 8, %129:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx200)
  Ready @3c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %129:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  Ready @12c
  BotQ.A BotLatency SU(0) 12c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.73 ***
SU(0):   %129:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
SU(1):   %130:gr64 = MOV64rm %stack.17.t_names, 8, %129:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx200)
SU(2):   %131:fr64 = MOVSDrm_alt %stack.16.trecs, 8, %129:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx204)
SU(3):   %133:fr64 = COPY %131:fr64
SU(4):   %133:fr64 = MULSDrr %133:fr64(tied-def 0), %241:fr64
SU(5):   %133:fr64 = DIVSDrm %133:fr64(tied-def 0), %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)

********** MI Scheduling **********
main:%bb.74 if.then210
  From: $rdi = MOV32ri64 @.str.36
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.36
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.37
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %151:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $xmm1 = COPY %153:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   $al = MOV8ri 2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) $al = MOV8ri 2
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $xmm1 = COPY %153:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) $xmm0 = COPY %151:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.37
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.36
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.74 ***
SU(0):   $rdi = MOV32ri64 @.str.36
SU(1):   $rsi = MOV32ri64 @.str.37
SU(2):   $xmm0 = COPY %151:fr64
SU(3):   $xmm1 = COPY %153:fr64
SU(4):   $al = MOV8ri 2

********** MI Scheduling **********
main:%bb.74 if.then210
  From: %151:fr64 = MOVSDrm_alt %stack.16.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx211)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %151:fr64 = MOVSDrm_alt %stack.16.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx211)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 12
  Successors:
    SU(1): Data Latency=4 Reg=%151
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %151:fr64 = SUBSDrm %151:fr64(tied-def 0), %stack.16.trecs, 1, $noreg, 32, $noreg :: (dereferenceable load 8 from %ir.arrayidx212, align 16)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 8
  Predecessors:
    SU(0): Data Latency=4 Reg=%151
    SU(0): Out  Latency=0
  Successors:
    SU(3): Data Latency=4 Reg=%151
    SU(2): Data Latency=4 Reg=%151
  Single Issue       : false;
SU(2):   MOVSDmr %stack.15.t2, 1, $noreg, 0, $noreg, %151:fr64 :: (store 8 into %ir.t2)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Data Latency=4 Reg=%151
  Single Issue       : false;
SU(3):   %153:fr64 = COPY %151:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(1): Data Latency=4 Reg=%151
  Successors:
    SU(4): Data Latency=0 Reg=%153
    SU(4): Out  Latency=0
  Single Issue       : false;
SU(4):   %153:fr64 = MULSDrr %153:fr64(tied-def 0), %241:fr64
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(3): Data Latency=0 Reg=%153
    SU(3): Out  Latency=0
  Successors:
    SU(5): Data Latency=1 Reg=%153
    SU(5): Out  Latency=0
  Single Issue       : false;
SU(5):   %153:fr64 = DIVSDrm %153:fr64(tied-def 0), %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 9
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1 Reg=%153
    SU(4): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 12
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 5 
  Cand SU(2) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %153:fr64 = DIVSDrm %153:fr64(tied-def 0), %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @3c
  BotQ.A TopLatency SU(5) 9c
  BotQ.A BotLatency SU(5) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 4 
  Cand SU(2) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %153:fr64 = MULSDrr %153:fr64(tied-def 0), %241:fr64
  Ready @4c
  BotQ.A BotLatency SU(4) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %153:fr64 = COPY %151:fr64
  Ready @4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOVSDmr %stack.15.t2, 1, $noreg, 0, $noreg, %151:fr64 :: (store 8 into %ir.t2)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %151:fr64 = SUBSDrm %151:fr64(tied-def 0), %stack.16.trecs, 1, $noreg, 32, $noreg :: (dereferenceable load 8 from %ir.arrayidx212, align 16)
  Ready @8c
  BotQ.A BotLatency SU(1) 8c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %151:fr64 = MOVSDrm_alt %stack.16.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx211)
  Ready @12c
  BotQ.A BotLatency SU(0) 12c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.74 ***
SU(0):   %151:fr64 = MOVSDrm_alt %stack.16.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx211)
SU(1):   %151:fr64 = SUBSDrm %151:fr64(tied-def 0), %stack.16.trecs, 1, $noreg, 32, $noreg :: (dereferenceable load 8 from %ir.arrayidx212, align 16)
SU(2):   MOVSDmr %stack.15.t2, 1, $noreg, 0, $noreg, %151:fr64 :: (store 8 into %ir.t2)
SU(3):   %153:fr64 = COPY %151:fr64
SU(4):   %153:fr64 = MULSDrr %153:fr64(tied-def 0), %241:fr64
SU(5):   %153:fr64 = DIVSDrm %153:fr64(tied-def 0), %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)

********** MI Scheduling **********
main:%bb.76 if.then220
  From: $rdi = MOV32ri64 @.str.36
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.36
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.38
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %143:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $xmm1 = COPY %145:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   $al = MOV8ri 2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) $al = MOV8ri 2
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $xmm1 = COPY %145:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) $xmm0 = COPY %143:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.38
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.36
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.76 ***
SU(0):   $rdi = MOV32ri64 @.str.36
SU(1):   $rsi = MOV32ri64 @.str.38
SU(2):   $xmm0 = COPY %143:fr64
SU(3):   $xmm1 = COPY %145:fr64
SU(4):   $al = MOV8ri 2

********** MI Scheduling **********
main:%bb.76 if.then220
  From: %143:fr64 = MOVSDrm_alt %stack.16.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx221)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 7
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %143:fr64 = MOVSDrm_alt %stack.16.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx221)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 16
  Successors:
    SU(1): Data Latency=4 Reg=%143
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %143:fr64 = SUBSDrm %143:fr64(tied-def 0), %stack.16.trecs, 1, $noreg, 48, $noreg :: (dereferenceable load 8 from %ir.arrayidx222, align 16)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 12
  Predecessors:
    SU(0): Data Latency=4 Reg=%143
    SU(0): Out  Latency=0
  Successors:
    SU(2): Data Latency=4 Reg=%143
    SU(2): Out  Latency=0
  Single Issue       : false;
SU(2):   %143:fr64 = SUBSDrm %143:fr64(tied-def 0), %stack.16.trecs, 1, $noreg, 56, $noreg :: (dereferenceable load 8 from %ir.arrayidx224)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 8
  Height             : 8
  Predecessors:
    SU(1): Data Latency=4 Reg=%143
    SU(1): Out  Latency=0
  Successors:
    SU(4): Data Latency=4 Reg=%143
    SU(3): Data Latency=4 Reg=%143
  Single Issue       : false;
SU(3):   MOVSDmr %stack.15.t2, 1, $noreg, 0, $noreg, %143:fr64 :: (store 8 into %ir.t2)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(2): Data Latency=4 Reg=%143
  Single Issue       : false;
SU(4):   %145:fr64 = COPY %143:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 12
  Height             : 4
  Predecessors:
    SU(2): Data Latency=4 Reg=%143
  Successors:
    SU(5): Data Latency=0 Reg=%145
    SU(5): Out  Latency=0
  Single Issue       : false;
SU(5):   %145:fr64 = MULSDrr %145:fr64(tied-def 0), %241:fr64
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 4
  Predecessors:
    SU(4): Data Latency=0 Reg=%145
    SU(4): Out  Latency=0
  Successors:
    SU(6): Data Latency=1 Reg=%145
    SU(6): Out  Latency=0
  Single Issue       : false;
SU(6):   %145:fr64 = DIVSDrm %145:fr64(tied-def 0), %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 13
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1 Reg=%145
    SU(5): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 16
  Height             : 0
  Predecessors:
    SU(6): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 16
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 6 
  Cand SU(3) ORDER                              
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) %145:fr64 = DIVSDrm %145:fr64(tied-def 0), %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @3c
  BotQ.A TopLatency SU(6) 13c
  BotQ.A BotLatency SU(6) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 5 
  Cand SU(3) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %145:fr64 = MULSDrr %145:fr64(tied-def 0), %241:fr64
  Ready @4c
  BotQ.A BotLatency SU(5) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 4 
  Cand SU(3) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %145:fr64 = COPY %143:fr64
  Ready @4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOVSDmr %stack.15.t2, 1, $noreg, 0, $noreg, %143:fr64 :: (store 8 into %ir.t2)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %143:fr64 = SUBSDrm %143:fr64(tied-def 0), %stack.16.trecs, 1, $noreg, 56, $noreg :: (dereferenceable load 8 from %ir.arrayidx224)
  Ready @8c
  BotQ.A BotLatency SU(2) 8c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %143:fr64 = SUBSDrm %143:fr64(tied-def 0), %stack.16.trecs, 1, $noreg, 48, $noreg :: (dereferenceable load 8 from %ir.arrayidx222, align 16)
  Ready @12c
  BotQ.A BotLatency SU(1) 12c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %143:fr64 = MOVSDrm_alt %stack.16.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx221)
  Ready @16c
  BotQ.A BotLatency SU(0) 16c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 16c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.76 ***
SU(0):   %143:fr64 = MOVSDrm_alt %stack.16.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx221)
SU(1):   %143:fr64 = SUBSDrm %143:fr64(tied-def 0), %stack.16.trecs, 1, $noreg, 48, $noreg :: (dereferenceable load 8 from %ir.arrayidx222, align 16)
SU(2):   %143:fr64 = SUBSDrm %143:fr64(tied-def 0), %stack.16.trecs, 1, $noreg, 56, $noreg :: (dereferenceable load 8 from %ir.arrayidx224)
SU(3):   MOVSDmr %stack.15.t2, 1, $noreg, 0, $noreg, %143:fr64 :: (store 8 into %ir.t2)
SU(4):   %145:fr64 = COPY %143:fr64
SU(5):   %145:fr64 = MULSDrr %145:fr64(tied-def 0), %241:fr64
SU(6):   %145:fr64 = DIVSDrm %145:fr64(tied-def 0), %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)

********** INTERVALS **********
AH [208r,240r:45)[560r,560d:43)[736r,736d:18)[752r,752d:42)[864r,896r:44)[1072r,1072d:5)[1088r,1088d:40)[1232r,1232d:4)[1248r,1280r:39)[1376r,1408r:38)[1632r,1632d:3)[1648r,1680r:37)[1776r,1808r:36)[2032r,2032d:2)[2048r,2080r:35)[2176r,2208r:34)[2432r,2432d:1)[2448r,2480r:33)[2576r,2576d:32)[2720r,2720d:0)[2736r,2736d:41)[3184r,3184d:10)[3200r,3200d:31)[3312r,3312d:9)[3328r,3328d:30)[3504r,3504d:29)[3616r,3616d:8)[3632r,3632d:28)[3760r,3760d:27)[3808r,3808d:7)[4288r,4288d:17)[4704r,4704d:16)[4768r,4768d:15)[4832r,4832d:14)[4896r,4896d:13)[4976r,4976d:12)[5040r,5040d:11)[9360r,9376r:22)[9376r,9392r:21)[9392r,9400r:20)[11408r,11408d:6)[11424r,11424d:26)[11856r,11856d:25)[12176r,12176d:23)[12560r,12560d:24)[12672r,12688r:19)  0@2720r 1@2432r 2@2032r 3@1632r 4@1232r 5@1072r 6@11408r 7@3808r 8@3616r 9@3312r 10@3184r 11@5040r 12@4976r 13@4896r 14@4832r 15@4768r 16@4704r 17@4288r 18@736r 19@12672r 20@9392r 21@9376r 22@9360r 23@12176r 24@12560r 25@11856r 26@11424r 27@3760r 28@3632r 29@3504r 30@3328r 31@3200r 32@2576r 33@2448r 34@2176r 35@2048r 36@1776r 37@1648r 38@1376r 39@1248r 40@1088r 41@2736r 42@752r 43@560r 44@864r 45@208r
AL [208r,240r:50)[560r,560d:48)[736r,752r:18)[752r,752d:47)[864r,896r:49)[1072r,1088r:5)[1088r,1088d:45)[1232r,1248r:4)[1248r,1280r:44)[1376r,1408r:43)[1632r,1648r:3)[1648r,1680r:42)[1776r,1808r:41)[2032r,2048r:2)[2048r,2080r:40)[2176r,2208r:39)[2432r,2448r:1)[2448r,2480r:38)[2576r,2576d:37)[2720r,2736r:0)[2736r,2736d:46)[3184r,3200r:10)[3200r,3200d:36)[3312r,3328r:9)[3328r,3328d:35)[3488r,3504r:20)[3504r,3504d:34)[3616r,3632r:8)[3632r,3632d:33)[3744r,3760r:19)[3760r,3760d:32)[3808r,3824r:7)[4288r,4304r:17)[4704r,4720r:16)[4768r,4784r:15)[4832r,4848r:14)[4896r,4912r:13)[4976r,4992r:12)[5040r,5056r:11)[9360r,9376r:27)[9376r,9392r:26)[9392r,9400r:25)[11408r,11424r:6)[11424r,11424d:31)[11840r,11856r:23)[11856r,11856d:30)[12160r,12176r:22)[12176r,12176d:28)[12544r,12560r:21)[12560r,12560d:29)[12672r,12688r:24)  0@2720r 1@2432r 2@2032r 3@1632r 4@1232r 5@1072r 6@11408r 7@3808r 8@3616r 9@3312r 10@3184r 11@5040r 12@4976r 13@4896r 14@4832r 15@4768r 16@4704r 17@4288r 18@736r 19@3744r 20@3488r 21@12544r 22@12160r 23@11840r 24@12672r 25@9392r 26@9376r 27@9360r 28@12176r 29@12560r 30@11856r 31@11424r 32@3760r 33@3632r 34@3504r 35@3328r 36@3200r 37@2576r 38@2448r 39@2176r 40@2048r 41@1776r 42@1648r 43@1376r 44@1248r 45@1088r 46@2736r 47@752r 48@560r 49@864r 50@208r
DIL [0B,32r:0)[176r,208r:51)[544r,560r:50)[720r,752r:49)[832r,864r:48)[1056r,1088r:46)[1224r,1248r:45)[1360r,1376r:44)[1624r,1648r:43)[1760r,1776r:42)[2024r,2048r:41)[2160r,2176r:40)[2424r,2448r:39)[2560r,2576r:38)[2704r,2736r:47)[3152r,3200r:37)[3280r,3328r:36)[3440r,3504r:35)[3584r,3632r:34)[3712r,3760r:33)[3984r,4000r:1)[4176r,4192r:15)[4400r,4448r:32)[4608r,4656r:31)[5120r,5152r:30)[5280r,5296r:14)[5376r,5392r:13)[5808r,5856r:23)[6112r,6128r:2)[6240r,6256r:9)[6336r,6352r:8)[6464r,6480r:7)[6544r,6576r:22)[6816r,6864r:16)[7776r,7808r:21)[7920r,7936r:6)[8452r,8464r:17)[8640r,8688r:20)[8752r,8768r:5)[8880r,8896r:4)[8976r,9024r:19)[9136r,9152r:3)[9632r,9664r:18)[9904r,9920r:12)[9968r,9984r:11)[10096r,10128r:29)[10480r,10800r:28)[11024r,11040r:10)[11392r,11424r:27)[11776r,11856r:26)[12096r,12176r:24)[12480r,12560r:25)  0@0B-phi 1@3984r 2@6112r 3@9136r 4@8880r 5@8752r 6@7920r 7@6464r 8@6336r 9@6240r 10@11024r 11@9968r 12@9904r 13@5376r 14@5280r 15@4176r 16@6816r 17@8452r 18@9632r 19@8976r 20@8640r 21@7776r 22@6544r 23@5808r 24@12096r 25@12480r 26@11776r 27@11392r 28@10480r 29@10096r 30@5120r 31@4608r 32@4400r 33@3712r 34@3584r 35@3440r 36@3280r 37@3152r 38@2560r 39@2424r 40@2160r 41@2024r 42@1760r 43@1624r 44@1360r 45@1224r 46@1056r 47@2704r 48@832r 49@720r 50@544r 51@176r
DIH [0B,32r:0)[176r,208r:51)[544r,560r:50)[720r,752r:49)[832r,864r:48)[1056r,1088r:46)[1224r,1248r:45)[1360r,1376r:44)[1624r,1648r:43)[1760r,1776r:42)[2024r,2048r:41)[2160r,2176r:40)[2424r,2448r:39)[2560r,2576r:38)[2704r,2736r:47)[3152r,3200r:37)[3280r,3328r:36)[3440r,3504r:35)[3584r,3632r:34)[3712r,3760r:33)[3984r,4000r:1)[4176r,4192r:15)[4400r,4448r:32)[4608r,4656r:31)[5120r,5152r:30)[5280r,5296r:14)[5376r,5392r:13)[5808r,5856r:23)[6112r,6128r:2)[6240r,6256r:9)[6336r,6352r:8)[6464r,6480r:7)[6544r,6576r:22)[6816r,6864r:16)[7776r,7808r:21)[7920r,7936r:6)[8452r,8464r:17)[8640r,8688r:20)[8752r,8768r:5)[8880r,8896r:4)[8976r,9024r:19)[9136r,9152r:3)[9632r,9664r:18)[9904r,9920r:12)[9968r,9984r:11)[10096r,10128r:29)[10480r,10800r:28)[11024r,11040r:10)[11392r,11424r:27)[11776r,11856r:26)[12096r,12176r:24)[12480r,12560r:25)  0@0B-phi 1@3984r 2@6112r 3@9136r 4@8880r 5@8752r 6@7920r 7@6464r 8@6336r 9@6240r 10@11024r 11@9968r 12@9904r 13@5376r 14@5280r 15@4176r 16@6816r 17@8452r 18@9632r 19@8976r 20@8640r 21@7776r 22@6544r 23@5808r 24@12096r 25@12480r 26@11776r 27@11392r 28@10480r 29@10096r 30@5120r 31@4608r 32@4400r 33@3712r 34@3584r 35@3440r 36@3280r 37@3152r 38@2560r 39@2424r 40@2160r 41@2024r 42@1760r 43@1624r 44@1360r 45@1224r 46@1056r 47@2704r 48@832r 49@720r 50@544r 51@176r
HAX [208r,240r:45)[560r,560d:43)[736r,736d:18)[752r,752d:42)[864r,896r:44)[1072r,1072d:5)[1088r,1088d:40)[1232r,1232d:4)[1248r,1280r:39)[1376r,1408r:38)[1632r,1632d:3)[1648r,1680r:37)[1776r,1808r:36)[2032r,2032d:2)[2048r,2080r:35)[2176r,2208r:34)[2432r,2432d:1)[2448r,2480r:33)[2576r,2576d:32)[2720r,2720d:0)[2736r,2736d:41)[3184r,3184d:10)[3200r,3200d:31)[3312r,3312d:9)[3328r,3328d:30)[3504r,3504d:29)[3616r,3616d:8)[3632r,3632d:28)[3760r,3760d:27)[3808r,3808d:7)[4288r,4288d:17)[4704r,4704d:16)[4768r,4768d:15)[4832r,4832d:14)[4896r,4896d:13)[4976r,4976d:12)[5040r,5040d:11)[9360r,9376r:22)[9376r,9392r:21)[9392r,9400r:20)[11408r,11408d:6)[11424r,11424d:26)[11856r,11856d:25)[12176r,12176d:23)[12560r,12560d:24)[12672r,12688r:19)  0@2720r 1@2432r 2@2032r 3@1632r 4@1232r 5@1072r 6@11408r 7@3808r 8@3616r 9@3312r 10@3184r 11@5040r 12@4976r 13@4896r 14@4832r 15@4768r 16@4704r 17@4288r 18@736r 19@12672r 20@9392r 21@9376r 22@9360r 23@12176r 24@12560r 25@11856r 26@11424r 27@3760r 28@3632r 29@3504r 30@3328r 31@3200r 32@2576r 33@2448r 34@2176r 35@2048r 36@1776r 37@1648r 38@1376r 39@1248r 40@1088r 41@2736r 42@752r 43@560r 44@864r 45@208r
HDI [0B,32r:0)[176r,208r:51)[544r,560r:50)[720r,752r:49)[832r,864r:48)[1056r,1088r:46)[1224r,1248r:45)[1360r,1376r:44)[1624r,1648r:43)[1760r,1776r:42)[2024r,2048r:41)[2160r,2176r:40)[2424r,2448r:39)[2560r,2576r:38)[2704r,2736r:47)[3152r,3200r:37)[3280r,3328r:36)[3440r,3504r:35)[3584r,3632r:34)[3712r,3760r:33)[3984r,4000r:1)[4176r,4192r:15)[4400r,4448r:32)[4608r,4656r:31)[5120r,5152r:30)[5280r,5296r:14)[5376r,5392r:13)[5808r,5856r:23)[6112r,6128r:2)[6240r,6256r:9)[6336r,6352r:8)[6464r,6480r:7)[6544r,6576r:22)[6816r,6864r:16)[7776r,7808r:21)[7920r,7936r:6)[8452r,8464r:17)[8640r,8688r:20)[8752r,8768r:5)[8880r,8896r:4)[8976r,9024r:19)[9136r,9152r:3)[9632r,9664r:18)[9904r,9920r:12)[9968r,9984r:11)[10096r,10128r:29)[10480r,10800r:28)[11024r,11040r:10)[11392r,11424r:27)[11776r,11856r:26)[12096r,12176r:24)[12480r,12560r:25)  0@0B-phi 1@3984r 2@6112r 3@9136r 4@8880r 5@8752r 6@7920r 7@6464r 8@6336r 9@6240r 10@11024r 11@9968r 12@9904r 13@5376r 14@5280r 15@4176r 16@6816r 17@8452r 18@9632r 19@8976r 20@8640r 21@7776r 22@6544r 23@5808r 24@12096r 25@12480r 26@11776r 27@11392r 28@10480r 29@10096r 30@5120r 31@4608r 32@4400r 33@3712r 34@3584r 35@3440r 36@3280r 37@3152r 38@2560r 39@2424r 40@2160r 41@2024r 42@1760r 43@1624r 44@1360r 45@1224r 46@1056r 47@2704r 48@832r 49@720r 50@544r 51@176r
SIL [0B,16r:0)[192r,208r:26)[848r,864r:25)[1200r,1248r:24)[1600r,1648r:23)[2000r,2048r:22)[2400r,2448r:21)[3168r,3200r:11)[3296r,3328r:10)[3456r,3504r:9)[3600r,3632r:8)[4440r,4448r:7)[4624r,4656r:6)[5136r,5152r:5)[5848r,5856r:3)[6560r,6576r:16)[6832r,6864r:12)[7792r,7808r:15)[8456r,8464r:1)[8656r,8688r:14)[8992r,9024r:13)[9648r,9664r:2)[10112r,10128r:20)[10496r,10800r:4)[11792r,11856r:19)[12112r,12176r:17)[12496r,12560r:18)  0@0B-phi 1@8456r 2@9648r 3@5848r 4@10496r 5@5136r 6@4624r 7@4440r 8@3600r 9@3456r 10@3296r 11@3168r 12@6832r 13@8992r 14@8656r 15@7792r 16@6560r 17@12112r 18@12496r 19@11792r 20@10112r 21@2400r 22@2000r 23@1600r 24@1200r 25@848r 26@192r
SIH [0B,16r:0)[192r,208r:26)[848r,864r:25)[1200r,1248r:24)[1600r,1648r:23)[2000r,2048r:22)[2400r,2448r:21)[3168r,3200r:11)[3296r,3328r:10)[3456r,3504r:9)[3600r,3632r:8)[4440r,4448r:7)[4624r,4656r:6)[5136r,5152r:5)[5848r,5856r:3)[6560r,6576r:16)[6832r,6864r:12)[7792r,7808r:15)[8456r,8464r:1)[8656r,8688r:14)[8992r,9024r:13)[9648r,9664r:2)[10112r,10128r:20)[10496r,10800r:4)[11792r,11856r:19)[12112r,12176r:17)[12496r,12560r:18)  0@0B-phi 1@8456r 2@9648r 3@5848r 4@10496r 5@5136r 6@4624r 7@4440r 8@3600r 9@3456r 10@3296r 11@3168r 12@6832r 13@8992r 14@8656r 15@7792r 16@6560r 17@12112r 18@12496r 19@11792r 20@10112r 21@2400r 22@2000r 23@1600r 24@1200r 25@848r 26@192r
HSI [0B,16r:0)[192r,208r:26)[848r,864r:25)[1200r,1248r:24)[1600r,1648r:23)[2000r,2048r:22)[2400r,2448r:21)[3168r,3200r:11)[3296r,3328r:10)[3456r,3504r:9)[3600r,3632r:8)[4440r,4448r:7)[4624r,4656r:6)[5136r,5152r:5)[5848r,5856r:3)[6560r,6576r:16)[6832r,6864r:12)[7792r,7808r:15)[8456r,8464r:1)[8656r,8688r:14)[8992r,9024r:13)[9648r,9664r:2)[10112r,10128r:20)[10496r,10800r:4)[11792r,11856r:19)[12112r,12176r:17)[12496r,12560r:18)  0@0B-phi 1@8456r 2@9648r 3@5848r 4@10496r 5@5136r 6@4624r 7@4440r 8@3600r 9@3456r 10@3296r 11@3168r 12@6832r 13@8992r 14@8656r 15@7792r 16@6560r 17@12112r 18@12496r 19@11792r 20@10112r 21@2400r 22@2000r 23@1600r 24@1200r 25@848r 26@192r
%0 [32r,64r:0)  0@32r weight:0.000000e+00
%1 [16r,80r:0)  0@16r weight:0.000000e+00
%4 [240r,272r:0)  0@240r weight:0.000000e+00
%5 [512r,544r:0)  0@512r weight:0.000000e+00
%13 [896r,928r:0)  0@896r weight:0.000000e+00
%18 [2816r,2832r:0)  0@2816r weight:0.000000e+00
%23 [1120r,1224r:0)  0@1120r weight:0.000000e+00
%26 [1280r,1296r:0)  0@1280r weight:0.000000e+00
%27 [1328r,1360r:0)  0@1328r weight:0.000000e+00
%28 [1408r,1424r:0)  0@1408r weight:0.000000e+00
%30 [1488r,1624r:0)  0@1488r weight:0.000000e+00
%35 [1680r,1696r:0)  0@1680r weight:0.000000e+00
%36 [1728r,1760r:0)  0@1728r weight:0.000000e+00
%37 [1808r,1824r:0)  0@1808r weight:0.000000e+00
%39 [1888r,2024r:0)  0@1888r weight:0.000000e+00
%44 [2080r,2096r:0)  0@2080r weight:0.000000e+00
%45 [2128r,2160r:0)  0@2128r weight:0.000000e+00
%46 [2208r,2224r:0)  0@2208r weight:0.000000e+00
%48 [2288r,2424r:0)  0@2288r weight:0.000000e+00
%53 [2480r,2496r:0)  0@2480r weight:0.000000e+00
%54 [2528r,2560r:0)  0@2528r weight:0.000000e+00
%56 [2896r,2928r:0)  0@2896r weight:0.000000e+00
%57 [2912r,2944r:0)  0@2912r weight:0.000000e+00
%59 [2992r,3040r:0)[3040r,3056r:1)  0@2992r 1@3040r weight:0.000000e+00
%65 [3232r,3296r:0)  0@3232r weight:0.000000e+00
%68 [3360r,3456r:0)  0@3360r weight:0.000000e+00
%69 [3376r,3472r:0)  0@3376r weight:0.000000e+00
%73 [3536r,3600r:0)  0@3536r weight:0.000000e+00
%76 [3664r,3728r:0)  0@3664r weight:0.000000e+00
%84 [4336r,4440r:0)  0@4336r weight:0.000000e+00
%89 [4480r,4512r:1)[4512r,4544r:0)  0@4512r 1@4480r weight:0.000000e+00
%91 [4544r,4624r:0)  0@4544r weight:0.000000e+00
%94 [5104r,5120r:0)  0@5104r weight:0.000000e+00
%97 [5632r,5648r:0)  0@5632r weight:0.000000e+00
%100 [10016r,10032r:0)  0@10016r weight:0.000000e+00
%101 [10064r,10096r:0)  0@10064r weight:0.000000e+00
%102 [10080r,10112r:0)  0@10080r weight:0.000000e+00
%104 [10160r,10192r:0)[10192r,10208r:1)  0@10160r 1@10192r weight:0.000000e+00
%107 [10256r,10576r:0)  0@10256r weight:0.000000e+00
%108 [10272r,10304r:0)[10304r,10336r:1)  0@10272r 1@10304r weight:0.000000e+00
%109 [10208r,10240r:2)[10240r,10336r:0)[10336r,10592r:1)  0@10240r 1@10336r 2@10208r weight:0.000000e+00
%110 [10368r,10496r:0)  0@10368r weight:0.000000e+00
%111 [10384r,10560r:0)  0@10384r weight:0.000000e+00
%119 [11168r,11200r:0)  0@11168r weight:0.000000e+00
%120 [11184r,11200r:0)  0@11184r weight:0.000000e+00
%121 [11280r,11296r:0)  0@11280r weight:0.000000e+00
%129 [11648r,11680r:0)  0@11648r weight:0.000000e+00
%130 [11664r,11792r:0)  0@11664r weight:0.000000e+00
%131 [11680r,11808r:0)  0@11680r weight:0.000000e+00
%133 [11696r,11712r:2)[11712r,11744r:0)[11744r,11824r:1)  0@11712r 1@11744r 2@11696r weight:0.000000e+00
%143 [12304r,12336r:2)[12336r,12368r:0)[12368r,12512r:1)  0@12336r 1@12368r 2@12304r weight:0.000000e+00
%145 [12400r,12416r:2)[12416r,12448r:0)[12448r,12528r:1)  0@12416r 1@12448r 2@12400r weight:0.000000e+00
%151 [11952r,11984r:0)[11984r,12128r:1)  0@11952r 1@11984r weight:0.000000e+00
%153 [12016r,12032r:2)[12032r,12064r:0)[12064r,12144r:1)  0@12032r 1@12064r 2@12016r weight:0.000000e+00
%158 [10992r,11024r:0)  0@10992r weight:0.000000e+00
%159 [11072r,11104r:0)  0@11072r weight:0.000000e+00
%160 [11088r,11104r:0)  0@11088r weight:0.000000e+00
%163 [5776r,5848r:0)  0@5776r weight:0.000000e+00
%169 [6304r,6336r:0)  0@6304r weight:0.000000e+00
%173 [6640r,6656r:0)  0@6640r weight:0.000000e+00
%175 [6976r,6992r:0)  0@6976r weight:0.000000e+00
%180 [8016r,8032r:0)  0@8016r weight:0.000000e+00
%182 [8608r,8672r:0)  0@8608r weight:0.000000e+00
%185 [8720r,8752r:0)  0@8720r weight:0.000000e+00
%187 [8944r,9008r:0)  0@8944r weight:0.000000e+00
%192 [9200r,9232r:0)[9232r,9248r:1)  0@9200r 1@9232r weight:0.000000e+00
%193 [9328r,9456r:0)  0@9328r weight:0.000000e+00
%194 [9344r,9440r:0)  0@9344r weight:0.000000e+00
%196 [9400r,9440r:0)[9440r,9456r:1)  0@9400r 1@9440r weight:0.000000e+00
%198 [9520r,9536r:0)  0@9520r weight:0.000000e+00
%200 [9600r,9648r:0)  0@9600r weight:0.000000e+00
%201 [5600r,9856B:0)  0@5600r weight:0.000000e+00
%203 [9760r,9792r:0)[9792r,9808r:1)  0@9760r 1@9792r weight:0.000000e+00
%206 [8192r,8208r:0)  0@8192r weight:0.000000e+00
%207 [8208r,8272r:0)  0@8208r weight:0.000000e+00
%209 [8224r,8256r:0)[8256r,8272r:1)  0@8224r 1@8256r weight:0.000000e+00
%210 [8336r,8352r:0)  0@8336r weight:0.000000e+00
%211 [8352r,8368r:0)  0@8352r weight:0.000000e+00
%212 [8368r,8452r:0)  0@8368r weight:0.000000e+00
%213 [8384r,8456r:0)  0@8384r weight:0.000000e+00
%221 [7344r,7360r:0)  0@7344r weight:0.000000e+00
%222 [7360r,7424r:0)  0@7360r weight:0.000000e+00
%223 [7376r,7392r:0)  0@7376r weight:0.000000e+00
%225 [7440r,7456r:0)  0@7440r weight:0.000000e+00
%226 [7456r,7488r:0)  0@7456r weight:0.000000e+00
%227 [7472r,7552r:0)  0@7472r weight:0.000000e+00
%228 [7392r,7424r:0)[7424r,7488r:1)  0@7392r 1@7424r weight:0.000000e+00
%229 [7488r,7552r:0)  0@7488r weight:0.000000e+00
%231 [7504r,7536r:0)[7536r,7552r:1)  0@7504r 1@7536r weight:0.000000e+00
%232 [6720r,6784r:0)  0@6720r weight:0.000000e+00
%233 [6736r,6768r:0)  0@6736r weight:0.000000e+00
%234 [6752r,6816r:0)  0@6752r weight:0.000000e+00
%235 [6768r,6832r:0)  0@6768r weight:0.000000e+00
%236 [6784r,6848r:0)  0@6784r weight:0.000000e+00
%239 [6080r,6112r:0)  0@6080r weight:0.000000e+00
%240 [3952r,3984r:0)  0@3952r weight:0.000000e+00
%241 [11472r,12640B:0)  0@11472r weight:0.000000e+00
%245 [10400r,10768r:0)  0@10400r weight:0.000000e+00
RegMasks: 208r 560r 752r 864r 1088r 1248r 1376r 1648r 1776r 2048r 2176r 2448r 2576r 2736r 2960r 3200r 3328r 3504r 3632r 3760r 3824r 4000r 4192r 4304r 4448r 4656r 4720r 4784r 4848r 4912r 4992r 5056r 5152r 5296r 5392r 5856r 6128r 6256r 6352r 6480r 6576r 6864r 7808r 7936r 8464r 8688r 8768r 8896r 9024r 9152r 9664r 9920r 9984r 10128r 10800r 11040r 11424r 11856r 12176r 12560r
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=4, align=4, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=4, align=4, at location [SP+8]
  fi#6: size=4, align=4, at location [SP+8]
  fi#7: size=4, align=4, at location [SP+8]
  fi#8: size=4, align=4, at location [SP+8]
  fi#9: size=8, align=8, at location [SP+8]
  fi#10: size=8, align=8, at location [SP+8]
  fi#11: size=8, align=8, at location [SP+8]
  fi#12: size=1, align=1, at location [SP+8]
  fi#13: size=4, align=4, at location [SP+8]
  fi#14: size=4, align=4, at location [SP+8]
  fi#15: size=8, align=8, at location [SP+8]
  fi#16: size=88, align=16, at location [SP+8]
  fi#17: size=88, align=16, at location [SP+8]
  fi#18: size=8, align=8, at location [SP+8]
  fi#19: size=4, align=4, at location [SP+8]
Constant Pool:
  cp#0: 5.000000e-01, align=8
  cp#1: 7.000000e+00, align=8
  cp#2: 4.000000e-02, align=8
  cp#3: 1.000000e+06, align=8
  cp#4: 1.000000e+02, align=8
Function Live Ins: $edi in %0, $rsi in %1

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $edi, $rsi
16B	  %1:gr64 = COPY $rsi
32B	  %0:gr32 = COPY $edi
48B	  MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
64B	  MOV32mr %stack.1.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
80B	  MOV64mr %stack.2.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
96B	  MOV64mi32 %stack.11.nelt_tot, 1, $noreg, 0, $noreg, 0 :: (store 8 into %ir.nelt_tot)
112B	  MOV32mi %stack.13.ifmortar, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.ifmortar)
128B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  $rdi = MOV32ri64 @.str
192B	  $rsi = MOV32ri64 @.str.1
208B	  CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
224B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
240B	  %4:gr64 = COPY $rax
256B	  MOV64mr %stack.18.fp, 1, $noreg, 0, $noreg, %4:gr64 :: (store 8 into %ir.fp)
272B	  TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
288B	  JCC_1 %bb.2, 4, implicit killed $eflags
304B	  JMP_1 %bb.1

320B	bb.1.if.then:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

336B	  MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
352B	  MOV64mi32 %stack.17.t_names, 1, $noreg, 8, $noreg, @.str.2 :: (store 8 into %ir.arrayidx)
368B	  MOV64mi32 %stack.17.t_names, 1, $noreg, 16, $noreg, @.str.3 :: (store 8 into %ir.arrayidx1, align 16)
384B	  MOV64mi32 %stack.17.t_names, 1, $noreg, 24, $noreg, @.str.4 :: (store 8 into %ir.arrayidx2)
400B	  MOV64mi32 %stack.17.t_names, 1, $noreg, 32, $noreg, @.str.5 :: (store 8 into %ir.arrayidx3, align 16)
416B	  MOV64mi32 %stack.17.t_names, 1, $noreg, 40, $noreg, @.str.6 :: (store 8 into %ir.arrayidx4)
432B	  MOV64mi32 %stack.17.t_names, 1, $noreg, 48, $noreg, @.str.7 :: (store 8 into %ir.arrayidx5, align 16)
448B	  MOV64mi32 %stack.17.t_names, 1, $noreg, 56, $noreg, @.str.8 :: (store 8 into %ir.arrayidx6)
464B	  MOV64mi32 %stack.17.t_names, 1, $noreg, 64, $noreg, @.str.9 :: (store 8 into %ir.arrayidx7, align 16)
480B	  MOV64mi32 %stack.17.t_names, 1, $noreg, 72, $noreg, @.str.10 :: (store 8 into %ir.arrayidx8)
496B	  MOV64mi32 %stack.17.t_names, 1, $noreg, 80, $noreg, @.str.11 :: (store 8 into %ir.arrayidx9, align 16)
512B	  %5:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
528B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
544B	  $rdi = COPY %5:gr64
560B	  CALL64pcrel32 @fclose, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
576B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
592B	  JMP_1 %bb.3

608B	bb.2.if.else:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

624B	  MOV32mi $rip, 1, $noreg, @timeron, $noreg, 0 :: (store 4 into @timeron)

640B	bb.3.if.end:
	; predecessors: %bb.2, %bb.1
	  successors: %bb.4(0x50000000), %bb.11(0x30000000); %bb.4(62.50%), %bb.11(37.50%)

656B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
720B	  $rdi = MOV32ri64 @.str.12
736B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
752B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
768B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
784B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
832B	  $rdi = MOV32ri64 @.str.13
848B	  $rsi = MOV32ri64 @.str.1
864B	  CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
880B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
896B	  %13:gr64 = COPY $rax
912B	  MOV64mr %stack.18.fp, 1, $noreg, 0, $noreg, %13:gr64 :: (store 8 into %ir.fp)
928B	  TEST64rr %13:gr64, %13:gr64, implicit-def $eflags
944B	  JCC_1 %bb.11, 4, implicit killed $eflags
960B	  JMP_1 %bb.4

976B	bb.4.if.then14:
	; predecessors: %bb.3
	  successors: %bb.5(0x80000000); %bb.5(100.00%)

992B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1056B	  $rdi = MOV32ri64 @.str.14
1072B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1088B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1104B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1120B	  %23:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
1136B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1200B	  $rsi = MOV32ri64 @.str.15
1216B	  $rdx = MOV32ri64 @fre
1224B	  $rdi = COPY %23:gr64
1232B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1248B	  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1264B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1280B	  %26:gr32 = COPY $eax
1296B	  MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %26:gr32 :: (store 4 into %ir.result)

1312B	bb.5.while.cond:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

1328B	  %27:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
1344B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1360B	  $rdi = COPY %27:gr64
1376B	  CALL64pcrel32 @fgetc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1392B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1408B	  %28:gr32 = COPY $eax
1424B	  CMP32ri8 %28:gr32, 10, implicit-def $eflags
1440B	  JCC_1 %bb.5, 5, implicit killed $eflags
1456B	  JMP_1 %bb.6

1472B	bb.6.while.end:
	; predecessors: %bb.5
	  successors: %bb.7(0x80000000); %bb.7(100.00%)

1488B	  %30:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
1504B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1600B	  $rsi = MOV32ri64 @.str.15
1616B	  $rdx = MOV32ri64 @niter
1624B	  $rdi = COPY %30:gr64
1632B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1648B	  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1664B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1680B	  %35:gr32 = COPY $eax
1696B	  MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %35:gr32 :: (store 4 into %ir.result)

1712B	bb.7.while.cond20:
	; predecessors: %bb.6, %bb.7
	  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)

1728B	  %36:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
1744B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1760B	  $rdi = COPY %36:gr64
1776B	  CALL64pcrel32 @fgetc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1792B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1808B	  %37:gr32 = COPY $eax
1824B	  CMP32ri8 %37:gr32, 10, implicit-def $eflags
1840B	  JCC_1 %bb.7, 5, implicit killed $eflags
1856B	  JMP_1 %bb.8

1872B	bb.8.while.end24:
	; predecessors: %bb.7
	  successors: %bb.9(0x80000000); %bb.9(100.00%)

1888B	  %39:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
1904B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2000B	  $rsi = MOV32ri64 @.str.15
2016B	  $rdx = MOV32ri64 @nmxh
2024B	  $rdi = COPY %39:gr64
2032B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
2048B	  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
2064B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2080B	  %44:gr32 = COPY $eax
2096B	  MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %44:gr32 :: (store 4 into %ir.result)

2112B	bb.9.while.cond26:
	; predecessors: %bb.8, %bb.9
	  successors: %bb.9(0x7c000000), %bb.10(0x04000000); %bb.9(96.88%), %bb.10(3.12%)

2128B	  %45:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
2144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2160B	  $rdi = COPY %45:gr64
2176B	  CALL64pcrel32 @fgetc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
2192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2208B	  %46:gr32 = COPY $eax
2224B	  CMP32ri8 %46:gr32, 10, implicit-def $eflags
2240B	  JCC_1 %bb.9, 5, implicit killed $eflags
2256B	  JMP_1 %bb.10

2272B	bb.10.while.end30:
	; predecessors: %bb.9
	  successors: %bb.12(0x80000000); %bb.12(100.00%)

2288B	  %48:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
2304B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2400B	  $rsi = MOV32ri64 @.str.16
2416B	  $rdx = MOV32ri64 @alpha
2424B	  $rdi = COPY %48:gr64
2432B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
2448B	  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
2464B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2480B	  %53:gr32 = COPY $eax
2496B	  MOV32mr %stack.19.result, 1, $noreg, 0, $noreg, %53:gr32 :: (store 4 into %ir.result)
2512B	  MOV8mi %stack.12.Class, 1, $noreg, 0, $noreg, 85 :: (store 1 into %ir.Class)
2528B	  %54:gr64 = MOV64rm %stack.18.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
2544B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2560B	  $rdi = COPY %54:gr64
2576B	  CALL64pcrel32 @fclose, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
2592B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2608B	  JMP_1 %bb.12

2624B	bb.11.if.else33:
	; predecessors: %bb.3
	  successors: %bb.12(0x80000000); %bb.12(100.00%)

2640B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2704B	  $rdi = MOV32ri64 @.str.17
2720B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
2736B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
2752B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2768B	  MOV32mi $rip, 1, $noreg, @fre, $noreg, 5 :: (store 4 into @fre)
2784B	  MOV32mi $rip, 1, $noreg, @niter, $noreg, 200 :: (store 4 into @niter)
2800B	  MOV32mi $rip, 1, $noreg, @nmxh, $noreg, 10 :: (store 4 into @nmxh)
2816B	  %18:gr64 = MOV64ri 4590140797810047451
2832B	  MOV64mr $rip, 1, $noreg, @alpha, $noreg, %18:gr64 :: (store 8 into @alpha)
2848B	  MOV8mi %stack.12.Class, 1, $noreg, 0, $noreg, 66 :: (store 1 into %ir.Class)

2864B	bb.12.if.end35:
	; predecessors: %bb.11, %bb.10
	  successors: %bb.13(0x80000000); %bb.13(100.00%)

2880B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2896B	  %56:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
2912B	  %57:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
2928B	  $xmm0 = COPY %56:fr64
2944B	  $xmm1 = COPY %57:fr64
2960B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
2976B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2992B	  %59:fr64 = COPY killed $xmm0
3008B	  MOVSDmr $rip, 1, $noreg, @dlmin, $noreg, %59:fr64 :: (store 8 into @dlmin)
3040B	  %59:fr64 = MULSDrm %59:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
3056B	  MOVSDmr $rip, 1, $noreg, @dtime, $noreg, %59:fr64 :: (store 8 into @dtime)
3072B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3152B	  $rdi = MOV32ri64 @.str.18
3168B	  $esi = MOV32ri 7
3184B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
3200B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
3216B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3232B	  %65:gr32 = MOV32rm $rip, 1, $noreg, @fre, $noreg :: (dereferenceable load 4 from @fre)
3248B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3280B	  $rdi = MOV32ri64 @.str.19
3296B	  $esi = COPY %65:gr32
3312B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
3328B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
3344B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3360B	  %68:gr32 = MOV32rm $rip, 1, $noreg, @niter, $noreg :: (dereferenceable load 4 from @niter)
3376B	  %69:fr64 = MOVSDrm_alt $rip, 1, $noreg, @dtime, $noreg :: (dereferenceable load 8 from @dtime)
3392B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3440B	  $rdi = MOV32ri64 @.str.20
3456B	  $esi = COPY %68:gr32
3472B	  $xmm0 = COPY %69:fr64
3488B	  $al = MOV8ri 1
3504B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
3520B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3536B	  %73:gr32 = MOV32rm $rip, 1, $noreg, @nmxh, $noreg :: (dereferenceable load 4 from @nmxh)
3552B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3584B	  $rdi = MOV32ri64 @.str.21
3600B	  $esi = COPY %73:gr32
3616B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
3632B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
3648B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3664B	  %76:fr64 = MOVSDrm_alt $rip, 1, $noreg, @alpha, $noreg :: (dereferenceable load 8 from @alpha)
3680B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3712B	  $rdi = MOV32ri64 @.str.22
3728B	  $xmm0 = COPY %76:fr64
3744B	  $al = MOV8ri 1
3760B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
3776B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3792B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3808B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
3824B	  CALL64pcrel32 @top_constants, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $al, implicit-def $rsp, implicit-def $ssp
3840B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3856B	  MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

3872B	bb.13.for.cond:
	; predecessors: %bb.12, %bb.14
	  successors: %bb.14(0x7c000000), %bb.15(0x04000000); %bb.14(96.88%), %bb.15(3.12%)

3888B	  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 10, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
3904B	  JCC_1 %bb.15, 15, implicit killed $eflags
3920B	  JMP_1 %bb.14

3936B	bb.14.for.body:
	; predecessors: %bb.13
	  successors: %bb.13(0x80000000); %bb.13(100.00%)

3952B	  %240:gr32 = MOV32rm %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
3968B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3984B	  $edi = COPY %240:gr32
4000B	  CALL64pcrel32 @timer_clear, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
4016B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4032B	  INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
4048B	  JMP_1 %bb.13

4064B	bb.15.for.end:
	; predecessors: %bb.13
	  successors: %bb.16(0x50000000), %bb.17(0x30000000); %bb.16(62.50%), %bb.17(37.50%)

4080B	  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
4096B	  JCC_1 %bb.17, 4, implicit killed $eflags
4112B	  JMP_1 %bb.16

4128B	bb.16.if.then43:
	; predecessors: %bb.15
	  successors: %bb.17(0x80000000); %bb.17(100.00%)

4144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4176B	  $edi = MOV32ri 2
4192B	  CALL64pcrel32 @timer_start, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
4208B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

4224B	bb.17.if.end44:
	; predecessors: %bb.15, %bb.16
	  successors: %bb.18(0x50000000), %bb.19(0x30000000); %bb.18(62.50%), %bb.19(37.50%)

4240B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4288B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
4304B	  CALL64pcrel32 @create_initial_grid, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $al, implicit-def $rsp, implicit-def $ssp
4320B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4336B	  %84:gr32 = MOV32rm $rip, 1, $noreg, @ntot, $noreg :: (dereferenceable load 4 from @ntot)
4352B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4400B	  $rdi = MOV32ri64 @ta1
4432B	  $xmm0 = FsFLD0SD
4440B	  $esi = COPY %84:gr32
4448B	  CALL64pcrel32 @r_init, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp
4464B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4480B	  undef %89.sub_32bit:gr64_nosp = MOV32rm $rip, 1, $noreg, @nelt, $noreg :: (dereferenceable load 4 from @nelt)
4512B	  %89.sub_32bit:gr64_nosp = SHL32ri %89.sub_32bit:gr64_nosp(tied-def 0), 3, implicit-def dead $eflags
4544B	  %91:gr32 = LEA64_32r %89:gr64_nosp, 2, %89:gr64_nosp, 0, $noreg
4560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4608B	  $rdi = MOV32ri64 @sje
4624B	  $esi = COPY %91:gr32
4640B	  $edx = MOV32ri -1
4656B	  CALL64pcrel32 @nr_init, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
4672B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4688B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4704B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
4720B	  CALL64pcrel32 @coef, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $al, implicit-def $rsp, implicit-def $ssp
4736B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4752B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4768B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
4784B	  CALL64pcrel32 @geom1, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $al, implicit-def $rsp, implicit-def $ssp
4800B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4816B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4832B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
4848B	  CALL64pcrel32 @setdef, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $al, implicit-def $rsp, implicit-def $ssp
4864B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4880B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4896B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
4912B	  CALL64pcrel32 @setpcmo_pre, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $al, implicit-def $rsp, implicit-def $ssp
4928B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4944B	  MOV64mi32 $rip, 1, $noreg, @time, $noreg, 0 :: (store 8 into @time)
4960B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4976B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
4992B	  CALL64pcrel32 @mortar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $al, implicit-def $rsp, implicit-def $ssp
5008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5024B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5040B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
5056B	  CALL64pcrel32 @prepwork, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $al, implicit-def $rsp, implicit-def $ssp
5072B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5088B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5104B	  %94:gr64 = LEA64r %stack.13.ifmortar, 1, $noreg, 0, $noreg
5120B	  $rdi = COPY %94:gr64
5136B	  $esi = MOV32r0 implicit-def dead $eflags
5152B	  CALL64pcrel32 @adaptation, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp
5168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5184B	  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
5200B	  JCC_1 %bb.19, 4, implicit killed $eflags
5216B	  JMP_1 %bb.18

5232B	bb.18.if.then47:
	; predecessors: %bb.17
	  successors: %bb.19(0x80000000); %bb.19(100.00%)

5248B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5280B	  $edi = MOV32ri 2
5296B	  CALL64pcrel32 @timer_stop, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
5312B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

5328B	bb.19.if.end48:
	; predecessors: %bb.17, %bb.18
	  successors: %bb.20(0x80000000); %bb.20(100.00%)

5344B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5376B	  $edi = MOV32ri 1
5392B	  CALL64pcrel32 @timer_clear, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
5408B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5424B	  MOV64mi32 $rip, 1, $noreg, @time, $noreg, 0 :: (store 8 into @time)
5440B	  MOV32mi %stack.3.step, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.step)
5600B	  %201:gr64 = LEA64r %stack.13.ifmortar, 1, $noreg, 0, $noreg

5616B	bb.20.for.cond49:
	; predecessors: %bb.19, %bb.64
	  successors: %bb.21(0x7c000000), %bb.65(0x04000000); %bb.21(96.88%), %bb.65(3.12%)

5632B	  %97:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
5648B	  CMP32rm %97:gr32, $rip, 1, $noreg, @niter, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @niter)
5664B	  JCC_1 %bb.65, 15, implicit killed $eflags
5680B	  JMP_1 %bb.21

5696B	bb.21.for.body51:
	; predecessors: %bb.20
	  successors: %bb.22(0x40000000), %bb.28(0x40000000); %bb.22(50.00%), %bb.28(50.00%)

5712B	  CMP32mi8 %stack.3.step, 1, $noreg, 0, $noreg, 1, implicit-def $eflags :: (dereferenceable load 4 from %ir.step)
5728B	  JCC_1 %bb.28, 5, implicit killed $eflags
5744B	  JMP_1 %bb.22

5760B	bb.22.if.then53:
	; predecessors: %bb.21
	  successors: %bb.23(0x80000000); %bb.23(100.00%)

5776B	  %163:gr32 = MOV32rm $rip, 1, $noreg, @ntot, $noreg :: (dereferenceable load 4 from @ntot)
5792B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5808B	  $rdi = MOV32ri64 @ta1
5840B	  $xmm0 = FsFLD0SD
5848B	  $esi = COPY %163:gr32
5856B	  CALL64pcrel32 @r_init, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp
5872B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5888B	  MOV64mi32 $rip, 1, $noreg, @time, $noreg, 0 :: (store 8 into @time)
5904B	  MOV64mi32 %stack.11.nelt_tot, 1, $noreg, 0, $noreg, 0 :: (store 8 into %ir.nelt_tot)
5920B	  MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

5936B	bb.23.for.cond54:
	; predecessors: %bb.22, %bb.26
	  successors: %bb.24(0x7c000000), %bb.27(0x04000000); %bb.24(96.88%), %bb.27(3.12%)

5952B	  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 10, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
5968B	  JCC_1 %bb.27, 15, implicit killed $eflags
5984B	  JMP_1 %bb.24

6000B	bb.24.for.body56:
	; predecessors: %bb.23
	  successors: %bb.25(0x40000000), %bb.26(0x40000000); %bb.25(50.00%), %bb.26(50.00%)

6016B	  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 2, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
6032B	  JCC_1 %bb.26, 4, implicit killed $eflags
6048B	  JMP_1 %bb.25

6064B	bb.25.if.then58:
	; predecessors: %bb.24
	  successors: %bb.26(0x80000000); %bb.26(100.00%)

6080B	  %239:gr32 = MOV32rm %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
6096B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6112B	  $edi = COPY %239:gr32
6128B	  CALL64pcrel32 @timer_clear, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
6144B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

6160B	bb.26.if.end59:
	; predecessors: %bb.24, %bb.25
	  successors: %bb.23(0x80000000); %bb.23(100.00%)

6176B	  INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
6192B	  JMP_1 %bb.23

6208B	bb.27.for.end62:
	; predecessors: %bb.23
	  successors: %bb.28(0x80000000); %bb.28(100.00%)

6224B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6240B	  $edi = MOV32ri 1
6256B	  CALL64pcrel32 @timer_start, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
6272B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

6288B	bb.28.if.end63:
	; predecessors: %bb.21, %bb.27
	  successors: %bb.29(0x50000000), %bb.30(0x30000000); %bb.29(62.50%), %bb.30(37.50%)

6304B	  %169:gr32 = MOV32rm %stack.13.ifmortar, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ifmortar)
6320B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6336B	  $edi = COPY %169:gr32
6352B	  CALL64pcrel32 @convect, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
6368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6384B	  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
6400B	  JCC_1 %bb.30, 4, implicit killed $eflags
6416B	  JMP_1 %bb.29

6432B	bb.29.if.then65:
	; predecessors: %bb.28
	  successors: %bb.30(0x80000000); %bb.30(100.00%)

6448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6464B	  $edi = MOV32ri 9
6480B	  CALL64pcrel32 @timer_start, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
6496B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

6512B	bb.30.if.end66:
	; predecessors: %bb.28, %bb.29
	  successors: %bb.31(0x80000000); %bb.31(100.00%)

6528B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6544B	  $rdi = MOV32ri64 @tmort
6560B	  $rsi = MOV32ri64 @ta1
6576B	  CALL64pcrel32 @transf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
6592B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6608B	  MOV32mi %stack.4.ie, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.ie)

6624B	bb.31.for.cond67:
	; predecessors: %bb.30, %bb.32
	  successors: %bb.32(0x7c000000), %bb.33(0x04000000); %bb.32(96.88%), %bb.33(3.12%)

6640B	  %173:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
6656B	  CMP32rm %173:gr32, $rip, 1, $noreg, @nelt, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @nelt)
6672B	  JCC_1 %bb.33, 13, implicit killed $eflags
6688B	  JMP_1 %bb.32

6704B	bb.32.for.body69:
	; predecessors: %bb.31
	  successors: %bb.31(0x80000000); %bb.31(100.00%)

6720B	  %232:gr64_nosp = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
6736B	  %233:gr64 = IMUL64rri32 %232:gr64_nosp, 1000, implicit-def dead $eflags
6752B	  %234:gr64 = LEA64r %233:gr64, 1, $noreg, @ta2, $noreg
6768B	  %235:gr64 = LEA64r %233:gr64, 1, $noreg, @ta1, $noreg
6784B	  %236:gr32 = MOV32rm $noreg, 4, %232:gr64_nosp, @size_e, $noreg :: (load 4 from %ir.arrayidx75)
6800B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6816B	  $rdi = COPY %234:gr64
6832B	  $rsi = COPY %235:gr64
6848B	  $edx = COPY %236:gr32
6864B	  CALL64pcrel32 @laplacian, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
6880B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6896B	  INC32m %stack.4.ie, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.ie), (dereferenceable load 4 from %ir.ie)
6912B	  JMP_1 %bb.31

6928B	bb.33.for.end78:
	; predecessors: %bb.31
	  successors: %bb.34(0x80000000); %bb.34(100.00%)

6944B	  MOV32mi %stack.4.ie, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.ie)

6960B	bb.34.for.cond79:
	; predecessors: %bb.33, %bb.44
	  successors: %bb.35(0x7c000000), %bb.45(0x04000000); %bb.35(96.88%), %bb.45(3.12%)

6976B	  %175:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
6992B	  CMP32rm %175:gr32, $rip, 1, $noreg, @nelt, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @nelt)
7008B	  JCC_1 %bb.45, 13, implicit killed $eflags
7024B	  JMP_1 %bb.35

7040B	bb.35.for.body81:
	; predecessors: %bb.34
	  successors: %bb.36(0x80000000); %bb.36(100.00%)

7056B	  MOV32mi %stack.8.k, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.k)

7072B	bb.36.for.cond82:
	; predecessors: %bb.35, %bb.43
	  successors: %bb.37(0x7c000000), %bb.44(0x04000000); %bb.37(96.88%), %bb.44(3.12%)

7088B	  CMP32mi8 %stack.8.k, 1, $noreg, 0, $noreg, 4, implicit-def $eflags :: (dereferenceable load 4 from %ir.k)
7104B	  JCC_1 %bb.44, 15, implicit killed $eflags
7120B	  JMP_1 %bb.37

7136B	bb.37.for.body84:
	; predecessors: %bb.36
	  successors: %bb.38(0x80000000); %bb.38(100.00%)

7152B	  MOV32mi %stack.7.j, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.j)

7168B	bb.38.for.cond85:
	; predecessors: %bb.37, %bb.42
	  successors: %bb.39(0x7c000000), %bb.43(0x04000000); %bb.39(96.88%), %bb.43(3.12%)

7184B	  CMP32mi8 %stack.7.j, 1, $noreg, 0, $noreg, 4, implicit-def $eflags :: (dereferenceable load 4 from %ir.j)
7200B	  JCC_1 %bb.43, 15, implicit killed $eflags
7216B	  JMP_1 %bb.39

7232B	bb.39.for.body87:
	; predecessors: %bb.38
	  successors: %bb.40(0x80000000); %bb.40(100.00%)

7248B	  MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

7264B	bb.40.for.cond88:
	; predecessors: %bb.39, %bb.41
	  successors: %bb.41(0x7c000000), %bb.42(0x04000000); %bb.41(96.88%), %bb.42(3.12%)

7280B	  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 4, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
7296B	  JCC_1 %bb.42, 15, implicit killed $eflags
7312B	  JMP_1 %bb.41

7328B	bb.41.for.body90:
	; predecessors: %bb.40
	  successors: %bb.40(0x80000000); %bb.40(100.00%)

7344B	  %221:gr64 = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
7360B	  %222:gr64 = IMUL64rri32 %221:gr64, 1000, implicit-def dead $eflags
7376B	  %223:gr64 = MOVSX64rm32 %stack.8.k, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.k)
7392B	  %228:gr64 = IMUL64rri32 %223:gr64, 200, implicit-def dead $eflags
7424B	  %228:gr64 = ADD64rr %228:gr64(tied-def 0), %222:gr64, implicit-def dead $eflags
7440B	  %225:gr64_nosp = MOVSX64rm32 %stack.7.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
7456B	  %226:gr64_nosp = LEA64r %225:gr64_nosp, 4, %225:gr64_nosp, 0, $noreg
7472B	  %227:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
7488B	  %229:gr64 = LEA64r %228:gr64, 8, %226:gr64_nosp, 0, $noreg
7504B	  %231:fr64 = MOVSDrm_alt %229:gr64, 8, %227:gr64_nosp, @trhs, $noreg :: (load 8 from %ir.arrayidx98)
7536B	  %231:fr64 = SUBSDrm %231:fr64(tied-def 0), %229:gr64, 8, %227:gr64_nosp, @ta2, $noreg :: (load 8 from %ir.arrayidx106)
7552B	  MOVSDmr %229:gr64, 8, %227:gr64_nosp, @trhs, $noreg, %231:fr64 :: (store 8 into %ir.arrayidx114)
7568B	  INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
7584B	  JMP_1 %bb.40

7600B	bb.42.for.end117:
	; predecessors: %bb.40
	  successors: %bb.38(0x80000000); %bb.38(100.00%)

7616B	  INC32m %stack.7.j, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.j), (dereferenceable load 4 from %ir.j)
7632B	  JMP_1 %bb.38

7648B	bb.43.for.end120:
	; predecessors: %bb.38
	  successors: %bb.36(0x80000000); %bb.36(100.00%)

7664B	  INC32m %stack.8.k, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.k), (dereferenceable load 4 from %ir.k)
7680B	  JMP_1 %bb.36

7696B	bb.44.for.end123:
	; predecessors: %bb.36
	  successors: %bb.34(0x80000000); %bb.34(100.00%)

7712B	  INC32m %stack.4.ie, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.ie), (dereferenceable load 4 from %ir.ie)
7728B	  JMP_1 %bb.34

7744B	bb.45.for.end126:
	; predecessors: %bb.34
	  successors: %bb.46(0x50000000), %bb.47(0x30000000); %bb.46(62.50%), %bb.47(37.50%)

7760B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
7776B	  $rdi = MOV32ri64 @rmor
7792B	  $rsi = MOV32ri64 @trhs
7808B	  CALL64pcrel32 @transfb, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
7824B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
7840B	  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
7856B	  JCC_1 %bb.47, 4, implicit killed $eflags
7872B	  JMP_1 %bb.46

7888B	bb.46.if.then128:
	; predecessors: %bb.45
	  successors: %bb.47(0x80000000); %bb.47(100.00%)

7904B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
7920B	  $edi = MOV32ri 9
7936B	  CALL64pcrel32 @timer_stop, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
7952B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

7968B	bb.47.if.end129:
	; predecessors: %bb.45, %bb.46
	  successors: %bb.48(0x80000000); %bb.48(100.00%)

7984B	  MOV32mi %stack.4.ie, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.ie)

8000B	bb.48.for.cond130:
	; predecessors: %bb.47, %bb.54
	  successors: %bb.49(0x7c000000), %bb.55(0x04000000); %bb.49(96.88%), %bb.55(3.12%)

8016B	  %180:gr32 = MOV32rm %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
8032B	  CMP32rm %180:gr32, $rip, 1, $noreg, @nelt, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @nelt)
8048B	  JCC_1 %bb.55, 13, implicit killed $eflags
8064B	  JMP_1 %bb.49

8080B	bb.49.for.body132:
	; predecessors: %bb.48
	  successors: %bb.50(0x80000000); %bb.50(100.00%)

8096B	  MOV32mi %stack.5.iside, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.iside)

8112B	bb.50.for.cond133:
	; predecessors: %bb.49, %bb.53
	  successors: %bb.51(0x7c000000), %bb.54(0x04000000); %bb.51(96.88%), %bb.54(3.12%)

8128B	  CMP32mi8 %stack.5.iside, 1, $noreg, 0, $noreg, 5, implicit-def $eflags :: (dereferenceable load 4 from %ir.iside)
8144B	  JCC_1 %bb.54, 15, implicit killed $eflags
8160B	  JMP_1 %bb.51

8176B	bb.51.for.body135:
	; predecessors: %bb.50
	  successors: %bb.52(0x30000000), %bb.53(0x50000000); %bb.52(37.50%), %bb.53(62.50%)

8192B	  %206:gr64_nosp = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
8208B	  %207:gr64_nosp = LEA64r %206:gr64_nosp, 2, %206:gr64_nosp, 0, $noreg
8224B	  %209:gr64 = MOVSX64rm32 %stack.5.iside, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.iside)
8256B	  %209:gr64 = SHL64ri %209:gr64(tied-def 0), 2, implicit-def dead $eflags
8272B	  CMP32mi8 %209:gr64, 8, %207:gr64_nosp, @cbc, $noreg, 0, implicit-def $eflags :: (load 4 from %ir.arrayidx139)
8288B	  JCC_1 %bb.53, 5, implicit killed $eflags
8304B	  JMP_1 %bb.52

8320B	bb.52.if.then141:
	; predecessors: %bb.51
	  successors: %bb.53(0x80000000); %bb.53(100.00%)

8336B	  %210:gr64 = MOVSX64rm32 %stack.4.ie, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ie)
8352B	  %211:gr64 = IMUL64rri32 %210:gr64, 1000, implicit-def dead $eflags
8368B	  %212:gr64 = LEA64r %211:gr64, 1, $noreg, @trhs, $noreg
8384B	  %213:gr32 = MOV32rm %stack.5.iside, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.iside)
8400B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8448B	  $xmm0 = FsFLD0SD
8452B	  $rdi = COPY %212:gr64
8456B	  $esi = COPY %213:gr32
8464B	  CALL64pcrel32 @facev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp
8480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

8496B	bb.53.if.end145:
	; predecessors: %bb.51, %bb.52
	  successors: %bb.50(0x80000000); %bb.50(100.00%)

8512B	  INC32m %stack.5.iside, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.iside), (dereferenceable load 4 from %ir.iside)
8528B	  JMP_1 %bb.50

8544B	bb.54.for.end148:
	; predecessors: %bb.50
	  successors: %bb.48(0x80000000); %bb.48(100.00%)

8560B	  INC32m %stack.4.ie, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.ie), (dereferenceable load 4 from %ir.ie)
8576B	  JMP_1 %bb.48

8592B	bb.55.for.end151:
	; predecessors: %bb.48
	  successors: %bb.56(0x50000000), %bb.57(0x30000000); %bb.56(62.50%), %bb.57(37.50%)

8608B	  %182:gr32 = MOV32rm $rip, 1, $noreg, @nmor, $noreg :: (dereferenceable load 4 from @nmor)
8624B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8640B	  $rdi = MOV32ri64 @rmor
8656B	  $rsi = MOV32ri64 @tmmor
8672B	  $edx = COPY %182:gr32
8688B	  CALL64pcrel32 @col2, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
8704B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8720B	  %185:gr32 = MOV32rm %stack.13.ifmortar, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.ifmortar)
8736B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8752B	  $edi = COPY %185:gr32
8768B	  CALL64pcrel32 @diffusion, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
8784B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8800B	  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
8816B	  JCC_1 %bb.57, 4, implicit killed $eflags
8832B	  JMP_1 %bb.56

8848B	bb.56.if.then153:
	; predecessors: %bb.55
	  successors: %bb.57(0x80000000); %bb.57(100.00%)

8864B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8880B	  $edi = MOV32ri 10
8896B	  CALL64pcrel32 @timer_start, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
8912B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

8928B	bb.57.if.end154:
	; predecessors: %bb.55, %bb.56
	  successors: %bb.58(0x50000000), %bb.59(0x30000000); %bb.58(62.50%), %bb.59(37.50%)

8944B	  %187:gr32 = MOV32rm $rip, 1, $noreg, @ntot, $noreg :: (dereferenceable load 4 from @ntot)
8960B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8976B	  $rdi = MOV32ri64 @ta1
8992B	  $rsi = MOV32ri64 @t
9008B	  $edx = COPY %187:gr32
9024B	  CALL64pcrel32 @add2, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $edx, implicit-def $rsp, implicit-def $ssp
9040B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
9056B	  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
9072B	  JCC_1 %bb.59, 4, implicit killed $eflags
9088B	  JMP_1 %bb.58

9104B	bb.58.if.then156:
	; predecessors: %bb.57
	  successors: %bb.59(0x80000000); %bb.59(100.00%)

9120B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
9136B	  $edi = MOV32ri 10
9152B	  CALL64pcrel32 @timer_stop, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
9168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

9184B	bb.59.if.end157:
	; predecessors: %bb.57, %bb.58
	  successors: %bb.60(0x50000000), %bb.63(0x30000000); %bb.60(62.50%), %bb.63(37.50%)

9200B	  %192:fr64 = MOVSDrm_alt $rip, 1, $noreg, @time, $noreg :: (dereferenceable load 8 from @time)
9232B	  %192:fr64 = ADDSDrm %192:fr64(tied-def 0), $rip, 1, $noreg, @dtime, $noreg :: (dereferenceable load 8 from @dtime)
9248B	  MOVSDmr $rip, 1, $noreg, @time, $noreg, %192:fr64 :: (store 8 into @time)
9264B	  CMP32mi8 %stack.3.step, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.step)
9280B	  JCC_1 %bb.63, 4, implicit killed $eflags
9296B	  JMP_1 %bb.60

9312B	bb.60.land.lhs.true:
	; predecessors: %bb.59
	  successors: %bb.61(0x40000000), %bb.63(0x40000000); %bb.61(50.00%), %bb.63(50.00%)

9328B	  %193:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
9344B	  %194:gr32 = MOV32rm $rip, 1, $noreg, @fre, $noreg :: (dereferenceable load 4 from @fre)
9360B	  $eax = COPY %193:gr32
9376B	  CDQ implicit-def $eax, implicit-def $edx, implicit $eax
9392B	  IDIV32r %194:gr32, implicit-def $eax, implicit-def dead $edx, implicit-def dead $eflags, implicit $eax, implicit killed $edx
9400B	  %196:gr32 = COPY $eax
9440B	  %196:gr32 = nsw IMUL32rr %196:gr32(tied-def 0), %194:gr32, implicit-def dead $eflags
9456B	  CMP32rr %196:gr32, %193:gr32, implicit-def $eflags
9472B	  JCC_1 %bb.63, 5, implicit killed $eflags
9488B	  JMP_1 %bb.61

9504B	bb.61.if.then161:
	; predecessors: %bb.60
	  successors: %bb.62(0x40000000), %bb.64(0x40000000); %bb.62(50.00%), %bb.64(50.00%)

9520B	  %198:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
9536B	  CMP32rm %198:gr32, $rip, 1, $noreg, @niter, $noreg, implicit-def $eflags :: (dereferenceable load 4 from @niter)
9552B	  JCC_1 %bb.64, 4, implicit killed $eflags
9568B	  JMP_1 %bb.62

9584B	bb.62.if.then163:
	; predecessors: %bb.61
	  successors: %bb.64(0x80000000); %bb.64(100.00%)

9600B	  %200:gr32 = MOV32rm %stack.3.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
9616B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
9632B	  $rdi = COPY %201:gr64
9648B	  $esi = COPY %200:gr32
9664B	  CALL64pcrel32 @adaptation, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp
9680B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
9696B	  JMP_1 %bb.64

9712B	bb.63.if.else165:
	; predecessors: %bb.59, %bb.60
	  successors: %bb.64(0x80000000); %bb.64(100.00%)

9728B	  MOV32mi %stack.13.ifmortar, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.ifmortar)

9744B	bb.64.if.end166:
	; predecessors: %bb.63, %bb.61, %bb.62
	  successors: %bb.20(0x80000000); %bb.20(100.00%)

9760B	  %203:fr64 = CVTSI2SDrm $rip, 1, $noreg, @nelt, $noreg :: (dereferenceable load 4 from @nelt)
9792B	  %203:fr64 = ADDSDrm %203:fr64(tied-def 0), %stack.11.nelt_tot, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.nelt_tot)
9808B	  MOVSDmr %stack.11.nelt_tot, 1, $noreg, 0, $noreg, %203:fr64 :: (store 8 into %ir.nelt_tot)
9824B	  INC32m %stack.3.step, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.step), (dereferenceable load 4 from %ir.step)
9840B	  JMP_1 %bb.20

9856B	bb.65.for.end170:
	; predecessors: %bb.20
	  successors: %bb.66(0x50000000), %bb.78(0x30000000); %bb.66(62.50%), %bb.78(37.50%)

9872B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
9904B	  $edi = MOV32ri 1
9920B	  CALL64pcrel32 @timer_stop, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
9936B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
9952B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
9968B	  $edi = MOV32ri 1
9984B	  CALL64pcrel32 @timer_read, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
10000B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
10016B	  %100:fr64 = COPY killed $xmm0
10032B	  MOVSDmr %stack.10.tmax, 1, $noreg, 0, $noreg, %100:fr64 :: (store 8 into %ir.tmax)
10048B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
10064B	  %101:gr64 = LEA64r %stack.12.Class, 1, $noreg, 0, $noreg
10080B	  %102:gr64 = LEA64r %stack.14.verified, 1, $noreg, 0, $noreg
10096B	  $rdi = COPY %101:gr64
10112B	  $rsi = COPY %102:gr64
10128B	  CALL64pcrel32 @verify, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
10144B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
10160B	  %104:gr32 = IMUL32rmi8 $rip, 1, $noreg, @nmxh, $noreg, 125, implicit-def dead $eflags :: (dereferenceable load 4 from @nmxh)
10192B	  %104:gr32 = ADD32ri8 %104:gr32(tied-def 0), 125, implicit-def dead $eflags
10208B	  %109:fr64 = CVTSI2SDrr %104:gr32
10240B	  %109:fr64 = MULSDrm %109:fr64(tied-def 0), %stack.11.nelt_tot, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.nelt_tot)
10256B	  %107:fr64 = MOVSDrm_alt %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
10272B	  %108:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
10304B	  %108:fr64 = MULSDrr %108:fr64(tied-def 0), %107:fr64
10336B	  %109:fr64 = DIVSDrr %109:fr64(tied-def 0), %108:fr64
10352B	  MOVSDmr %stack.9.mflops, 1, $noreg, 0, $noreg, %109:fr64 :: (store 8 into %ir.mflops)
10368B	  %110:gr32 = MOVSX32rm8 %stack.12.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
10384B	  %111:gr32 = MOV32rm $rip, 1, $noreg, @niter, $noreg :: (dereferenceable load 4 from @niter)
10400B	  undef %245.sub_32bit:gr64_with_sub_8bit = MOV32rm %stack.14.verified, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.verified)
10416B	  ADJCALLSTACKDOWN64 88, 0, 88, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
10480B	  $rdi = MOV32ri64 @.str.23
10496B	  $esi = COPY %110:gr32
10512B	  $edx = MOV32ri 7
10528B	  $ecx = MOV32ri 0
10544B	  $r8d = MOV32ri 0
10560B	  $r9d = COPY %111:gr32
10576B	  $xmm0 = COPY %107:fr64
10592B	  $xmm1 = COPY %109:fr64
10608B	  PUSH64i32 @.str.33, implicit-def $rsp, implicit $rsp
10624B	  PUSH64i32 @.str.32, implicit-def $rsp, implicit $rsp
10640B	  PUSH64i32 @.str.31, implicit-def $rsp, implicit $rsp
10656B	  PUSH64i32 @.str.30, implicit-def $rsp, implicit $rsp
10672B	  PUSH64i32 @.str.29, implicit-def $rsp, implicit $rsp
10688B	  PUSH64i32 @.str.28, implicit-def $rsp, implicit $rsp
10704B	  PUSH64i32 @.str.27, implicit-def $rsp, implicit $rsp
10720B	  PUSH64i32 @.str.26, implicit-def $rsp, implicit $rsp
10736B	  PUSH64i32 @.str.25, implicit-def $rsp, implicit $rsp
10768B	  PUSH64r %245:gr64_with_sub_8bit, implicit-def $rsp, implicit $rsp
10784B	  PUSH64i32 @.str.24, implicit-def $rsp, implicit $rsp
10800B	  CALL64pcrel32 @print_results, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $r8d, implicit killed $r9d, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp
10816B	  ADJCALLSTACKUP64 88, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
10832B	  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
10848B	  JCC_1 %bb.78, 4, implicit killed $eflags
10864B	  JMP_1 %bb.66

10880B	bb.66.if.then179:
	; predecessors: %bb.65
	  successors: %bb.67(0x80000000); %bb.67(100.00%)

10896B	  MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

10912B	bb.67.for.cond180:
	; predecessors: %bb.66, %bb.68
	  successors: %bb.68(0x7c000000), %bb.69(0x04000000); %bb.68(96.88%), %bb.69(3.12%)

10928B	  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 10, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
10944B	  JCC_1 %bb.69, 15, implicit killed $eflags
10960B	  JMP_1 %bb.68

10976B	bb.68.for.body183:
	; predecessors: %bb.67
	  successors: %bb.67(0x80000000); %bb.67(100.00%)

10992B	  %158:gr32 = MOV32rm %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
11008B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
11024B	  $edi = COPY %158:gr32
11040B	  CALL64pcrel32 @timer_read, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
11056B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
11072B	  %159:fr64 = COPY killed $xmm0
11088B	  %160:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
11104B	  MOVSDmr %stack.16.trecs, 8, %160:gr64_nosp, 0, $noreg, %159:fr64 :: (store 8 into %ir.arrayidx186)
11120B	  INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
11136B	  JMP_1 %bb.67

11152B	bb.69.for.end189:
	; predecessors: %bb.67
	  successors: %bb.70(0x50000000), %bb.71(0x30000000); %bb.70(62.50%), %bb.71(37.50%)

11168B	  %119:fr64 = MOVSDrm_alt %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
11184B	  %120:fr64 = FsFLD0SD
11200B	  UCOMISDrr %119:fr64, %120:fr64, implicit-def $eflags
11216B	  JCC_1 %bb.71, 5, implicit $eflags
11232B	  JCC_1 %bb.71, 10, implicit killed $eflags
11248B	  JMP_1 %bb.70

11264B	bb.70.if.then192:
	; predecessors: %bb.69
	  successors: %bb.71(0x80000000); %bb.71(100.00%)

11280B	  %121:gr64 = MOV64ri 4607182418800017408
11296B	  MOV64mr %stack.10.tmax, 1, $noreg, 0, $noreg, %121:gr64 :: (store 8 into %ir.tmax)

11312B	bb.71.if.end193:
	; predecessors: %bb.69, %bb.70
	  successors: %bb.72(0x80000000); %bb.72(100.00%)

11328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
11392B	  $rdi = MOV32ri64 @.str.34
11408B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
11424B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
11440B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
11456B	  MOV32mi %stack.6.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
11472B	  %241:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)

11568B	bb.72.for.cond195:
	; predecessors: %bb.71, %bb.77
	  successors: %bb.73(0x7c000000), %bb.78(0x04000000); %bb.73(96.88%), %bb.78(3.12%)

11584B	  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 10, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
11600B	  JCC_1 %bb.78, 15, implicit killed $eflags
11616B	  JMP_1 %bb.73

11632B	bb.73.for.body198:
	; predecessors: %bb.72
	  successors: %bb.74(0x40000000), %bb.75(0x40000000); %bb.74(50.00%), %bb.75(50.00%)

11648B	  %129:gr64_nosp = MOVSX64rm32 %stack.6.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
11664B	  %130:gr64 = MOV64rm %stack.17.t_names, 8, %129:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx200)
11680B	  %131:fr64 = MOVSDrm_alt %stack.16.trecs, 8, %129:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx204)
11696B	  %133:fr64 = COPY %131:fr64
11712B	  %133:fr64 = MULSDrr %133:fr64(tied-def 0), %241:fr64
11744B	  %133:fr64 = DIVSDrm %133:fr64(tied-def 0), %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
11760B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
11776B	  $rdi = MOV32ri64 @.str.35
11792B	  $rsi = COPY %130:gr64
11808B	  $xmm0 = COPY %131:fr64
11824B	  $xmm1 = COPY %133:fr64
11840B	  $al = MOV8ri 2
11856B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
11872B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
11888B	  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 4, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
11904B	  JCC_1 %bb.75, 5, implicit killed $eflags
11920B	  JMP_1 %bb.74

11936B	bb.74.if.then210:
	; predecessors: %bb.73
	  successors: %bb.77(0x80000000); %bb.77(100.00%)

11952B	  %151:fr64 = MOVSDrm_alt %stack.16.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx211)
11984B	  %151:fr64 = SUBSDrm %151:fr64(tied-def 0), %stack.16.trecs, 1, $noreg, 32, $noreg :: (dereferenceable load 8 from %ir.arrayidx212, align 16)
12000B	  MOVSDmr %stack.15.t2, 1, $noreg, 0, $noreg, %151:fr64 :: (store 8 into %ir.t2)
12016B	  %153:fr64 = COPY %151:fr64
12032B	  %153:fr64 = MULSDrr %153:fr64(tied-def 0), %241:fr64
12064B	  %153:fr64 = DIVSDrm %153:fr64(tied-def 0), %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
12080B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
12096B	  $rdi = MOV32ri64 @.str.36
12112B	  $rsi = MOV32ri64 @.str.37
12128B	  $xmm0 = COPY %151:fr64
12144B	  $xmm1 = COPY %153:fr64
12160B	  $al = MOV8ri 2
12176B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
12192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
12208B	  JMP_1 %bb.77

12224B	bb.75.if.else217:
	; predecessors: %bb.73
	  successors: %bb.76(0x40000000), %bb.77(0x40000000); %bb.76(50.00%), %bb.77(50.00%)

12240B	  CMP32mi8 %stack.6.i, 1, $noreg, 0, $noreg, 7, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
12256B	  JCC_1 %bb.77, 5, implicit killed $eflags
12272B	  JMP_1 %bb.76

12288B	bb.76.if.then220:
	; predecessors: %bb.75
	  successors: %bb.77(0x80000000); %bb.77(100.00%)

12304B	  %143:fr64 = MOVSDrm_alt %stack.16.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx221)
12336B	  %143:fr64 = SUBSDrm %143:fr64(tied-def 0), %stack.16.trecs, 1, $noreg, 48, $noreg :: (dereferenceable load 8 from %ir.arrayidx222, align 16)
12368B	  %143:fr64 = SUBSDrm %143:fr64(tied-def 0), %stack.16.trecs, 1, $noreg, 56, $noreg :: (dereferenceable load 8 from %ir.arrayidx224)
12384B	  MOVSDmr %stack.15.t2, 1, $noreg, 0, $noreg, %143:fr64 :: (store 8 into %ir.t2)
12400B	  %145:fr64 = COPY %143:fr64
12416B	  %145:fr64 = MULSDrr %145:fr64(tied-def 0), %241:fr64
12448B	  %145:fr64 = DIVSDrm %145:fr64(tied-def 0), %stack.10.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
12464B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
12480B	  $rdi = MOV32ri64 @.str.36
12496B	  $rsi = MOV32ri64 @.str.38
12512B	  $xmm0 = COPY %143:fr64
12528B	  $xmm1 = COPY %145:fr64
12544B	  $al = MOV8ri 2
12560B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
12576B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

12592B	bb.77.if.end230:
	; predecessors: %bb.75, %bb.76, %bb.74
	  successors: %bb.72(0x80000000); %bb.72(100.00%)

12608B	  INC32m %stack.6.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
12624B	  JMP_1 %bb.72

12640B	bb.78.if.end234:
	; predecessors: %bb.65, %bb.72

12672B	  $eax = MOV32r0 implicit-def dead $eflags
12688B	  RET 0, $eax

# End machine code for function main.

