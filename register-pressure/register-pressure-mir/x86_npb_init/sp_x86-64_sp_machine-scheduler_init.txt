Before MISched:
# Machine code for function main: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=4, align=4, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=4, align=4, at location [SP+8]
  fi#6: size=4, align=4, at location [SP+8]
  fi#7: size=8, align=8, at location [SP+8]
  fi#8: size=8, align=8, at location [SP+8]
  fi#9: size=8, align=8, at location [SP+8]
  fi#10: size=128, align=16, at location [SP+8]
  fi#11: size=4, align=4, at location [SP+8]
  fi#12: size=1, align=1, at location [SP+8]
  fi#13: size=128, align=16, at location [SP+8]
  fi#14: size=8, align=8, at location [SP+8]
  fi#15: size=4, align=4, at location [SP+8]
Constant Pool:
  cp#0: 3.000000e+00, align=8
  cp#1: 0x408B89645A1CAC08, align=8
  cp#2: -4.683910e+03, align=8
  cp#3: 1.148450e+04, align=8
  cp#4: -1.927240e+04, align=8
  cp#5: 1.000000e+06, align=8
  cp#6: 1.000000e+02, align=8
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
  MOV32mr %stack.1.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.2.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str
  $rsi = MOV32ri64 @.str.1
  CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %4:gr64 = COPY killed $rax
  MOV64mr %stack.14.fp, 1, $noreg, 0, $noreg, %4:gr64 :: (store 8 into %ir.fp)
  TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
  JCC_1 %bb.2, 4, implicit killed $eflags
  JMP_1 %bb.1

bb.1.if.then:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
  MOV64mi32 %stack.13.t_names, 1, $noreg, 8, $noreg, @.str.2 :: (store 8 into %ir.arrayidx)
  MOV64mi32 %stack.13.t_names, 1, $noreg, 16, $noreg, @.str.3 :: (store 8 into %ir.arrayidx1, align 16)
  MOV64mi32 %stack.13.t_names, 1, $noreg, 24, $noreg, @.str.4 :: (store 8 into %ir.arrayidx2)
  MOV64mi32 %stack.13.t_names, 1, $noreg, 32, $noreg, @.str.5 :: (store 8 into %ir.arrayidx3, align 16)
  MOV64mi32 %stack.13.t_names, 1, $noreg, 40, $noreg, @.str.6 :: (store 8 into %ir.arrayidx4)
  MOV64mi32 %stack.13.t_names, 1, $noreg, 48, $noreg, @.str.7 :: (store 8 into %ir.arrayidx5, align 16)
  MOV64mi32 %stack.13.t_names, 1, $noreg, 56, $noreg, @.str.8 :: (store 8 into %ir.arrayidx6)
  MOV64mi32 %stack.13.t_names, 1, $noreg, 64, $noreg, @.str.9 :: (store 8 into %ir.arrayidx7, align 16)
  MOV64mi32 %stack.13.t_names, 1, $noreg, 72, $noreg, @.str.10 :: (store 8 into %ir.arrayidx8)
  MOV64mi32 %stack.13.t_names, 1, $noreg, 80, $noreg, @.str.11 :: (store 8 into %ir.arrayidx9, align 16)
  MOV64mi32 %stack.13.t_names, 1, $noreg, 112, $noreg, @.str.12 :: (store 8 into %ir.arrayidx10, align 16)
  MOV64mi32 %stack.13.t_names, 1, $noreg, 104, $noreg, @.str.13 :: (store 8 into %ir.arrayidx11)
  MOV64mi32 %stack.13.t_names, 1, $noreg, 96, $noreg, @.str.14 :: (store 8 into %ir.arrayidx12, align 16)
  MOV64mi32 %stack.13.t_names, 1, $noreg, 88, $noreg, @.str.15 :: (store 8 into %ir.arrayidx13)
  MOV64mi32 %stack.13.t_names, 1, $noreg, 120, $noreg, @.str.16 :: (store 8 into %ir.arrayidx14)
  %5:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @fclose, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  JMP_1 %bb.3

bb.2.if.else:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  MOV32mi $rip, 1, $noreg, @timeron, $noreg, 0 :: (store 4 into @timeron)

bb.3.if.end:
; predecessors: %bb.2, %bb.1
  successors: %bb.4(0x50000000), %bb.9(0x30000000); %bb.4(62.50%), %bb.9(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.17
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.18
  $rsi = MOV32ri64 @.str.1
  CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %13:gr64 = COPY killed $rax
  MOV64mr %stack.14.fp, 1, $noreg, 0, $noreg, %13:gr64 :: (store 8 into %ir.fp)
  TEST64rr %13:gr64, %13:gr64, implicit-def $eflags
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.4

bb.4.if.then19:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.19
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %24:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %26:gr64 = LEA64r %stack.4.niter, 1, $noreg, 0, $noreg
  $rdi = COPY %24:gr64
  $rsi = MOV32ri64 @.str.20
  $rdx = COPY %26:gr64
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %27:gr32 = COPY killed $eax
  MOV32mr %stack.15.result, 1, $noreg, 0, $noreg, %27:gr32 :: (store 4 into %ir.result)

bb.5.while.cond:
; predecessors: %bb.4, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %28:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %28:gr64
  CALL64pcrel32 @fgetc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %29:gr32 = COPY killed $eax
  CMP32ri8 %29:gr32, 10, implicit-def $eflags
  JCC_1 %bb.5, 5, implicit killed $eflags
  JMP_1 %bb.6

bb.6.while.end:
; predecessors: %bb.5
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %31:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %31:gr64
  $rsi = MOV32ri64 @.str.21
  $rdx = MOV32ri64 @dt
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %36:gr32 = COPY killed $eax
  MOV32mr %stack.15.result, 1, $noreg, 0, $noreg, %36:gr32 :: (store 4 into %ir.result)

bb.7.while.cond25:
; predecessors: %bb.6, %bb.7
  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)

  %37:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %37:gr64
  CALL64pcrel32 @fgetc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %38:gr32 = COPY killed $eax
  CMP32ri8 %38:gr32, 10, implicit-def $eflags
  JCC_1 %bb.7, 5, implicit killed $eflags
  JMP_1 %bb.8

bb.8.while.end29:
; predecessors: %bb.7
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %40:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %40:gr64
  $rsi = MOV32ri64 @.str.22
  $rdx = MOV32ri64 @grid_points
  $rcx = MOV32ri64 @grid_points + 4
  $r8 = MOV32ri64 @grid_points + 8
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %47:gr32 = COPY killed $eax
  MOV32mr %stack.15.result, 1, $noreg, 0, $noreg, %47:gr32 :: (store 4 into %ir.result)
  %48:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %48:gr64
  CALL64pcrel32 @fclose, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  JMP_1 %bb.10

bb.9.if.else32:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.23
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi %stack.4.niter, 1, $noreg, 0, $noreg, 400 :: (store 4 into %ir.niter)
  %18:gr64 = MOV64ri 4562254508917369340
  MOV64mr $rip, 1, $noreg, @dt, $noreg, %18:gr64 :: (store 8 into @dt)
  %19:gr64 = MOV64ri 438086664294
  MOV64mr $rip, 1, $noreg, @grid_points, $noreg, %19:gr64 :: (store 8 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`, align 4)
  MOV32mi $rip, 1, $noreg, @grid_points + 8, $noreg, 102 :: (store 4 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)

bb.10.if.end34:
; predecessors: %bb.9, %bb.8
  successors: %bb.13(0x40000000), %bb.11(0x40000000); %bb.13(50.00%), %bb.11(50.00%)

  %50:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  %51:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  %52:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.24
  $esi = COPY %50:gr32
  $edx = COPY %51:gr32
  $ecx = COPY %52:gr32
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  %58:fr64 = MOVSDrm_alt $rip, 1, $noreg, @dt, $noreg :: (dereferenceable load 8 from @dt)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.25
  $esi = COPY %57:gr32
  $xmm0 = COPY %58:fr64
  $al = MOV8ri 1
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.26
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 $rip, 1, $noreg, @grid_points, $noreg, 102, implicit-def $eflags :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  JCC_1 %bb.13, 15, implicit killed $eflags
  JMP_1 %bb.11

bb.11.lor.lhs.false:
; predecessors: %bb.10
  successors: %bb.13(0x40000000), %bb.12(0x40000000); %bb.13(50.00%), %bb.12(50.00%)

  CMP32mi8 $rip, 1, $noreg, @grid_points + 4, $noreg, 102, implicit-def $eflags :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  JCC_1 %bb.13, 15, implicit killed $eflags
  JMP_1 %bb.12

bb.12.lor.lhs.false40:
; predecessors: %bb.11
  successors: %bb.13(0x40000000), %bb.14(0x40000000); %bb.13(50.00%), %bb.14(50.00%)

  CMP32mi8 $rip, 1, $noreg, @grid_points + 8, $noreg, 103, implicit-def $eflags :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  JCC_1 %bb.14, 12, implicit killed $eflags
  JMP_1 %bb.13

bb.13.if.then42:
; predecessors: %bb.10, %bb.11, %bb.12
  successors: %bb.45(0x80000000); %bb.45(100.00%)

  %211:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  %212:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  %213:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.27
  $esi = COPY %211:gr32
  $edx = COPY %212:gr32
  $ecx = COPY %213:gr32
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.28
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
  JMP_1 %bb.45

bb.14.if.end45:
; predecessors: %bb.12
  successors: %bb.15(0x80000000); %bb.15(100.00%)

  %71:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  %71:gr32 = ADD32ri8 %71:gr32(tied-def 0), -2, implicit-def dead $eflags
  MOV32mr $rip, 1, $noreg, @nx2, $noreg, %71:gr32 :: (store 4 into @nx2)
  %73:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  %73:gr32 = ADD32ri8 %73:gr32(tied-def 0), -2, implicit-def dead $eflags
  MOV32mr $rip, 1, $noreg, @ny2, $noreg, %73:gr32 :: (store 4 into @ny2)
  %75:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  %75:gr32 = ADD32ri8 %75:gr32(tied-def 0), -2, implicit-def dead $eflags
  MOV32mr $rip, 1, $noreg, @nz2, $noreg, %75:gr32 :: (store 4 into @nz2)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @set_constants, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

bb.15.for.cond:
; predecessors: %bb.14, %bb.16
  successors: %bb.16(0x7c000000), %bb.17(0x04000000); %bb.16(96.88%), %bb.17(3.12%)

  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 15, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.17, 15, implicit killed $eflags
  JMP_1 %bb.16

bb.16.for.body:
; predecessors: %bb.15
  successors: %bb.15(0x80000000); %bb.15(100.00%)

  %210:gr32 = MOV32rm %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %210:gr32
  CALL64pcrel32 @timer_clear, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  JMP_1 %bb.15

bb.17.for.end:
; predecessors: %bb.15
  successors: %bb.18(0x80000000); %bb.18(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @exact_rhs, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @initialize, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @adi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @initialize, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

bb.18.for.cond49:
; predecessors: %bb.17, %bb.19
  successors: %bb.19(0x7c000000), %bb.20(0x04000000); %bb.19(96.88%), %bb.20(3.12%)

  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 15, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.20, 15, implicit killed $eflags
  JMP_1 %bb.19

bb.19.for.body51:
; predecessors: %bb.18
  successors: %bb.18(0x80000000); %bb.18(100.00%)

  %209:gr32 = MOV32rm %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %209:gr32
  CALL64pcrel32 @timer_clear, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  JMP_1 %bb.18

bb.20.for.end54:
; predecessors: %bb.18
  successors: %bb.21(0x80000000); %bb.21(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 1
  CALL64pcrel32 @timer_start, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi %stack.5.step, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.step)

bb.21.for.cond55:
; predecessors: %bb.20, %bb.25
  successors: %bb.22(0x7c000000), %bb.26(0x04000000); %bb.22(96.88%), %bb.26(3.12%)

  %85:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  CMP32rm %85:gr32, %stack.4.niter, 1, $noreg, 0, $noreg, implicit-def $eflags :: (dereferenceable load 4 from %ir.niter)
  JCC_1 %bb.26, 15, implicit killed $eflags
  JMP_1 %bb.22

bb.22.for.body57:
; predecessors: %bb.21
  successors: %bb.24(0x30000000), %bb.23(0x50000000); %bb.24(37.50%), %bb.23(62.50%)

  %187:gr64_with_sub_8bit = MOVSX64rm32 %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  %196:gr64_nosp = IMUL64rri32 %187:gr64_with_sub_8bit, 1717986919, implicit-def dead $eflags
  %190:gr64_with_sub_8bit = COPY %196:gr64_nosp
  %190:gr64_with_sub_8bit = SHR64ri %190:gr64_with_sub_8bit(tied-def 0), 63, implicit-def dead $eflags
  %196:gr64_nosp = SAR64ri %196:gr64_nosp(tied-def 0), 35, implicit-def dead $eflags
  %196.sub_32bit:gr64_nosp = ADD32rr %196.sub_32bit:gr64_nosp(tied-def 0), %190.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags
  %196.sub_32bit:gr64_nosp = SHL32ri %196.sub_32bit:gr64_nosp(tied-def 0), 2, implicit-def dead $eflags
  %198:gr32 = LEA64_32r %196:gr64_nosp, 4, %196:gr64_nosp, 0, $noreg
  CMP32rr %187.sub_32bit:gr64_with_sub_8bit, %198:gr32, implicit-def $eflags
  JCC_1 %bb.24, 4, implicit killed $eflags
  JMP_1 %bb.23

bb.23.lor.lhs.false59:
; predecessors: %bb.22
  successors: %bb.24(0x40000000), %bb.25(0x40000000); %bb.24(50.00%), %bb.25(50.00%)

  CMP32mi8 %stack.5.step, 1, $noreg, 0, $noreg, 1, implicit-def $eflags :: (dereferenceable load 4 from %ir.step)
  JCC_1 %bb.25, 5, implicit killed $eflags
  JMP_1 %bb.24

bb.24.if.then61:
; predecessors: %bb.22, %bb.23
  successors: %bb.25(0x80000000); %bb.25(100.00%)

  %202:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.29
  $esi = COPY %202:gr32
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.25.if.end63:
; predecessors: %bb.23, %bb.24
  successors: %bb.21(0x80000000); %bb.21(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @adi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  INC32m %stack.5.step, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.step), (dereferenceable load 4 from %ir.step)
  JMP_1 %bb.21

bb.26.for.end66:
; predecessors: %bb.21
  successors: %bb.27(0x50000000), %bb.28(0x30000000); %bb.27(62.50%), %bb.28(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 1
  CALL64pcrel32 @timer_stop, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 1
  CALL64pcrel32 @timer_read, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %88:fr64 = COPY killed $xmm0
  MOVSDmr %stack.9.tmax, 1, $noreg, 0, $noreg, %88:fr64 :: (store 8 into %ir.tmax)
  %89:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %90:gr64 = LEA64r %stack.12.Class, 1, $noreg, 0, $noreg
  %91:gr64 = LEA64r %stack.11.verified, 1, $noreg, 0, $noreg
  $edi = COPY %89:gr32
  $rsi = COPY %90:gr64
  $rdx = COPY %91:gr64
  CALL64pcrel32 @verify, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %92:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  %93:fr64 = FsFLD0SD
  UCOMISDrr %92:fr64, %93:fr64, implicit-def $eflags
  JCC_1 %bb.27, 5, implicit $eflags
  JCC_1 %bb.27, 10, implicit killed $eflags
  JMP_1 %bb.28

bb.27.if.then69:
; predecessors: %bb.26
  successors: %bb.29(0x80000000); %bb.29(100.00%)

  %100:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  %95:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  %97:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  %98:gr32 = COPY %95:gr32
  %98:gr32 = IMUL32rr %98:gr32(tied-def 0), %97:gr32, implicit-def dead $eflags
  %98:gr32 = IMUL32rr %98:gr32(tied-def 0), %100:gr32, implicit-def dead $eflags
  MOV32mr %stack.6.n3, 1, $noreg, 0, $noreg, %98:gr32 :: (store 4 into %ir.n3)
  %100:gr32 = nsw ADD32rr %100:gr32(tied-def 0), %95:gr32, implicit-def dead $eflags
  %100:gr32 = nsw ADD32rr %100:gr32(tied-def 0), %97:gr32, implicit-def dead $eflags
  %108:fr64 = CVTSI2SDrr %100:gr32
  %108:fr64 = DIVSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %108:fr64 :: (store 8 into %ir.t)
  %104:fr64 = CVTSI2SDrr %98:gr32
  %104:fr64 = MULSDrm %104:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  %106:fr64 = COPY %108:fr64
  %106:fr64 = MULSDrr %106:fr64(tied-def 0), %106:fr64
  %106:fr64 = MULSDrm %106:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  %106:fr64 = ADDSDrr %106:fr64(tied-def 0), %104:fr64
  %108:fr64 = MULSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %108:fr64 = ADDSDrr %108:fr64(tied-def 0), %106:fr64
  %108:fr64 = ADDSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
  %115:fr64 = CVTSI2SDrm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  %115:fr64 = MULSDrr %115:fr64(tied-def 0), %108:fr64
  %114:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  %114:fr64 = MULSDrm %114:fr64(tied-def 0), $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
  %115:fr64 = DIVSDrr %115:fr64(tied-def 0), %114:fr64
  MOVSDmr %stack.7.mflops, 1, $noreg, 0, $noreg, %115:fr64 :: (store 8 into %ir.mflops)
  JMP_1 %bb.29

bb.28.if.else84:
; predecessors: %bb.26
  successors: %bb.29(0x80000000); %bb.29(100.00%)

  MOV64mi32 %stack.7.mflops, 1, $noreg, 0, $noreg, 0 :: (store 8 into %ir.mflops)

bb.29.if.end85:
; predecessors: %bb.28, %bb.27
  successors: %bb.30(0x50000000), %bb.44(0x30000000); %bb.30(62.50%), %bb.44(37.50%)

  %116:gr32 = MOVSX32rm8 %stack.12.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
  %117:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  %118:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  %119:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  %120:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  %121:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  %122:fr64 = MOVSDrm_alt %stack.7.mflops, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.mflops)
  undef %226.sub_32bit:gr64_with_sub_8bit = MOV32rm %stack.11.verified, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.verified)
  ADJCALLSTACKDOWN64 88, 0, 88, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.30
  $esi = COPY %116:gr32
  $edx = COPY %117:gr32
  $ecx = COPY %118:gr32
  $r8d = COPY %119:gr32
  $r9d = COPY %120:gr32
  $xmm0 = COPY %121:fr64
  $xmm1 = COPY %122:fr64
  PUSH64i32 @.str.40, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.39, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.38, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.37, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.36, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.35, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.34, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.33, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.32, implicit-def $rsp, implicit $rsp
  PUSH64r %226:gr64_with_sub_8bit, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.31, implicit-def $rsp, implicit $rsp
  CALL64pcrel32 @print_results, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $r8d, implicit killed $r9d, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 88, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
  JCC_1 %bb.44, 4, implicit killed $eflags
  JMP_1 %bb.30

bb.30.if.then86:
; predecessors: %bb.29
  successors: %bb.31(0x80000000); %bb.31(100.00%)

  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

bb.31.for.cond87:
; predecessors: %bb.30, %bb.32
  successors: %bb.32(0x7c000000), %bb.33(0x04000000); %bb.32(96.88%), %bb.33(3.12%)

  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 15, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.33, 15, implicit killed $eflags
  JMP_1 %bb.32

bb.32.for.body90:
; predecessors: %bb.31
  successors: %bb.31(0x80000000); %bb.31(100.00%)

  %184:gr32 = MOV32rm %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %184:gr32
  CALL64pcrel32 @timer_read, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %185:fr64 = COPY killed $xmm0
  %186:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOVSDmr %stack.10.trecs, 8, %186:gr64_nosp, 0, $noreg, %185:fr64 :: (store 8 into %ir.arrayidx92)
  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  JMP_1 %bb.31

bb.33.for.end95:
; predecessors: %bb.31
  successors: %bb.34(0x50000000), %bb.35(0x30000000); %bb.34(62.50%), %bb.35(37.50%)

  %128:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  %129:fr64 = FsFLD0SD
  UCOMISDrr %128:fr64, %129:fr64, implicit-def $eflags
  JCC_1 %bb.35, 5, implicit $eflags
  JCC_1 %bb.35, 10, implicit killed $eflags
  JMP_1 %bb.34

bb.34.if.then98:
; predecessors: %bb.33
  successors: %bb.35(0x80000000); %bb.35(100.00%)

  %130:gr64 = MOV64ri 4607182418800017408
  MOV64mr %stack.9.tmax, 1, $noreg, 0, $noreg, %130:gr64 :: (store 8 into %ir.tmax)

bb.35.if.end99:
; predecessors: %bb.33, %bb.34
  successors: %bb.36(0x80000000); %bb.36(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.41
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
  %222:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.6, $noreg :: (load 8 from constant-pool)

bb.36.for.cond101:
; predecessors: %bb.35, %bb.43
  successors: %bb.37(0x7c000000), %bb.44(0x04000000); %bb.37(96.88%), %bb.44(3.12%)

  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 15, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.44, 15, implicit killed $eflags
  JMP_1 %bb.37

bb.37.for.body104:
; predecessors: %bb.36
  successors: %bb.38(0x40000000), %bb.39(0x40000000); %bb.38(50.00%), %bb.39(50.00%)

  %137:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %138:gr64 = MOV64rm %stack.13.t_names, 8, %137:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx106)
  %139:fr64 = MOVSDrm_alt %stack.10.trecs, 8, %137:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx110)
  %141:fr64 = COPY %139:fr64
  %141:fr64 = MULSDrr %141:fr64(tied-def 0), %222:fr64
  %141:fr64 = DIVSDrm %141:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.42
  $rsi = COPY %138:gr64
  $xmm0 = COPY %139:fr64
  $xmm1 = COPY %141:fr64
  $al = MOV8ri 2
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 5, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.39, 5, implicit killed $eflags
  JMP_1 %bb.38

bb.38.if.then116:
; predecessors: %bb.37
  successors: %bb.43(0x80000000); %bb.43(100.00%)

  %170:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 16, $noreg :: (dereferenceable load 8 from %ir.arrayidx117, align 16)
  %170:fr64 = ADDSDrm %170:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx118)
  %170:fr64 = ADDSDrm %170:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 32, $noreg :: (dereferenceable load 8 from %ir.arrayidx120, align 16)
  MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %170:fr64 :: (store 8 into %ir.t)
  %173:fr64 = COPY %170:fr64
  %173:fr64 = MULSDrr %173:fr64(tied-def 0), %222:fr64
  %173:fr64 = DIVSDrm %173:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.43
  $rsi = MOV32ri64 @.str.44
  $xmm0 = COPY %170:fr64
  $xmm1 = COPY %173:fr64
  $al = MOV8ri 2
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %179:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx125)
  %179:fr64 = SUBSDrm %179:fr64(tied-def 0), %stack.8.t, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.t)
  MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %179:fr64 :: (store 8 into %ir.t)
  %181:fr64 = COPY %179:fr64
  %181:fr64 = MULSDrr %181:fr64(tied-def 0), %222:fr64
  %181:fr64 = DIVSDrm %181:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.43
  $rsi = MOV32ri64 @.str.45
  $xmm0 = COPY %179:fr64
  $xmm1 = COPY %181:fr64
  $al = MOV8ri 2
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  JMP_1 %bb.43

bb.39.if.else130:
; predecessors: %bb.37
  successors: %bb.40(0x40000000), %bb.41(0x40000000); %bb.40(50.00%), %bb.41(50.00%)

  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 8, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.41, 5, implicit killed $eflags
  JMP_1 %bb.40

bb.40.if.then133:
; predecessors: %bb.39
  successors: %bb.43(0x80000000); %bb.43(100.00%)

  %161:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 64, $noreg :: (dereferenceable load 8 from %ir.arrayidx134, align 16)
  %161:fr64 = SUBSDrm %161:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx135)
  %161:fr64 = SUBSDrm %161:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx137, align 16)
  MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %161:fr64 :: (store 8 into %ir.t)
  %163:fr64 = COPY %161:fr64
  %163:fr64 = MULSDrr %163:fr64(tied-def 0), %222:fr64
  %163:fr64 = DIVSDrm %163:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.43
  $rsi = MOV32ri64 @.str.46
  $xmm0 = COPY %161:fr64
  $xmm1 = COPY %163:fr64
  $al = MOV8ri 2
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  JMP_1 %bb.43

bb.41.if.else142:
; predecessors: %bb.39
  successors: %bb.42(0x40000000), %bb.43(0x40000000); %bb.42(50.00%), %bb.43(50.00%)

  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 10, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.43, 5, implicit killed $eflags
  JMP_1 %bb.42

bb.42.if.then145:
; predecessors: %bb.41
  successors: %bb.43(0x80000000); %bb.43(100.00%)

  %152:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx146)
  %152:fr64 = ADDSDrm %152:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx147, align 16)
  MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %152:fr64 :: (store 8 into %ir.t)
  %154:fr64 = COPY %152:fr64
  %154:fr64 = MULSDrr %154:fr64(tied-def 0), %222:fr64
  %154:fr64 = DIVSDrm %154:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.43
  $rsi = MOV32ri64 @.str.47
  $xmm0 = COPY %152:fr64
  $xmm1 = COPY %154:fr64
  $al = MOV8ri 2
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.43.if.end154:
; predecessors: %bb.41, %bb.42, %bb.40, %bb.38
  successors: %bb.36(0x80000000); %bb.36(100.00%)

  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  JMP_1 %bb.36

bb.44.if.end158:
; predecessors: %bb.29, %bb.36
  successors: %bb.45(0x80000000); %bb.45(100.00%)

  MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)

bb.45.return:
; predecessors: %bb.44, %bb.13

  %220:gr32 = MOV32rm %stack.0.retval, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.retval)
  $eax = COPY %220:gr32
  RET 0, killed $eax

# End machine code for function main.

********** MI Scheduling **********
main:%bb.0 entry
  From: %4:gr64 = COPY killed $rax
    To: JCC_1 %bb.2, 4, implicit killed $eflags
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %4:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(2): Data Latency=0 Reg=%4
    SU(1): Data Latency=0 Reg=%4
  Single Issue       : false;
SU(1):   MOV64mr %stack.14.fp, 1, $noreg, 0, $noreg, %4:gr64 :: (store 8 into %ir.fp)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%4
  Single Issue       : false;
SU(2):   TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%4
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.2, 4, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %stack.14.fp, 1, $noreg, 0, $noreg, %4:gr64 :: (store 8 into %ir.fp)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %4:gr64 = COPY killed $rax
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %4:gr64 = COPY killed $rax
SU(1):   MOV64mr %stack.14.fp, 1, $noreg, 0, $noreg, %4:gr64 :: (store 8 into %ir.fp)
SU(2):   TEST64rr %4:gr64, %4:gr64, implicit-def $eflags

********** MI Scheduling **********
main:%bb.0 entry
  From: $rdi = MOV32ri64 @.str
    To: CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.1
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   $rdi = MOV32ri64 @.str
SU(1):   $rsi = MOV32ri64 @.str.1

********** MI Scheduling **********
main:%bb.0 entry
  From: %1:gr64 = COPY $rsi
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %1:gr64 = COPY $rsi
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(4): Data Latency=0 Reg=%1
  Single Issue       : false;
SU(1):   %0:gr32 = COPY $edi
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(3): Data Latency=0 Reg=%0
  Single Issue       : false;
SU(2):   MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(3):   MOV32mr %stack.1.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Data Latency=0 Reg=%0
  Single Issue       : false;
SU(4):   MOV64mr %stack.2.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%1
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) MOV64mr %stack.2.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 0 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) MOV32mr %stack.1.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 0 1 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %0:gr32 = COPY $edi
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %1:gr64 = COPY $rsi
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %1:gr64 = COPY $rsi
SU(1):   %0:gr32 = COPY $edi
SU(2):   MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
SU(3):   MOV32mr %stack.1.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
SU(4):   MOV64mr %stack.2.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)

********** MI Scheduling **********
main:%bb.1 if.then
  From: MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 17
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GR16=2
Live In: 
Live Out: %5 
Live Thru: 
  LiveReg: %5
Top Pressure:

Bottom Pressure:
GR16=2
Excess PSets: 
SU(0):   MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : 
  Single Issue       : false;
SU(1):   MOV64mi32 %stack.13.t_names, 1, $noreg, 8, $noreg, @.str.2 :: (store 8 into %ir.arrayidx)
  # preds left       : 0
  # succs left       : 14
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
    SU(15): Ord  Latency=0 Memory
    SU(14): Ord  Latency=0 Memory
    SU(13): Ord  Latency=0 Memory
    SU(12): Ord  Latency=0 Memory
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(2):   MOV64mi32 %stack.13.t_names, 1, $noreg, 16, $noreg, @.str.3 :: (store 8 into %ir.arrayidx1, align 16)
  # preds left       : 1
  # succs left       : 13
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(15): Ord  Latency=0 Memory
    SU(14): Ord  Latency=0 Memory
    SU(13): Ord  Latency=0 Memory
    SU(12): Ord  Latency=0 Memory
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(3):   MOV64mi32 %stack.13.t_names, 1, $noreg, 24, $noreg, @.str.4 :: (store 8 into %ir.arrayidx2)
  # preds left       : 2
  # succs left       : 12
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(15): Ord  Latency=0 Memory
    SU(14): Ord  Latency=0 Memory
    SU(13): Ord  Latency=0 Memory
    SU(12): Ord  Latency=0 Memory
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(4):   MOV64mi32 %stack.13.t_names, 1, $noreg, 32, $noreg, @.str.5 :: (store 8 into %ir.arrayidx3, align 16)
  # preds left       : 3
  # succs left       : 11
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(15): Ord  Latency=0 Memory
    SU(14): Ord  Latency=0 Memory
    SU(13): Ord  Latency=0 Memory
    SU(12): Ord  Latency=0 Memory
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(5):   MOV64mi32 %stack.13.t_names, 1, $noreg, 40, $noreg, @.str.6 :: (store 8 into %ir.arrayidx4)
  # preds left       : 4
  # succs left       : 10
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(15): Ord  Latency=0 Memory
    SU(14): Ord  Latency=0 Memory
    SU(13): Ord  Latency=0 Memory
    SU(12): Ord  Latency=0 Memory
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(6):   MOV64mi32 %stack.13.t_names, 1, $noreg, 48, $noreg, @.str.7 :: (store 8 into %ir.arrayidx5, align 16)
  # preds left       : 5
  # succs left       : 9
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(15): Ord  Latency=0 Memory
    SU(14): Ord  Latency=0 Memory
    SU(13): Ord  Latency=0 Memory
    SU(12): Ord  Latency=0 Memory
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   MOV64mi32 %stack.13.t_names, 1, $noreg, 56, $noreg, @.str.8 :: (store 8 into %ir.arrayidx6)
  # preds left       : 6
  # succs left       : 8
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(15): Ord  Latency=0 Memory
    SU(14): Ord  Latency=0 Memory
    SU(13): Ord  Latency=0 Memory
    SU(12): Ord  Latency=0 Memory
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(8):   MOV64mi32 %stack.13.t_names, 1, $noreg, 64, $noreg, @.str.9 :: (store 8 into %ir.arrayidx7, align 16)
  # preds left       : 7
  # succs left       : 7
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(15): Ord  Latency=0 Memory
    SU(14): Ord  Latency=0 Memory
    SU(13): Ord  Latency=0 Memory
    SU(12): Ord  Latency=0 Memory
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(9):   MOV64mi32 %stack.13.t_names, 1, $noreg, 72, $noreg, @.str.10 :: (store 8 into %ir.arrayidx8)
  # preds left       : 8
  # succs left       : 6
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(15): Ord  Latency=0 Memory
    SU(14): Ord  Latency=0 Memory
    SU(13): Ord  Latency=0 Memory
    SU(12): Ord  Latency=0 Memory
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(10):   MOV64mi32 %stack.13.t_names, 1, $noreg, 80, $noreg, @.str.11 :: (store 8 into %ir.arrayidx9, align 16)
  # preds left       : 9
  # succs left       : 5
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(15): Ord  Latency=0 Memory
    SU(14): Ord  Latency=0 Memory
    SU(13): Ord  Latency=0 Memory
    SU(12): Ord  Latency=0 Memory
    SU(11): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(11):   MOV64mi32 %stack.13.t_names, 1, $noreg, 112, $noreg, @.str.12 :: (store 8 into %ir.arrayidx10, align 16)
  # preds left       : 10
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(15): Ord  Latency=0 Memory
    SU(14): Ord  Latency=0 Memory
    SU(13): Ord  Latency=0 Memory
    SU(12): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(12):   MOV64mi32 %stack.13.t_names, 1, $noreg, 104, $noreg, @.str.13 :: (store 8 into %ir.arrayidx11)
  # preds left       : 11
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(15): Ord  Latency=0 Memory
    SU(14): Ord  Latency=0 Memory
    SU(13): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(13):   MOV64mi32 %stack.13.t_names, 1, $noreg, 96, $noreg, @.str.14 :: (store 8 into %ir.arrayidx12, align 16)
  # preds left       : 12
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(12): Ord  Latency=0 Memory
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(15): Ord  Latency=0 Memory
    SU(14): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(14):   MOV64mi32 %stack.13.t_names, 1, $noreg, 88, $noreg, @.str.15 :: (store 8 into %ir.arrayidx13)
  # preds left       : 13
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(13): Ord  Latency=0 Memory
    SU(12): Ord  Latency=0 Memory
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(15): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(15):   MOV64mi32 %stack.13.t_names, 1, $noreg, 120, $noreg, @.str.16 :: (store 8 into %ir.arrayidx14)
  # preds left       : 14
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(14): Ord  Latency=0 Memory
    SU(13): Ord  Latency=0 Memory
    SU(12): Ord  Latency=0 Memory
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(16):   %5:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(16): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 15 0 16 
  Cand SU(15) ORDER                              
  Cand SU(16) ORDER                              
Pick Bot ORDER     
Scheduling SU(16) %5:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
Bottom Pressure:

  Ready @3c
  BotQ.A BotLatency SU(16) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 15 0 
  Cand SU(15) ORDER                              
Pick Bot ORDER     
Scheduling SU(15) MOV64mi32 %stack.13.t_names, 1, $noreg, 120, $noreg, @.str.16 :: (store 8 into %ir.arrayidx14)
Bottom Pressure:

  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 14 
  Cand SU(0) ORDER                              
  Cand SU(14) ORDER                              
Pick Bot ORDER     
Scheduling SU(14) MOV64mi32 %stack.13.t_names, 1, $noreg, 88, $noreg, @.str.15 :: (store 8 into %ir.arrayidx13)
Bottom Pressure:

  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 13 
  Cand SU(0) ORDER                              
  Cand SU(13) ORDER                              
Pick Bot ORDER     
Scheduling SU(13) MOV64mi32 %stack.13.t_names, 1, $noreg, 96, $noreg, @.str.14 :: (store 8 into %ir.arrayidx12, align 16)
Bottom Pressure:

  Ready @0c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 12 
  Cand SU(0) ORDER                              
  Cand SU(12) ORDER                              
Pick Bot ORDER     
Scheduling SU(12) MOV64mi32 %stack.13.t_names, 1, $noreg, 104, $noreg, @.str.13 :: (store 8 into %ir.arrayidx11)
Bottom Pressure:

  Ready @1c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 11 
  Cand SU(0) ORDER                              
  Cand SU(11) ORDER                              
Pick Bot ORDER     
Scheduling SU(11) MOV64mi32 %stack.13.t_names, 1, $noreg, 112, $noreg, @.str.12 :: (store 8 into %ir.arrayidx10, align 16)
Bottom Pressure:

  Ready @1c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 10 
  Cand SU(0) ORDER                              
  Cand SU(10) ORDER                              
Pick Bot ORDER     
Scheduling SU(10) MOV64mi32 %stack.13.t_names, 1, $noreg, 80, $noreg, @.str.11 :: (store 8 into %ir.arrayidx9, align 16)
Bottom Pressure:

  Ready @1c
BotQ.A @1c
  Retired: 7
  Executed: 1c
  Critical: 1c, 7 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 9 
  Cand SU(0) ORDER                              
  Cand SU(9) ORDER                              
Pick Bot ORDER     
Scheduling SU(9) MOV64mi32 %stack.13.t_names, 1, $noreg, 72, $noreg, @.str.10 :: (store 8 into %ir.arrayidx8)
Bottom Pressure:

  Ready @1c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 2c
  Critical: 2c, 8 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 8 
  Cand SU(0) ORDER                              
  Cand SU(8) ORDER                              
Pick Bot ORDER     
Scheduling SU(8) MOV64mi32 %stack.13.t_names, 1, $noreg, 64, $noreg, @.str.9 :: (store 8 into %ir.arrayidx7, align 16)
Bottom Pressure:

  Ready @2c
BotQ.A @2c
  Retired: 9
  Executed: 2c
  Critical: 2c, 9 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 7 
  Cand SU(0) ORDER                              
  Cand SU(7) ORDER                              
Pick Bot ORDER     
Scheduling SU(7) MOV64mi32 %stack.13.t_names, 1, $noreg, 56, $noreg, @.str.8 :: (store 8 into %ir.arrayidx6)
Bottom Pressure:

  Ready @2c
BotQ.A @2c
  Retired: 10
  Executed: 2c
  Critical: 2c, 10 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 6 
  Cand SU(0) ORDER                              
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) MOV64mi32 %stack.13.t_names, 1, $noreg, 48, $noreg, @.str.7 :: (store 8 into %ir.arrayidx5, align 16)
Bottom Pressure:

  Ready @2c
BotQ.A @2c
  Retired: 11
  Executed: 2c
  Critical: 2c, 11 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 5 
  Cand SU(0) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) MOV64mi32 %stack.13.t_names, 1, $noreg, 40, $noreg, @.str.6 :: (store 8 into %ir.arrayidx4)
Bottom Pressure:

  Ready @2c
  *** Max MOps 4 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 12
  Executed: 3c
  Critical: 3c, 12 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 4 
  Cand SU(0) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) MOV64mi32 %stack.13.t_names, 1, $noreg, 32, $noreg, @.str.5 :: (store 8 into %ir.arrayidx3, align 16)
Bottom Pressure:

  Ready @3c
BotQ.A @3c
  Retired: 13
  Executed: 3c
  Critical: 3c, 13 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 
  Cand SU(0) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) MOV64mi32 %stack.13.t_names, 1, $noreg, 24, $noreg, @.str.4 :: (store 8 into %ir.arrayidx2)
Bottom Pressure:

  Ready @3c
BotQ.A @3c
  Retired: 14
  Executed: 3c
  Critical: 3c, 14 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 
  Cand SU(0) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) MOV64mi32 %stack.13.t_names, 1, $noreg, 16, $noreg, @.str.3 :: (store 8 into %ir.arrayidx1, align 16)
Bottom Pressure:

  Ready @3c
BotQ.A @3c
  Retired: 15
  Executed: 3c
  Critical: 3c, 15 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) MOV64mi32 %stack.13.t_names, 1, $noreg, 8, $noreg, @.str.2 :: (store 8 into %ir.arrayidx)
Bottom Pressure:

  Ready @3c
  *** Max MOps 4 at cycle 3
Cycle: 4 BotQ.A
BotQ.A @4c
  Retired: 16
  Executed: 4c
  Critical: 4c, 16 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
Bottom Pressure:

  Ready @4c
BotQ.A @4c
  Retired: 17
  Executed: 4c
  Critical: 4c, 17 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.1 ***
SU(0):   MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
SU(1):   MOV64mi32 %stack.13.t_names, 1, $noreg, 8, $noreg, @.str.2 :: (store 8 into %ir.arrayidx)
SU(2):   MOV64mi32 %stack.13.t_names, 1, $noreg, 16, $noreg, @.str.3 :: (store 8 into %ir.arrayidx1, align 16)
SU(3):   MOV64mi32 %stack.13.t_names, 1, $noreg, 24, $noreg, @.str.4 :: (store 8 into %ir.arrayidx2)
SU(4):   MOV64mi32 %stack.13.t_names, 1, $noreg, 32, $noreg, @.str.5 :: (store 8 into %ir.arrayidx3, align 16)
SU(5):   MOV64mi32 %stack.13.t_names, 1, $noreg, 40, $noreg, @.str.6 :: (store 8 into %ir.arrayidx4)
SU(6):   MOV64mi32 %stack.13.t_names, 1, $noreg, 48, $noreg, @.str.7 :: (store 8 into %ir.arrayidx5, align 16)
SU(7):   MOV64mi32 %stack.13.t_names, 1, $noreg, 56, $noreg, @.str.8 :: (store 8 into %ir.arrayidx6)
SU(8):   MOV64mi32 %stack.13.t_names, 1, $noreg, 64, $noreg, @.str.9 :: (store 8 into %ir.arrayidx7, align 16)
SU(9):   MOV64mi32 %stack.13.t_names, 1, $noreg, 72, $noreg, @.str.10 :: (store 8 into %ir.arrayidx8)
SU(10):   MOV64mi32 %stack.13.t_names, 1, $noreg, 80, $noreg, @.str.11 :: (store 8 into %ir.arrayidx9, align 16)
SU(11):   MOV64mi32 %stack.13.t_names, 1, $noreg, 112, $noreg, @.str.12 :: (store 8 into %ir.arrayidx10, align 16)
SU(12):   MOV64mi32 %stack.13.t_names, 1, $noreg, 104, $noreg, @.str.13 :: (store 8 into %ir.arrayidx11)
SU(13):   MOV64mi32 %stack.13.t_names, 1, $noreg, 96, $noreg, @.str.14 :: (store 8 into %ir.arrayidx12, align 16)
SU(14):   MOV64mi32 %stack.13.t_names, 1, $noreg, 88, $noreg, @.str.15 :: (store 8 into %ir.arrayidx13)
SU(15):   MOV64mi32 %stack.13.t_names, 1, $noreg, 120, $noreg, @.str.16 :: (store 8 into %ir.arrayidx14)
SU(16):   %5:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)

********** MI Scheduling **********
main:%bb.3 if.end
  From: %13:gr64 = COPY killed $rax
    To: JCC_1 %bb.9, 4, implicit killed $eflags
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %13:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(2): Data Latency=0 Reg=%13
    SU(1): Data Latency=0 Reg=%13
  Single Issue       : false;
SU(1):   MOV64mr %stack.14.fp, 1, $noreg, 0, $noreg, %13:gr64 :: (store 8 into %ir.fp)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%13
  Single Issue       : false;
SU(2):   TEST64rr %13:gr64, %13:gr64, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%13
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.9, 4, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) TEST64rr %13:gr64, %13:gr64, implicit-def $eflags
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %stack.14.fp, 1, $noreg, 0, $noreg, %13:gr64 :: (store 8 into %ir.fp)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %13:gr64 = COPY killed $rax
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.3 ***
SU(0):   %13:gr64 = COPY killed $rax
SU(1):   MOV64mr %stack.14.fp, 1, $noreg, 0, $noreg, %13:gr64 :: (store 8 into %ir.fp)
SU(2):   TEST64rr %13:gr64, %13:gr64, implicit-def $eflags

********** MI Scheduling **********
main:%bb.3 if.end
  From: $rdi = MOV32ri64 @.str.18
    To: CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.18
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.1
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.18
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.3 ***
SU(0):   $rdi = MOV32ri64 @.str.18
SU(1):   $rsi = MOV32ri64 @.str.1

********** MI Scheduling **********
main:%bb.3 if.end
  From: $rdi = MOV32ri64 @.str.17
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.17
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.17
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.3 ***
SU(0):   $rdi = MOV32ri64 @.str.17
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.4 if.then19
  From: %27:gr32 = COPY killed $eax
    To: End RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %27:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Data Latency=0 Reg=%27
  Single Issue       : false;
SU(1):   MOV32mr %stack.15.result, 1, $noreg, 0, $noreg, %27:gr32 :: (store 4 into %ir.result)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%27
  Single Issue       : false;
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV32mr %stack.15.result, 1, $noreg, 0, $noreg, %27:gr32 :: (store 4 into %ir.result)
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %27:gr32 = COPY killed $eax
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   %27:gr32 = COPY killed $eax
SU(1):   MOV32mr %stack.15.result, 1, $noreg, 0, $noreg, %27:gr32 :: (store 4 into %ir.result)

********** MI Scheduling **********
main:%bb.4 if.then19
  From: %26:gr64 = LEA64r %stack.4.niter, 1, $noreg, 0, $noreg
    To: CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %26:gr64 = LEA64r %stack.4.niter, 1, $noreg, 0, $noreg
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(3): Data Latency=1 Reg=%26
  Single Issue       : false;
SU(1):   $rdi = COPY %24:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $rsi = MOV32ri64 @.str.20
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(3):   $rdx = COPY %26:gr64
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(0): Data Latency=1 Reg=%26
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 3 2 
  Cand SU(1) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) $rdx = COPY %26:gr64
  Ready @0c
  BotQ.A TopLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) $rdi = COPY %24:gr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 
  Cand SU(0) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $rsi = MOV32ri64 @.str.20
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %26:gr64 = LEA64r %stack.4.niter, 1, $noreg, 0, $noreg
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   %26:gr64 = LEA64r %stack.4.niter, 1, $noreg, 0, $noreg
SU(2):   $rsi = MOV32ri64 @.str.20
SU(1):   $rdi = COPY %24:gr64
SU(3):   $rdx = COPY %26:gr64
SU(4):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.4 if.then19
  From: $rdi = MOV32ri64 @.str.19
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.19
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.19
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   $rdi = MOV32ri64 @.str.19
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.5 while.cond
  From: %29:gr32 = COPY killed $eax
    To: JCC_1 %bb.5, 5, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %29:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%29
  Single Issue       : false;
SU(1):   CMP32ri8 %29:gr32, 10, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%29
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.5, 5, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32ri8 %29:gr32, 10, implicit-def $eflags
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %29:gr32 = COPY killed $eax
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.5 ***
SU(0):   %29:gr32 = COPY killed $eax
SU(1):   CMP32ri8 %29:gr32, 10, implicit-def $eflags

********** MI Scheduling **********
main:%bb.6 while.end
  From: %36:gr32 = COPY killed $eax
    To: End RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %36:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Data Latency=0 Reg=%36
  Single Issue       : false;
SU(1):   MOV32mr %stack.15.result, 1, $noreg, 0, $noreg, %36:gr32 :: (store 4 into %ir.result)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%36
  Single Issue       : false;
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV32mr %stack.15.result, 1, $noreg, 0, $noreg, %36:gr32 :: (store 4 into %ir.result)
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %36:gr32 = COPY killed $eax
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(0):   %36:gr32 = COPY killed $eax
SU(1):   MOV32mr %stack.15.result, 1, $noreg, 0, $noreg, %36:gr32 :: (store 4 into %ir.result)

********** MI Scheduling **********
main:%bb.6 while.end
  From: $rdi = COPY %31:gr64
    To: CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %31:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.21
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $rdx = MOV32ri64 @dt
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(3):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=1 Artificial
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 1 0 
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 1 
  Cand SU(0) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(0) $rdi = COPY %31:gr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $rdx = MOV32ri64 @dt
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) $rsi = MOV32ri64 @.str.21
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(1):   $rsi = MOV32ri64 @.str.21
SU(2):   $rdx = MOV32ri64 @dt
SU(0):   $rdi = COPY %31:gr64
SU(3):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.7 while.cond25
  From: %38:gr32 = COPY killed $eax
    To: JCC_1 %bb.7, 5, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %38:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%38
  Single Issue       : false;
SU(1):   CMP32ri8 %38:gr32, 10, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%38
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.7, 5, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32ri8 %38:gr32, 10, implicit-def $eflags
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %38:gr32 = COPY killed $eax
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.7 ***
SU(0):   %38:gr32 = COPY killed $eax
SU(1):   CMP32ri8 %38:gr32, 10, implicit-def $eflags

********** MI Scheduling **********
main:%bb.8 while.end29
  From: %47:gr32 = COPY killed $eax
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %47:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Data Latency=0 Reg=%47
  Single Issue       : false;
SU(1):   MOV32mr %stack.15.result, 1, $noreg, 0, $noreg, %47:gr32 :: (store 4 into %ir.result)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%47
  Single Issue       : false;
SU(2):   %48:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %48:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  Ready @3c
  BotQ.A BotLatency SU(2) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV32mr %stack.15.result, 1, $noreg, 0, $noreg, %47:gr32 :: (store 4 into %ir.result)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %47:gr32 = COPY killed $eax
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.8 ***
SU(0):   %47:gr32 = COPY killed $eax
SU(1):   MOV32mr %stack.15.result, 1, $noreg, 0, $noreg, %47:gr32 :: (store 4 into %ir.result)
SU(2):   %48:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)

********** MI Scheduling **********
main:%bb.8 while.end29
  From: $rdi = COPY %40:gr64
    To: CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %40:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.22
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $rdx = MOV32ri64 @grid_points
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(3):   $rcx = MOV32ri64 @grid_points + 4
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(4):   $r8 = MOV32ri64 @grid_points + 8
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(5):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  # preds left       : 6
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=1 Artificial
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=1 Artificial
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 4 3 2 1 0 
  Cand SU(5) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(5) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(5) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 4 3 2 1 
  Cand SU(0) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(0) $rdi = COPY %40:gr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 4 3 2 
  Cand SU(1) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) $r8 = MOV32ri64 @grid_points + 8
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 3 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) $rcx = MOV32ri64 @grid_points + 4
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $rdx = MOV32ri64 @grid_points
  Ready @1c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) $rsi = MOV32ri64 @.str.22
  Ready @1c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.8 ***
SU(1):   $rsi = MOV32ri64 @.str.22
SU(2):   $rdx = MOV32ri64 @grid_points
SU(3):   $rcx = MOV32ri64 @grid_points + 4
SU(4):   $r8 = MOV32ri64 @grid_points + 8
SU(0):   $rdi = COPY %40:gr64
SU(5):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.9 if.else32
  From: MOV32mi %stack.4.niter, 1, $noreg, 0, $noreg, 400 :: (store 4 into %ir.niter)
    To: End RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV32mi %stack.4.niter, 1, $noreg, 0, $noreg, 400 :: (store 4 into %ir.niter)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   %18:gr64 = MOV64ri 4562254508917369340
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(2): Data Latency=1 Reg=%18
  Single Issue       : false;
SU(2):   MOV64mr $rip, 1, $noreg, @dt, $noreg, %18:gr64 :: (store 8 into @dt)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%18
  Single Issue       : false;
SU(3):   %19:gr64 = MOV64ri 438086664294
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(4): Data Latency=1 Reg=%19
  Single Issue       : false;
SU(4):   MOV64mr $rip, 1, $noreg, @grid_points, $noreg, %19:gr64 :: (store 8 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`, align 4)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(3): Data Latency=1 Reg=%19
  Successors:
    SU(5): Ord  Latency=0 Memory
  Single Issue       : false;
SU(5):   MOV32mi $rip, 1, $noreg, @grid_points + 8, $noreg, 102 :: (store 4 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=0 Memory
  Single Issue       : false;
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 2 0 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) MOV32mi $rip, 1, $noreg, @grid_points + 8, $noreg, 102 :: (store 4 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  Ready @0c
  BotQ.A TopLatency SU(5) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 4 
  Cand SU(0) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) MOV64mr $rip, 1, $noreg, @grid_points, $noreg, %19:gr64 :: (store 8 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`, align 4)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 3 
  Cand SU(0) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %19:gr64 = MOV64ri 438086664294
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 
  Cand SU(0) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) MOV64mr $rip, 1, $noreg, @dt, $noreg, %18:gr64 :: (store 8 into @dt)
  Ready @0c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %18:gr64 = MOV64ri 4562254508917369340
  Ready @1c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV32mi %stack.4.niter, 1, $noreg, 0, $noreg, 400 :: (store 4 into %ir.niter)
  Ready @1c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.9 ***
SU(0):   MOV32mi %stack.4.niter, 1, $noreg, 0, $noreg, 400 :: (store 4 into %ir.niter)
SU(1):   %18:gr64 = MOV64ri 4562254508917369340
SU(2):   MOV64mr $rip, 1, $noreg, @dt, $noreg, %18:gr64 :: (store 8 into @dt)
SU(3):   %19:gr64 = MOV64ri 438086664294
SU(4):   MOV64mr $rip, 1, $noreg, @grid_points, $noreg, %19:gr64 :: (store 8 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`, align 4)
SU(5):   MOV32mi $rip, 1, $noreg, @grid_points + 8, $noreg, 102 :: (store 4 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)

********** MI Scheduling **********
main:%bb.9 if.else32
  From: $rdi = MOV32ri64 @.str.23
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.23
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.23
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.9 ***
SU(0):   $rdi = MOV32ri64 @.str.23
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.10 if.end34
  From: $rdi = MOV32ri64 @.str.26
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.26
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.26
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(0):   $rdi = MOV32ri64 @.str.26
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.10 if.end34
  From: $rdi = MOV32ri64 @.str.25
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.25
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %57:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %58:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $al = MOV8ri 1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=1 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 1 0 
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) $al = MOV8ri 1
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 1 
  Cand SU(0) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) $xmm0 = COPY %58:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %57:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.25
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(0):   $rdi = MOV32ri64 @.str.25
SU(1):   $esi = COPY %57:gr32
SU(2):   $xmm0 = COPY %58:fr64
SU(3):   $al = MOV8ri 1

********** MI Scheduling **********
main:%bb.10 if.end34
  From: %57:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %57:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
SU(1):   %58:fr64 = MOVSDrm_alt $rip, 1, $noreg, @dt, $noreg :: (dereferenceable load 8 from @dt)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=3 Artificial
    SU(0): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %58:fr64 = MOVSDrm_alt $rip, 1, $noreg, @dt, $noreg :: (dereferenceable load 8 from @dt)
  Ready @3c
  BotQ.A BotLatency SU(1) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %57:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  Ready @3c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(0):   %57:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
SU(1):   %58:fr64 = MOVSDrm_alt $rip, 1, $noreg, @dt, $noreg :: (dereferenceable load 8 from @dt)

********** MI Scheduling **********
main:%bb.10 if.end34
  From: $rdi = MOV32ri64 @.str.24
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.24
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %50:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $edx = COPY %51:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $ecx = COPY %52:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $ecx = COPY %52:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $edx = COPY %51:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %50:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.24
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(0):   $rdi = MOV32ri64 @.str.24
SU(1):   $esi = COPY %50:gr32
SU(2):   $edx = COPY %51:gr32
SU(3):   $ecx = COPY %52:gr32
SU(4):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.10 if.end34
  From: %50:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %50:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
SU(1):   %51:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
SU(2):   %52:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=3 Artificial
    SU(1): Ord  Latency=3 Artificial
    SU(0): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %52:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  Ready @3c
  BotQ.A BotLatency SU(2) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %51:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  Ready @3c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %50:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  Ready @3c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(0):   %50:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
SU(1):   %51:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
SU(2):   %52:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)

********** MI Scheduling **********
main:%bb.13 if.then42
  From: $rdi = MOV32ri64 @.str.28
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.28
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.28
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.13 ***
SU(0):   $rdi = MOV32ri64 @.str.28
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.13 if.then42
  From: $rdi = MOV32ri64 @.str.27
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.27
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %211:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $edx = COPY %212:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $ecx = COPY %213:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $ecx = COPY %213:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $edx = COPY %212:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %211:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.27
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.13 ***
SU(0):   $rdi = MOV32ri64 @.str.27
SU(1):   $esi = COPY %211:gr32
SU(2):   $edx = COPY %212:gr32
SU(3):   $ecx = COPY %213:gr32
SU(4):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.13 if.then42
  From: %211:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %211:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
SU(1):   %212:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
SU(2):   %213:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=3 Artificial
    SU(1): Ord  Latency=3 Artificial
    SU(0): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %213:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  Ready @3c
  BotQ.A BotLatency SU(2) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %212:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  Ready @3c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %211:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  Ready @3c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.13 ***
SU(0):   %211:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
SU(1):   %212:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
SU(2):   %213:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)

********** MI Scheduling **********
main:%bb.14 if.end45
  From: %71:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 9
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GR16=2
Live In: 
Live Out: 
Live Thru: 
Top Pressure:

Bottom Pressure:

Excess PSets: 
SU(0):   %71:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
    SU(1): Data Latency=4 Reg=%71
    SU(1): Out  Latency=0
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(1):   %71:gr32 = ADD32ri8 %71:gr32(tied-def 0), -2, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(0): Data Latency=4 Reg=%71
    SU(0): Out  Latency=0
  Successors:
    SU(2): Data Latency=1 Reg=%71
  Pressure Diff      : 
  Single Issue       : false;
SU(2):   MOV32mr $rip, 1, $noreg, @nx2, $noreg, %71:gr32 :: (store 4 into @nx2)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%71
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(3):   %73:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
    SU(4): Data Latency=4 Reg=%73
    SU(4): Out  Latency=0
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(4):   %73:gr32 = ADD32ri8 %73:gr32(tied-def 0), -2, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(3): Data Latency=4 Reg=%73
    SU(3): Out  Latency=0
  Successors:
    SU(5): Data Latency=1 Reg=%73
  Pressure Diff      : 
  Single Issue       : false;
SU(5):   MOV32mr $rip, 1, $noreg, @ny2, $noreg, %73:gr32 :: (store 4 into @ny2)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(4): Data Latency=1 Reg=%73
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(6):   %75:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
    SU(7): Data Latency=4 Reg=%75
    SU(7): Out  Latency=0
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(7):   %75:gr32 = ADD32ri8 %75:gr32(tied-def 0), -2, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(6): Data Latency=4 Reg=%75
    SU(6): Out  Latency=0
  Successors:
    SU(8): Data Latency=1 Reg=%75
  Pressure Diff      : 
  Single Issue       : false;
SU(8):   MOV32mr $rip, 1, $noreg, @nz2, $noreg, %75:gr32 :: (store 4 into @nz2)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(7): Data Latency=1 Reg=%75
  Pressure Diff      : GR16 2
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 5
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 5 2 
  Cand SU(8) ORDER                              
Pick Bot ORDER     
Scheduling SU(8) MOV32mr $rip, 1, $noreg, @nz2, $noreg, %75:gr32 :: (store 4 into @nz2)
Bottom Pressure:
GR16=2
  LiveReg: %75
  UpdateRegP: SU(8) MOV32mr $rip, 1, $noreg, @nz2, $noreg, %75:gr32 :: (store 4 into @nz2)
              to 
  Ready @0c
  BotQ.A TopLatency SU(8) 5c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 5 7 
  Cand SU(2) ORDER                              
  Cand SU(5) ORDER                              
  Cand SU(7) REG-MAX                            
Pick Bot REG-MAX   
Scheduling SU(7) %75:gr32 = ADD32ri8 %75:gr32(tied-def 0), -2, implicit-def dead $eflags
Bottom Pressure:
GR16=2
  LiveReg: %75
  UpdateRegP: SU(7) %75:gr32 = ADD32ri8 %75:gr32(tied-def 0), -2, implicit-def dead $eflags
              to GR16 -2
  Ready @1c
  BotQ.A BotLatency SU(7) 1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 5 6 
  Cand SU(2) ORDER                              
  Cand SU(5) ORDER                              
  Cand SU(6) REG-MAX                            
Pick Bot REG-MAX   
Scheduling SU(6) %75:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
Bottom Pressure:

  Ready @5c
  BotQ.A BotLatency SU(6) 5c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 5 
  Cand SU(2) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) MOV32mr $rip, 1, $noreg, @ny2, $noreg, %73:gr32 :: (store 4 into @ny2)
Bottom Pressure:
GR16=2
  LiveReg: %73
  UpdateRegP: SU(5) MOV32mr $rip, 1, $noreg, @ny2, $noreg, %73:gr32 :: (store 4 into @ny2)
              to 
  Ready @0c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 4 
  Cand SU(2) ORDER                              
  Cand SU(4) REG-MAX                            
Pick Bot REG-MAX   
Scheduling SU(4) %73:gr32 = ADD32ri8 %73:gr32(tied-def 0), -2, implicit-def dead $eflags
Bottom Pressure:
GR16=2
  LiveReg: %73
  UpdateRegP: SU(4) %73:gr32 = ADD32ri8 %73:gr32(tied-def 0), -2, implicit-def dead $eflags
              to GR16 -2
  Ready @1c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 
  Cand SU(2) ORDER                              
  Cand SU(3) REG-MAX                            
Pick Bot REG-MAX   
Scheduling SU(3) %73:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
Bottom Pressure:

  Ready @5c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOV32mr $rip, 1, $noreg, @nx2, $noreg, %71:gr32 :: (store 4 into @nx2)
Bottom Pressure:
GR16=2
  LiveReg: %71
  UpdateRegP: SU(2) MOV32mr $rip, 1, $noreg, @nx2, $noreg, %71:gr32 :: (store 4 into @nx2)
              to 
  Ready @1c
  BotQ.A TopLatency SU(2) 5c
BotQ.A @1c
  Retired: 7
  Executed: 1c
  Critical: 1c, 7 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %71:gr32 = ADD32ri8 %71:gr32(tied-def 0), -2, implicit-def dead $eflags
Bottom Pressure:
GR16=2
  LiveReg: %71
  UpdateRegP: SU(1) %71:gr32 = ADD32ri8 %71:gr32(tied-def 0), -2, implicit-def dead $eflags
              to GR16 -2
  Ready @2c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 2c
  Critical: 2c, 8 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %71:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
Bottom Pressure:

  Ready @6c
BotQ.A @2c
  Retired: 9
  Executed: 2c
  Critical: 2c, 9 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.14 ***
SU(0):   %71:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
SU(1):   %71:gr32 = ADD32ri8 %71:gr32(tied-def 0), -2, implicit-def dead $eflags
SU(2):   MOV32mr $rip, 1, $noreg, @nx2, $noreg, %71:gr32 :: (store 4 into @nx2)
SU(3):   %73:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
SU(4):   %73:gr32 = ADD32ri8 %73:gr32(tied-def 0), -2, implicit-def dead $eflags
SU(5):   MOV32mr $rip, 1, $noreg, @ny2, $noreg, %73:gr32 :: (store 4 into @ny2)
SU(6):   %75:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
SU(7):   %75:gr32 = ADD32ri8 %75:gr32(tied-def 0), -2, implicit-def dead $eflags
SU(8):   MOV32mr $rip, 1, $noreg, @nz2, $noreg, %75:gr32 :: (store 4 into @nz2)

********** MI Scheduling **********
main:%bb.21 for.cond55
  From: %85:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
    To: JCC_1 %bb.26, 15, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %85:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 8
  Successors:
    SU(1): Data Latency=4 Reg=%85
  Single Issue       : false;
SU(1):   CMP32rm %85:gr32, %stack.4.niter, 1, $noreg, 0, $noreg, implicit-def $eflags :: (dereferenceable load 4 from %ir.niter)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 4
  Predecessors:
    SU(0): Data Latency=4 Reg=%85
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.26, 15, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=4 Artificial
Critical Path(GS-RR ): 8
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32rm %85:gr32, %stack.4.niter, 1, $noreg, 0, $noreg, implicit-def $eflags :: (dereferenceable load 4 from %ir.niter)
  Ready @4c
  BotQ.A TopLatency SU(1) 4c
  BotQ.A BotLatency SU(1) 4c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %85:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  Ready @8c
  BotQ.A BotLatency SU(0) 8c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.21 ***
SU(0):   %85:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
SU(1):   CMP32rm %85:gr32, %stack.4.niter, 1, $noreg, 0, $noreg, implicit-def $eflags :: (dereferenceable load 4 from %ir.niter)

********** MI Scheduling **********
main:%bb.22 for.body57
  From: %187:gr64_with_sub_8bit = MOVSX64rm32 %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
    To: JCC_1 %bb.24, 4, implicit killed $eflags
 RegionInstrs: 9
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GR16=6
Live In: 
Live Out: 
Live Thru: 
Top Pressure:

Bottom Pressure:

Excess PSets: 
SU(0):   %187:gr64_with_sub_8bit = MOVSX64rm32 %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 10
  Successors:
    SU(8): Data Latency=4 Reg=%187
    SU(1): Data Latency=4 Reg=%187
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(1):   %196:gr64_nosp = IMUL64rri32 %187:gr64_with_sub_8bit, 1717986919, implicit-def dead $eflags
  # preds left       : 1
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(0): Data Latency=4 Reg=%187
  Successors:
    SU(4): Data Latency=1 Reg=%196
    SU(2): Data Latency=1 Reg=%196
    SU(4): Out  Latency=0
    SU(8): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(2):   %190:gr64_with_sub_8bit = COPY %196:gr64_nosp
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 0
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(1): Data Latency=1 Reg=%196
  Successors:
    SU(3): Data Latency=0 Reg=%190
    SU(3): Out  Latency=0
    SU(4): Anti Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(3):   %190:gr64_with_sub_8bit = SHR64ri %190:gr64_with_sub_8bit(tied-def 0), 63, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(2): Data Latency=0 Reg=%190
    SU(2): Out  Latency=0
  Successors:
    SU(5): Data Latency=1 Reg=%190
    SU(8): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(4):   %196:gr64_nosp = SAR64ri %196:gr64_nosp(tied-def 0), 35, implicit-def dead $eflags
  # preds left       : 3
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(2): Anti Latency=0
    SU(1): Data Latency=1 Reg=%196
    SU(1): Out  Latency=0
  Successors:
    SU(5): Data Latency=1 Reg=%196
    SU(5): Out  Latency=0
    SU(8): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(5):   %196.sub_32bit:gr64_nosp = ADD32rr %196.sub_32bit:gr64_nosp(tied-def 0), %190.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags
  # preds left       : 3
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(4): Data Latency=1 Reg=%196
    SU(4): Out  Latency=0
    SU(3): Data Latency=1 Reg=%190
  Successors:
    SU(6): Data Latency=1 Reg=%196
    SU(6): Out  Latency=0
    SU(8): Out  Latency=0
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(6):   %196.sub_32bit:gr64_nosp = SHL32ri %196.sub_32bit:gr64_nosp(tied-def 0), 2, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1 Reg=%196
    SU(5): Out  Latency=0
  Successors:
    SU(7): Data Latency=1 Reg=%196
    SU(8): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   %198:gr32 = LEA64_32r %196:gr64_nosp, 4, %196:gr64_nosp, 0, $noreg
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1 Reg=%196
  Successors:
    SU(8): Data Latency=1 Reg=%198
  Pressure Diff      : 
  Single Issue       : false;
SU(8):   CMP32rr %187.sub_32bit:gr64_with_sub_8bit, %198:gr32, implicit-def $eflags
  # preds left       : 7
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(7): Data Latency=1 Reg=%198
    SU(6): Out  Latency=0
    SU(5): Out  Latency=0
    SU(4): Out  Latency=0
    SU(3): Out  Latency=0
    SU(1): Out  Latency=0
    SU(0): Data Latency=4 Reg=%187
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Pressure Diff      : GR16 4
  Single Issue       : false;
ExitSU:   JCC_1 %bb.24, 4, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(8): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 10
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 
Scheduling SU(8) CMP32rr %187.sub_32bit:gr64_with_sub_8bit, %198:gr32, implicit-def $eflags
Bottom Pressure:
GR16=4
  LiveReg: %187
  UpdateRegP: SU(1) %196:gr64_nosp = IMUL64rri32 %187:gr64_with_sub_8bit, 1717986919, implicit-def dead $eflags
              to GR16 -2
  UpdateRegP: SU(8) CMP32rr %187.sub_32bit:gr64_with_sub_8bit, %198:gr32, implicit-def $eflags
              to GR16 2
  LiveReg: %198
  UpdateRegP: SU(8) CMP32rr %187.sub_32bit:gr64_with_sub_8bit, %198:gr32, implicit-def $eflags
              to 
  Ready @1c
  BotQ.A TopLatency SU(8) 9c
  BotQ.A BotLatency SU(8) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 
Scheduling SU(7) %198:gr32 = LEA64_32r %196:gr64_nosp, 4, %196:gr64_nosp, 0, $noreg
Bottom Pressure:
GR16=4
  LiveReg: %196
  UpdateRegP: SU(7) %198:gr32 = LEA64_32r %196:gr64_nosp, 4, %196:gr64_nosp, 0, $noreg
              to GR16 -2
  Ready @2c
  BotQ.A BotLatency SU(7) 2c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 
Scheduling SU(6) %196.sub_32bit:gr64_nosp = SHL32ri %196.sub_32bit:gr64_nosp(tied-def 0), 2, implicit-def dead $eflags
Bottom Pressure:
GR16=4
  LiveReg: %196
  UpdateRegP: SU(6) %196.sub_32bit:gr64_nosp = SHL32ri %196.sub_32bit:gr64_nosp(tied-def 0), 2, implicit-def dead $eflags
              to GR16 -2
  Ready @3c
  BotQ.A BotLatency SU(6) 3c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 
Scheduling SU(5) %196.sub_32bit:gr64_nosp = ADD32rr %196.sub_32bit:gr64_nosp(tied-def 0), %190.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags
Bottom Pressure:
GR16=6
  LiveReg: %196
  UpdateRegP: SU(5) %196.sub_32bit:gr64_nosp = ADD32rr %196.sub_32bit:gr64_nosp(tied-def 0), %190.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags
              to 
  LiveReg: %190
  UpdateRegP: SU(5) %196.sub_32bit:gr64_nosp = ADD32rr %196.sub_32bit:gr64_nosp(tied-def 0), %190.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags
              to GR16 -2
  Ready @4c
  BotQ.A BotLatency SU(5) 4c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %196:gr64_nosp = SAR64ri %196:gr64_nosp(tied-def 0), 35, implicit-def dead $eflags
Bottom Pressure:
GR16=6
  LiveReg: %196
  UpdateRegP: SU(2) %190:gr64_with_sub_8bit = COPY %196:gr64_nosp
              to GR16 -2
  UpdateRegP: SU(4) %196:gr64_nosp = SAR64ri %196:gr64_nosp(tied-def 0), 35, implicit-def dead $eflags
              to GR16 -2
  Ready @5c
  BotQ.A BotLatency SU(4) 5c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) %190:gr64_with_sub_8bit = SHR64ri %190:gr64_with_sub_8bit(tied-def 0), 63, implicit-def dead $eflags
Bottom Pressure:
GR16=6
  LiveReg: %190
  UpdateRegP: SU(3) %190:gr64_with_sub_8bit = SHR64ri %190:gr64_with_sub_8bit(tied-def 0), 63, implicit-def dead $eflags
              to GR16 -2
  Ready @5c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %190:gr64_with_sub_8bit = COPY %196:gr64_nosp
Bottom Pressure:
GR16=4
  Ready @5c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %196:gr64_nosp = IMUL64rri32 %187:gr64_with_sub_8bit, 1717986919, implicit-def dead $eflags
Bottom Pressure:
GR16=2
  Ready @6c
  BotQ.A BotLatency SU(1) 6c
BotQ.A @1c
  Retired: 7
  Executed: 1c
  Critical: 1c, 7 MOps
  ExpectedLatency: 6c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %187:gr64_with_sub_8bit = MOVSX64rm32 %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
Bottom Pressure:

  Ready @10c
  BotQ.A BotLatency SU(0) 10c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 2c
  Critical: 2c, 8 MOps
  ExpectedLatency: 10c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.22 ***
SU(0):   %187:gr64_with_sub_8bit = MOVSX64rm32 %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
SU(1):   %196:gr64_nosp = IMUL64rri32 %187:gr64_with_sub_8bit, 1717986919, implicit-def dead $eflags
SU(2):   %190:gr64_with_sub_8bit = COPY %196:gr64_nosp
SU(3):   %190:gr64_with_sub_8bit = SHR64ri %190:gr64_with_sub_8bit(tied-def 0), 63, implicit-def dead $eflags
SU(4):   %196:gr64_nosp = SAR64ri %196:gr64_nosp(tied-def 0), 35, implicit-def dead $eflags
SU(5):   %196.sub_32bit:gr64_nosp = ADD32rr %196.sub_32bit:gr64_nosp(tied-def 0), %190.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags
SU(6):   %196.sub_32bit:gr64_nosp = SHL32ri %196.sub_32bit:gr64_nosp(tied-def 0), 2, implicit-def dead $eflags
SU(7):   %198:gr32 = LEA64_32r %196:gr64_nosp, 4, %196:gr64_nosp, 0, $noreg
SU(8):   CMP32rr %187.sub_32bit:gr64_with_sub_8bit, %198:gr32, implicit-def $eflags

********** MI Scheduling **********
main:%bb.24 if.then61
  From: $rdi = MOV32ri64 @.str.29
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.29
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %202:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %202:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.29
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.24 ***
SU(0):   $rdi = MOV32ri64 @.str.29
SU(1):   $esi = COPY %202:gr32
SU(2):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.26 for.end66
  From: %92:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
    To: JCC_1 %bb.27, 5, implicit $eflags
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %92:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=4 Reg=%92
  Single Issue       : false;
SU(1):   %93:fr64 = FsFLD0SD
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(2): Data Latency=1 Reg=%93
  Single Issue       : false;
SU(2):   UCOMISDrr %92:fr64, %93:fr64, implicit-def $eflags
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(1): Data Latency=1 Reg=%93
    SU(0): Data Latency=4 Reg=%92
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.27, 5, implicit $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 5
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) UCOMISDrr %92:fr64, %93:fr64, implicit-def $eflags
  Ready @1c
  BotQ.A TopLatency SU(2) 4c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %93:fr64 = FsFLD0SD
  Ready @2c
  BotQ.A BotLatency SU(1) 2c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %92:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @5c
  BotQ.A BotLatency SU(0) 5c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.26 ***
SU(0):   %92:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
SU(1):   %93:fr64 = FsFLD0SD
SU(2):   UCOMISDrr %92:fr64, %93:fr64, implicit-def $eflags

********** MI Scheduling **********
main:%bb.26 for.end66
  From: %90:gr64 = LEA64r %stack.12.Class, 1, $noreg, 0, $noreg
    To: CALL64pcrel32 @verify, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %90:gr64 = LEA64r %stack.12.Class, 1, $noreg, 0, $noreg
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(3): Data Latency=1 Reg=%90
  Single Issue       : false;
SU(1):   %91:gr64 = LEA64r %stack.11.verified, 1, $noreg, 0, $noreg
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(4): Data Latency=1 Reg=%91
  Single Issue       : false;
SU(2):   $edi = COPY %89:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $rsi = COPY %90:gr64
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(0): Data Latency=1 Reg=%90
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   $rdx = COPY %91:gr64
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%91
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @verify, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=0 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) $rdx = COPY %91:gr64
  Ready @0c
  BotQ.A TopLatency SU(4) 1c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 1 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) $rsi = COPY %90:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) $edi = COPY %89:gr32
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %91:gr64 = LEA64r %stack.11.verified, 1, $noreg, 0, $noreg
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %90:gr64 = LEA64r %stack.12.Class, 1, $noreg, 0, $noreg
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.26 ***
SU(0):   %90:gr64 = LEA64r %stack.12.Class, 1, $noreg, 0, $noreg
SU(1):   %91:gr64 = LEA64r %stack.11.verified, 1, $noreg, 0, $noreg
SU(2):   $edi = COPY %89:gr32
SU(3):   $rsi = COPY %90:gr64
SU(4):   $rdx = COPY %91:gr64

********** MI Scheduling **********
main:%bb.26 for.end66
  From: %88:fr64 = COPY killed $xmm0
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %88:fr64 = COPY killed $xmm0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Data Latency=0 Reg=%88
  Single Issue       : false;
SU(1):   MOVSDmr %stack.9.tmax, 1, $noreg, 0, $noreg, %88:fr64 :: (store 8 into %ir.tmax)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%88
  Single Issue       : false;
SU(2):   %89:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %89:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  Ready @3c
  BotQ.A BotLatency SU(2) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOVSDmr %stack.9.tmax, 1, $noreg, 0, $noreg, %88:fr64 :: (store 8 into %ir.tmax)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %88:fr64 = COPY killed $xmm0
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.26 ***
SU(0):   %88:fr64 = COPY killed $xmm0
SU(1):   MOVSDmr %stack.9.tmax, 1, $noreg, 0, $noreg, %88:fr64 :: (store 8 into %ir.tmax)
SU(2):   %89:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)

********** MI Scheduling **********
main:%bb.27 if.then69
  From: %100:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
    To: JMP_1 %bb.29
 RegionInstrs: 27
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: FR32=3
FR32X=3
GR16=8
Live In: 
Live Out: 
Live Thru: 
Top Pressure:

Bottom Pressure:

Excess PSets: 
SU(0):   %100:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 33
  Successors:
    SU(7): Data Latency=4 Reg=%100
    SU(5): Data Latency=4 Reg=%100
    SU(7): Out  Latency=0
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(1):   %95:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 34
  Successors:
    SU(7): Data Latency=4 Reg=%95
    SU(3): Data Latency=4 Reg=%95
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(2):   %97:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 34
  Successors:
    SU(8): Data Latency=4 Reg=%97
    SU(4): Data Latency=4 Reg=%97
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(3):   %98:gr32 = COPY %95:gr32
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 30
  Predecessors:
    SU(1): Data Latency=4 Reg=%95
  Successors:
    SU(4): Data Latency=0 Reg=%98
    SU(4): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(4):   %98:gr32 = IMUL32rr %98:gr32(tied-def 0), %97:gr32, implicit-def dead $eflags
  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 30
  Predecessors:
    SU(3): Data Latency=0 Reg=%98
    SU(3): Out  Latency=0
    SU(2): Data Latency=4 Reg=%97
  Successors:
    SU(5): Data Latency=1 Reg=%98
    SU(5): Out  Latency=0
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(5):   %98:gr32 = IMUL32rr %98:gr32(tied-def 0), %100:gr32, implicit-def dead $eflags
  # preds left       : 3
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 29
  Predecessors:
    SU(4): Data Latency=1 Reg=%98
    SU(4): Out  Latency=0
    SU(0): Data Latency=4 Reg=%100
  Successors:
    SU(12): Data Latency=1 Reg=%98
    SU(6): Data Latency=1 Reg=%98
    SU(7): Anti Latency=0
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(6):   MOV32mr %stack.6.n3, 1, $noreg, 0, $noreg, %98:gr32 :: (store 4 into %ir.n3)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
    SU(5): Data Latency=1 Reg=%98
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(7):   %100:gr32 = nsw ADD32rr %100:gr32(tied-def 0), %95:gr32, implicit-def dead $eflags
  # preds left       : 4
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 29
  Predecessors:
    SU(5): Anti Latency=0
    SU(1): Data Latency=4 Reg=%95
    SU(0): Data Latency=4 Reg=%100
    SU(0): Out  Latency=0
  Successors:
    SU(8): Data Latency=1 Reg=%100
    SU(8): Out  Latency=0
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(8):   %100:gr32 = nsw ADD32rr %100:gr32(tied-def 0), %97:gr32, implicit-def dead $eflags
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 28
  Predecessors:
    SU(7): Data Latency=1 Reg=%100
    SU(7): Out  Latency=0
    SU(2): Data Latency=4 Reg=%97
  Successors:
    SU(9): Data Latency=1 Reg=%100
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(9):   %108:fr64 = CVTSI2SDrr %100:gr32
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 27
  Predecessors:
    SU(8): Data Latency=1 Reg=%100
  Successors:
    SU(10): Data Latency=1 Reg=%108
    SU(10): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1    GR16 2
  Single Issue       : false;
SU(10):   %108:fr64 = DIVSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  # preds left       : 2
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 4
  Depth              : 8
  Height             : 26
  Predecessors:
    SU(9): Data Latency=1 Reg=%108
    SU(9): Out  Latency=0
  Successors:
    SU(18): Data Latency=4 Reg=%108
    SU(14): Data Latency=4 Reg=%108
    SU(11): Data Latency=4 Reg=%108
    SU(18): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(11):   MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %108:fr64 :: (store 8 into %ir.t)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 20
  Predecessors:
    SU(10): Data Latency=4 Reg=%108
  Successors:
    SU(18): Anti Latency=0
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(12):   %104:fr64 = CVTSI2SDrr %98:gr32
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 22
  Predecessors:
    SU(5): Data Latency=1 Reg=%98
  Successors:
    SU(13): Data Latency=1 Reg=%104
    SU(13): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1    GR16 2
  Single Issue       : false;
SU(13):   %104:fr64 = MULSDrm %104:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 7
  Height             : 21
  Predecessors:
    SU(12): Data Latency=1 Reg=%104
    SU(12): Out  Latency=0
  Successors:
    SU(17): Data Latency=4 Reg=%104
  Pressure Diff      : 
  Single Issue       : false;
SU(14):   %106:fr64 = COPY %108:fr64
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 0
  Depth              : 12
  Height             : 22
  Predecessors:
    SU(10): Data Latency=4 Reg=%108
  Successors:
    SU(15): Data Latency=0 Reg=%106
    SU(15): Out  Latency=0
    SU(18): Anti Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(15):   %106:fr64 = MULSDrr %106:fr64(tied-def 0), %106:fr64
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 22
  Predecessors:
    SU(14): Data Latency=0 Reg=%106
    SU(14): Out  Latency=0
  Successors:
    SU(16): Data Latency=1 Reg=%106
    SU(16): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(16):   %106:fr64 = MULSDrm %106:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 13
  Height             : 21
  Predecessors:
    SU(15): Data Latency=1 Reg=%106
    SU(15): Out  Latency=0
  Successors:
    SU(17): Data Latency=4 Reg=%106
    SU(17): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(17):   %106:fr64 = ADDSDrr %106:fr64(tied-def 0), %104:fr64
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 17
  Height             : 17
  Predecessors:
    SU(16): Data Latency=4 Reg=%106
    SU(16): Out  Latency=0
    SU(13): Data Latency=4 Reg=%104
  Successors:
    SU(19): Data Latency=1 Reg=%106
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(18):   %108:fr64 = MULSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  # preds left       : 4
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 12
  Height             : 20
  Predecessors:
    SU(14): Anti Latency=0
    SU(11): Anti Latency=0
    SU(10): Data Latency=4 Reg=%108
    SU(10): Out  Latency=0
  Successors:
    SU(19): Data Latency=4 Reg=%108
    SU(19): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(19):   %108:fr64 = ADDSDrr %108:fr64(tied-def 0), %106:fr64
  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 18
  Height             : 16
  Predecessors:
    SU(17): Data Latency=1 Reg=%106
    SU(18): Out  Latency=0
    SU(18): Data Latency=4 Reg=%108
  Successors:
    SU(20): Data Latency=1 Reg=%108
    SU(20): Out  Latency=0
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(20):   %108:fr64 = ADDSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 19
  Height             : 15
  Predecessors:
    SU(19): Data Latency=1 Reg=%108
    SU(19): Out  Latency=0
  Successors:
    SU(22): Data Latency=4 Reg=%108
  Pressure Diff      : 
  Single Issue       : false;
SU(21):   %115:fr64 = CVTSI2SDrm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 15
  Successors:
    SU(22): Data Latency=4 Reg=%115
    SU(22): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(22):   %115:fr64 = MULSDrr %115:fr64(tied-def 0), %108:fr64
  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 23
  Height             : 11
  Predecessors:
    SU(20): Data Latency=4 Reg=%108
    SU(21): Out  Latency=0
    SU(21): Data Latency=4 Reg=%115
  Successors:
    SU(25): Data Latency=1 Reg=%115
    SU(25): Out  Latency=0
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(23):   %114:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 18
  Successors:
    SU(24): Data Latency=4 Reg=%114
    SU(24): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(24):   %114:fr64 = MULSDrm %114:fr64(tied-def 0), $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 14
  Predecessors:
    SU(23): Data Latency=4 Reg=%114
    SU(23): Out  Latency=0
  Successors:
    SU(25): Data Latency=4 Reg=%114
  Pressure Diff      : 
  Single Issue       : false;
SU(25):   %115:fr64 = DIVSDrr %115:fr64(tied-def 0), %114:fr64
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 10
  Depth              : 24
  Height             : 10
  Predecessors:
    SU(22): Data Latency=1 Reg=%115
    SU(24): Data Latency=4 Reg=%114
    SU(22): Out  Latency=0
  Successors:
    SU(26): Data Latency=10 Reg=%115
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(26):   MOVSDmr %stack.7.mflops, 1, $noreg, 0, $noreg, %115:fr64 :: (store 8 into %ir.mflops)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 34
  Height             : 0
  Predecessors:
    SU(25): Data Latency=10 Reg=%115
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
ExitSU:   JMP_1 %bb.29
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 34
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 26 6 
  Cand SU(26) ORDER                              
Pick Bot ORDER     
Scheduling SU(26) MOVSDmr %stack.7.mflops, 1, $noreg, 0, $noreg, %115:fr64 :: (store 8 into %ir.mflops)
Bottom Pressure:
FR32=1
FR32X=1
  LiveReg: %115
  UpdateRegP: SU(26) MOVSDmr %stack.7.mflops, 1, $noreg, 0, $noreg, %115:fr64 :: (store 8 into %ir.mflops)
              to 
  Ready @0c
  BotQ.A TopLatency SU(26) 34c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 25 
  Cand SU(6) ORDER                              
  Cand SU(25) ORDER                              
Pick Bot ORDER     
Scheduling SU(25) %115:fr64 = DIVSDrr %115:fr64(tied-def 0), %114:fr64
Bottom Pressure:
FR32=2
FR32X=2
  LiveReg: %115
  UpdateRegP: SU(25) %115:fr64 = DIVSDrr %115:fr64(tied-def 0), %114:fr64
              to 
  LiveReg: %114
  UpdateRegP: SU(25) %115:fr64 = DIVSDrr %115:fr64(tied-def 0), %114:fr64
              to FR32 -1    FR32X -1
  Ready @10c
  BotQ.A BotLatency SU(25) 10c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 10c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 24 22 
  Cand SU(6) ORDER                              
  Cand SU(24) ORDER                              
Pick Bot ORDER     
Scheduling SU(24) %114:fr64 = MULSDrm %114:fr64(tied-def 0), $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
Bottom Pressure:
FR32=2
FR32X=2
  LiveReg: %114
  UpdateRegP: SU(24) %114:fr64 = MULSDrm %114:fr64(tied-def 0), $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
              to FR32 -1    FR32X -1
  Ready @14c
  BotQ.A BotLatency SU(24) 14c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 14c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 22 23 
  Cand SU(6) ORDER                              
  Cand SU(22) ORDER                              
  Cand SU(23) ORDER                              
Pick Bot ORDER     
Scheduling SU(23) %114:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
Bottom Pressure:
FR32=1
FR32X=1
  Ready @18c
  BotQ.A BotLatency SU(23) 18c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 18c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 22 
  Cand SU(6) ORDER                              
  Cand SU(22) ORDER                              
Pick Bot ORDER     
Scheduling SU(22) %115:fr64 = MULSDrr %115:fr64(tied-def 0), %108:fr64
Bottom Pressure:
FR32=2
FR32X=2
  LiveReg: %115
  UpdateRegP: SU(22) %115:fr64 = MULSDrr %115:fr64(tied-def 0), %108:fr64
              to 
  LiveReg: %108
  UpdateRegP: SU(22) %115:fr64 = MULSDrr %115:fr64(tied-def 0), %108:fr64
              to FR32 -1    FR32X -1
  Ready @11c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 18c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 20 21 
  Cand SU(6) ORDER                              
  Cand SU(20) ORDER                              
  Cand SU(21) ORDER                              
Pick Bot ORDER     
Scheduling SU(21) %115:fr64 = CVTSI2SDrm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
Bottom Pressure:
FR32=1
FR32X=1
  Ready @15c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 18c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 20 
  Cand SU(6) ORDER                              
  Cand SU(20) ORDER                              
Pick Bot ORDER     
Scheduling SU(20) %108:fr64 = ADDSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
Bottom Pressure:
FR32=1
FR32X=1
  LiveReg: %108
  UpdateRegP: SU(20) %108:fr64 = ADDSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
              to FR32 -1    FR32X -1
  Ready @15c
BotQ.A @1c
  Retired: 7
  Executed: 1c
  Critical: 1c, 7 MOps
  ExpectedLatency: 18c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 19 
  Cand SU(6) ORDER                              
  Cand SU(19) ORDER                              
Pick Bot ORDER     
Scheduling SU(19) %108:fr64 = ADDSDrr %108:fr64(tied-def 0), %106:fr64
Bottom Pressure:
FR32=2
FR32X=2
  LiveReg: %108
  UpdateRegP: SU(19) %108:fr64 = ADDSDrr %108:fr64(tied-def 0), %106:fr64
              to 
  LiveReg: %106
  UpdateRegP: SU(19) %108:fr64 = ADDSDrr %108:fr64(tied-def 0), %106:fr64
              to FR32 -1    FR32X -1
  Ready @16c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 2c
  Critical: 2c, 8 MOps
  ExpectedLatency: 18c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 17 18 
  Cand SU(6) ORDER                              
  Cand SU(17) ORDER                              
  Cand SU(18) ORDER                              
Pick Bot ORDER     
Scheduling SU(18) %108:fr64 = MULSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
Bottom Pressure:
FR32=2
FR32X=2
  LiveReg: %108
  UpdateRegP: SU(11) MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %108:fr64 :: (store 8 into %ir.t)
              to 
  UpdateRegP: SU(14) %106:fr64 = COPY %108:fr64
              to FR32 -1    FR32X -1
  UpdateRegP: SU(18) %108:fr64 = MULSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
              to FR32 -1    FR32X -1
  Ready @20c
  BotQ.A BotLatency SU(18) 20c
BotQ.A @2c
  Retired: 9
  Executed: 2c
  Critical: 2c, 9 MOps
  ExpectedLatency: 20c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 17 11 
  Cand SU(6) ORDER                              
  Cand SU(17) ORDER                              
Pick Bot ORDER     
Scheduling SU(17) %106:fr64 = ADDSDrr %106:fr64(tied-def 0), %104:fr64
Bottom Pressure:
FR32=3
FR32X=3
  LiveReg: %106
  UpdateRegP: SU(17) %106:fr64 = ADDSDrr %106:fr64(tied-def 0), %104:fr64
              to 
  LiveReg: %104
  UpdateRegP: SU(17) %106:fr64 = ADDSDrr %106:fr64(tied-def 0), %104:fr64
              to FR32 -1    FR32X -1
  Ready @17c
BotQ.A @2c
  Retired: 10
  Executed: 2c
  Critical: 2c, 10 MOps
  ExpectedLatency: 20c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 11 16 13 
  Cand SU(6) ORDER                              
  Cand SU(11) ORDER                              
  Cand SU(16) ORDER                              
Pick Bot ORDER     
Scheduling SU(16) %106:fr64 = MULSDrm %106:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
Bottom Pressure:
FR32=3
FR32X=3
  LiveReg: %106
  UpdateRegP: SU(16) %106:fr64 = MULSDrm %106:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
              to FR32 -1    FR32X -1
  Ready @21c
  BotQ.A BotLatency SU(16) 21c
BotQ.A @2c
  Retired: 11
  Executed: 2c
  Critical: 2c, 11 MOps
  ExpectedLatency: 21c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 11 13 15 
  Cand SU(6) ORDER                              
  Cand SU(11) ORDER                              
  Cand SU(13) ORDER                              
  Cand SU(15) ORDER                              
Pick Bot ORDER     
Scheduling SU(15) %106:fr64 = MULSDrr %106:fr64(tied-def 0), %106:fr64
Bottom Pressure:
FR32=3
FR32X=3
  LiveReg: %106
  UpdateRegP: SU(15) %106:fr64 = MULSDrr %106:fr64(tied-def 0), %106:fr64
              to FR32 -1    FR32X -1
  Ready @22c
  BotQ.A BotLatency SU(15) 22c
  *** Max MOps 4 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 12
  Executed: 3c
  Critical: 3c, 12 MOps
  ExpectedLatency: 22c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 11 13 14 
  Cand SU(6) ORDER                              
  Cand SU(11) ORDER                              
  Cand SU(13) ORDER                              
  Cand SU(14) ORDER                              
Pick Bot ORDER     
Scheduling SU(14) %106:fr64 = COPY %108:fr64
Bottom Pressure:
FR32=2
FR32X=2
  Ready @22c
BotQ.A @3c
  Retired: 12
  Executed: 3c
  Critical: 3c, 12 MOps
  ExpectedLatency: 22c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 11 13 
  Cand SU(6) ORDER                              
  Cand SU(11) ORDER                              
  Cand SU(13) ORDER                              
Pick Bot ORDER     
Scheduling SU(13) %104:fr64 = MULSDrm %104:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
Bottom Pressure:
FR32=2
FR32X=2
  LiveReg: %104
  UpdateRegP: SU(13) %104:fr64 = MULSDrm %104:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
              to FR32 -1    FR32X -1
  Ready @21c
BotQ.A @3c
  Retired: 13
  Executed: 3c
  Critical: 3c, 13 MOps
  ExpectedLatency: 22c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 11 12 
  Cand SU(6) ORDER                              
  Cand SU(11) ORDER                              
  Cand SU(12) ORDER                              
Pick Bot ORDER     
Scheduling SU(12) %104:fr64 = CVTSI2SDrr %98:gr32
Bottom Pressure:
FR32=1
FR32X=1
GR16=2
  LiveReg: %98
  UpdateRegP: SU(6) MOV32mr %stack.6.n3, 1, $noreg, 0, $noreg, %98:gr32 :: (store 4 into %ir.n3)
              to 
  UpdateRegP: SU(12) %104:fr64 = CVTSI2SDrr %98:gr32
              to FR32 -1    FR32X -1
  Ready @22c
BotQ.A @3c
  Retired: 14
  Executed: 3c
  Critical: 3c, 14 MOps
  ExpectedLatency: 22c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 11 
  Cand SU(6) ORDER                              
  Cand SU(11) ORDER                              
Pick Bot ORDER     
Scheduling SU(11) MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %108:fr64 :: (store 8 into %ir.t)
Bottom Pressure:
FR32=1
FR32X=1
GR16=2
  Ready @20c
BotQ.A @3c
  Retired: 15
  Executed: 3c
  Critical: 3c, 15 MOps
  ExpectedLatency: 22c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 10 
  Cand SU(6) ORDER                              
  Cand SU(10) ORDER                              
Pick Bot ORDER     
Scheduling SU(10) %108:fr64 = DIVSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
Bottom Pressure:
FR32=1
FR32X=1
GR16=2
  LiveReg: %108
  UpdateRegP: SU(10) %108:fr64 = DIVSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
              to FR32 -1    FR32X -1
  Ready @26c
  BotQ.A BotLatency SU(10) 26c
  *** Max MOps 4 at cycle 3
Cycle: 4 BotQ.A
BotQ.A @4c
  Retired: 16
  Executed: 4c
  Critical: 4c, 16 MOps
  ExpectedLatency: 26c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 9 
  Cand SU(6) ORDER                              
  Cand SU(9) ORDER                              
Pick Bot ORDER     
Scheduling SU(9) %108:fr64 = CVTSI2SDrr %100:gr32
Bottom Pressure:
GR16=4
  LiveReg: %100
  UpdateRegP: SU(9) %108:fr64 = CVTSI2SDrr %100:gr32
              to FR32 -1    FR32X -1
  Ready @27c
  BotQ.A BotLatency SU(9) 27c
BotQ.A @4c
  Retired: 17
  Executed: 4c
  Critical: 4c, 17 MOps
  ExpectedLatency: 27c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 8 
  Cand SU(6) ORDER                              
  Cand SU(8) ORDER                              
Pick Bot ORDER     
Scheduling SU(8) %100:gr32 = nsw ADD32rr %100:gr32(tied-def 0), %97:gr32, implicit-def dead $eflags
Bottom Pressure:
GR16=6
  LiveReg: %100
  UpdateRegP: SU(8) %100:gr32 = nsw ADD32rr %100:gr32(tied-def 0), %97:gr32, implicit-def dead $eflags
              to 
  LiveReg: %97
  UpdateRegP: SU(4) %98:gr32 = IMUL32rr %98:gr32(tied-def 0), %97:gr32, implicit-def dead $eflags
              to 
  UpdateRegP: SU(8) %100:gr32 = nsw ADD32rr %100:gr32(tied-def 0), %97:gr32, implicit-def dead $eflags
              to GR16 -2
  Ready @28c
  BotQ.A BotLatency SU(8) 28c
BotQ.A @4c
  Retired: 18
  Executed: 4c
  Critical: 4c, 18 MOps
  ExpectedLatency: 28c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 7 
  Cand SU(6) ORDER                              
  Cand SU(7) ORDER                              
Pick Bot ORDER     
Scheduling SU(7) %100:gr32 = nsw ADD32rr %100:gr32(tied-def 0), %95:gr32, implicit-def dead $eflags
Bottom Pressure:
GR16=8
  LiveReg: %100
  UpdateRegP: SU(5) %98:gr32 = IMUL32rr %98:gr32(tied-def 0), %100:gr32, implicit-def dead $eflags
              to 
  UpdateRegP: SU(7) %100:gr32 = nsw ADD32rr %100:gr32(tied-def 0), %95:gr32, implicit-def dead $eflags
              to 
  LiveReg: %95
  UpdateRegP: SU(3) %98:gr32 = COPY %95:gr32
              to GR16 -2
  UpdateRegP: SU(7) %100:gr32 = nsw ADD32rr %100:gr32(tied-def 0), %95:gr32, implicit-def dead $eflags
              to GR16 -2
  Ready @29c
  BotQ.A BotLatency SU(7) 29c
BotQ.A @4c
  Retired: 19
  Executed: 4c
  Critical: 4c, 19 MOps
  ExpectedLatency: 29c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 
Scheduling SU(6) MOV32mr %stack.6.n3, 1, $noreg, 0, $noreg, %98:gr32 :: (store 4 into %ir.n3)
Bottom Pressure:
GR16=8
  Ready @4c
  *** Max MOps 4 at cycle 4
Cycle: 5 BotQ.A
BotQ.A @5c
  Retired: 20
  Executed: 5c
  Critical: 5c, 20 MOps
  ExpectedLatency: 29c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 
Scheduling SU(5) %98:gr32 = IMUL32rr %98:gr32(tied-def 0), %100:gr32, implicit-def dead $eflags
Bottom Pressure:
GR16=8
  LiveReg: %98
  UpdateRegP: SU(5) %98:gr32 = IMUL32rr %98:gr32(tied-def 0), %100:gr32, implicit-def dead $eflags
              to GR16 -2
  Ready @29c
BotQ.A @5c
  Retired: 21
  Executed: 5c
  Critical: 5c, 21 MOps
  ExpectedLatency: 29c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 0 
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %98:gr32 = IMUL32rr %98:gr32(tied-def 0), %97:gr32, implicit-def dead $eflags
Bottom Pressure:
GR16=8
  LiveReg: %98
  UpdateRegP: SU(4) %98:gr32 = IMUL32rr %98:gr32(tied-def 0), %97:gr32, implicit-def dead $eflags
              to GR16 -2
  Ready @30c
  BotQ.A BotLatency SU(4) 30c
BotQ.A @5c
  Retired: 22
  Executed: 5c
  Critical: 5c, 22 MOps
  ExpectedLatency: 30c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 
  Cand SU(0) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %98:gr32 = COPY %95:gr32
Bottom Pressure:
GR16=6
  Ready @30c
BotQ.A @5c
  Retired: 22
  Executed: 5c
  Critical: 5c, 22 MOps
  ExpectedLatency: 30c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 1 
  Cand SU(0) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %97:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
Bottom Pressure:
GR16=4
  Ready @34c
  BotQ.A BotLatency SU(2) 34c
BotQ.A @5c
  Retired: 23
  Executed: 5c
  Critical: 5c, 23 MOps
  ExpectedLatency: 34c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %95:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
Bottom Pressure:
GR16=2
  Ready @34c
  *** Max MOps 4 at cycle 5
Cycle: 6 BotQ.A
BotQ.A @6c
  Retired: 24
  Executed: 6c
  Critical: 6c, 24 MOps
  ExpectedLatency: 34c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %100:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
Bottom Pressure:

  Ready @33c
BotQ.A @6c
  Retired: 25
  Executed: 6c
  Critical: 6c, 25 MOps
  ExpectedLatency: 34c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.27 ***
SU(0):   %100:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
SU(1):   %95:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
SU(2):   %97:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
SU(3):   %98:gr32 = COPY %95:gr32
SU(4):   %98:gr32 = IMUL32rr %98:gr32(tied-def 0), %97:gr32, implicit-def dead $eflags
SU(5):   %98:gr32 = IMUL32rr %98:gr32(tied-def 0), %100:gr32, implicit-def dead $eflags
SU(6):   MOV32mr %stack.6.n3, 1, $noreg, 0, $noreg, %98:gr32 :: (store 4 into %ir.n3)
SU(7):   %100:gr32 = nsw ADD32rr %100:gr32(tied-def 0), %95:gr32, implicit-def dead $eflags
SU(8):   %100:gr32 = nsw ADD32rr %100:gr32(tied-def 0), %97:gr32, implicit-def dead $eflags
SU(9):   %108:fr64 = CVTSI2SDrr %100:gr32
SU(10):   %108:fr64 = DIVSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
SU(11):   MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %108:fr64 :: (store 8 into %ir.t)
SU(12):   %104:fr64 = CVTSI2SDrr %98:gr32
SU(13):   %104:fr64 = MULSDrm %104:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
SU(14):   %106:fr64 = COPY %108:fr64
SU(15):   %106:fr64 = MULSDrr %106:fr64(tied-def 0), %106:fr64
SU(16):   %106:fr64 = MULSDrm %106:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
SU(17):   %106:fr64 = ADDSDrr %106:fr64(tied-def 0), %104:fr64
SU(18):   %108:fr64 = MULSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
SU(19):   %108:fr64 = ADDSDrr %108:fr64(tied-def 0), %106:fr64
SU(20):   %108:fr64 = ADDSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
SU(21):   %115:fr64 = CVTSI2SDrm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
SU(22):   %115:fr64 = MULSDrr %115:fr64(tied-def 0), %108:fr64
SU(23):   %114:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
SU(24):   %114:fr64 = MULSDrm %114:fr64(tied-def 0), $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
SU(25):   %115:fr64 = DIVSDrr %115:fr64(tied-def 0), %114:fr64
SU(26):   MOVSDmr %stack.7.mflops, 1, $noreg, 0, $noreg, %115:fr64 :: (store 8 into %ir.mflops)

********** MI Scheduling **********
main:%bb.29 if.end85
  From: $rdi = MOV32ri64 @.str.30
    To: PUSH64i32 @.str.40, implicit-def $rsp, implicit $rsp
 RegionInstrs: 8
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=6
GR32_BPSP+GR64_TCW64=6
GR8=8
GR8+GR32_DIBP=8
GR8+GR32_BSI=8
GR64_TC+GR64_TCW64=8
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=8
GR8+GR64_NOREX=8
GR64_TC=8
GR8+GR64_TCW64=8
GR8+GR64_TC=8
FR32X=2
GR16=11
Live In: %122 %121 %120 %119 %118 %117 %116 
Live Out: XMM1 XMM0 R9B R9BH R9WH R8B R8BH R8WH CH CL HCX DH DL HDX SIL SIH HSI DIL DIH HDI 
Live Thru: 
Top Pressure:
FR32=2
FR32X=2
GR16=10
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=6
GR32_BPSP+GR64_TCW64=6
GR8=8
GR8+GR32_DIBP=8
GR8+GR32_BSI=8
GR64_TC+GR64_TCW64=8
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=8
GR8+GR64_NOREX=8
GR64_TC=8
GR8+GR64_TCW64=8
GR8+GR64_TC=8
FR32X=2
GR16=8
Excess PSets: 
SU(0):   $rdi = MOV32ri64 @.str.30
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR32_BPSP -1    GR32_SIDI -1    GR32_DIBP+GR32_SIDI -1    GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR64_NOREX -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1    GR16 -1
  Single Issue       : false;
SU(1):   $esi = COPY %116:gr32
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR32_BSI -1    GR32_SIDI -1    GR32_DIBP+GR32_SIDI -1    GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -1    GR64_NOREX -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1
  Single Issue       : false;
SU(2):   $edx = COPY %117:gr32
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -2    GR32_TC -2    GR32_BPSP+GR32_TC -2    GR64_NOREX -2    GR64_TCW64 -2    GR32_BPSP+GR64_TCW64 -2    GR8 -2    GR8+GR32_DIBP -2    GR8+GR32_BSI -2    GR64_TC+GR64_TCW64 -2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -2    GR8+GR64_NOREX -2    GR64_TC -2    GR8+GR64_TCW64 -2
  Single Issue       : false;
SU(3):   $ecx = COPY %118:gr32
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR32_BSI -2    GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -2    GR32_TC -2    GR32_BPSP+GR32_TC -2    GR64_NOREX -2    GR64_TCW64 -2    GR32_BPSP+GR64_TCW64 -2    GR8 -2    GR8+GR32_DIBP -2    GR8+GR32_BSI -2    GR64_TC+GR64_TCW64 -2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -2    GR8+GR64_NOREX -2    GR64_TC -2
  Single Issue       : false;
SU(4):   $r8d = COPY %119:gr32
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR64_TCW64 -1    GR32_BPSP+GR64_TCW64 -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1    GR16 1
  Single Issue       : false;
SU(5):   $r9d = COPY %120:gr32
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR64_TCW64 -1    GR32_BPSP+GR64_TCW64 -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1    GR16 1
  Single Issue       : false;
SU(6):   $xmm0 = COPY %121:fr64
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   $xmm1 = COPY %122:fr64
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : 
  Single Issue       : false;
ExitSU:   PUSH64i32 @.str.40, implicit-def $rsp, implicit $rsp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 6 5 4 3 2 1 0 
  Cand SU(7) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(7) $xmm1 = COPY %122:fr64
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=6
GR32_BPSP+GR64_TCW64=6
GR8=8
GR8+GR32_DIBP=8
GR8+GR32_BSI=8
GR64_TC+GR64_TCW64=8
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=8
GR8+GR64_NOREX=8
GR64_TC=8
GR8+GR64_TCW64=8
GR8+GR64_TC=8
FR32X=2
GR16=8
  LiveReg: %122
  UpdateRegP: SU(7) $xmm1 = COPY %122:fr64
              to FR32 -1    FR32X -1
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 6 5 4 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(6) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(6) $xmm0 = COPY %121:fr64
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=6
GR32_BPSP+GR64_TCW64=6
GR8=8
GR8+GR32_DIBP=8
GR8+GR32_BSI=8
GR64_TC+GR64_TCW64=8
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=8
GR8+GR64_NOREX=8
GR64_TC=8
GR8+GR64_TCW64=8
GR8+GR64_TC=8
FR32X=2
GR16=8
  LiveReg: %121
  UpdateRegP: SU(6) $xmm0 = COPY %121:fr64
              to FR32 -1    FR32X -1
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 5 4 3 2 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) $r9d = COPY %120:gr32
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=5
GR32_BPSP+GR64_TCW64=5
GR8=7
GR8+GR32_DIBP=7
GR8+GR32_BSI=7
GR64_TC+GR64_TCW64=7
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=7
GR8+GR64_NOREX=7
GR64_TC=7
GR8+GR64_TCW64=7
GR8+GR64_TC=7
FR32X=2
GR16=9
  LiveReg: %120
  UpdateRegP: SU(5) $r9d = COPY %120:gr32
              to GR64_TCW64 -1    GR32_BPSP+GR64_TCW64 -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1    GR16 -1
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 4 3 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) $r8d = COPY %119:gr32
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=4
GR32_BPSP+GR64_TCW64=4
GR8=6
GR8+GR32_DIBP=6
GR8+GR32_BSI=6
GR64_TC+GR64_TCW64=6
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=6
GR8+GR64_NOREX=6
GR64_TC=6
GR8+GR64_TCW64=6
GR8+GR64_TC=6
FR32X=2
GR16=10
  LiveReg: %119
  UpdateRegP: SU(4) $r8d = COPY %119:gr32
              to GR64_TCW64 -1    GR32_BPSP+GR64_TCW64 -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1    GR16 -1
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 3 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) $ecx = COPY %118:gr32
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=1
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=2
GR8_ABCD_L+GR32_BSI=2
GR8_NOREX=3
GR32_TC=2
GR32_BPSP+GR32_TC=2
FR32=2
GR64_NOREX=4
GR64_TCW64=2
GR32_BPSP+GR64_TCW64=2
GR8=4
GR8+GR32_DIBP=4
GR8+GR32_BSI=4
GR64_TC+GR64_TCW64=4
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=4
GR8+GR64_NOREX=4
GR64_TC=4
GR8+GR64_TCW64=4
GR8+GR64_TC=4
FR32X=2
GR16=10
  GR8_NOREX: 5 <= 6(+ 0 livethru)
  LiveReg: %118
  UpdateRegP: SU(3) $ecx = COPY %118:gr32
              to GR32_BSI -2    GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -2    GR32_TC -2    GR32_BPSP+GR32_TC -2    GR64_NOREX -2    GR64_TCW64 -2    GR32_BPSP+GR64_TCW64 -2    GR8 -2    GR8+GR32_DIBP -2    GR8+GR32_BSI -2    GR64_TC+GR64_TCW64 -2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -2    GR8+GR64_NOREX -2    GR64_TC -2
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $edx = COPY %117:gr32
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=1
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=1
GR8_ABCD_L+GR32_BSI=1
GR8_NOREX=1
FR32=2
GR64_NOREX=2
GR8=2
GR8+GR32_DIBP=2
GR8+GR32_BSI=2
GR64_TC+GR64_TCW64=2
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=2
GR8+GR64_NOREX=2
GR64_TC=2
GR8+GR64_TCW64=2
GR8+GR64_TC=2
FR32X=2
GR16=10
  GR8_NOREX: 5 <= 6(+ 0 livethru)
  LiveReg: %117
  UpdateRegP: SU(2) $edx = COPY %117:gr32
              to GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -2    GR32_TC -2    GR32_BPSP+GR32_TC -2    GR64_NOREX -2    GR64_TCW64 -2    GR32_BPSP+GR64_TCW64 -2    GR8 -2    GR8+GR32_DIBP -2    GR8+GR32_BSI -2    GR64_TC+GR64_TCW64 -2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -2    GR8+GR64_NOREX -2    GR64_TC -2    GR8+GR64_TCW64 -2
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %116:gr32
Bottom Pressure:
GR32_BPSP=1
GR32_SIDI=1
GR32_DIBP+GR32_SIDI=1
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
FR32=2
GR64_NOREX=1
GR8=1
GR8+GR32_DIBP=1
GR8+GR32_BSI=1
GR64_TC+GR64_TCW64=1
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8+GR64_NOREX=1
GR64_TC=1
GR8+GR64_TCW64=1
GR8+GR64_TC=1
FR32X=2
GR16=11
  GR32_DIBP+GR32_SIDI: 2 <= 4(+ 0 livethru)
  GR8_NOREX: 5 <= 6(+ 0 livethru)
  LiveReg: %116
  UpdateRegP: SU(1) $esi = COPY %116:gr32
              to GR32_BSI -1    GR32_SIDI -1    GR32_DIBP+GR32_SIDI -1    GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -1    GR64_NOREX -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.30
Bottom Pressure:
FR32=2
FR32X=2
GR16=10
  GR32_BPSP: 1 <= 2(+ 0 livethru)
  GR32_DIBP+GR32_SIDI: 2 <= 4(+ 0 livethru)
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.29 ***
SU(0):   $rdi = MOV32ri64 @.str.30
SU(1):   $esi = COPY %116:gr32
SU(2):   $edx = COPY %117:gr32
SU(3):   $ecx = COPY %118:gr32
SU(4):   $r8d = COPY %119:gr32
SU(5):   $r9d = COPY %120:gr32
SU(6):   $xmm0 = COPY %121:fr64
SU(7):   $xmm1 = COPY %122:fr64

********** MI Scheduling **********
main:%bb.29 if.end85
  From: %116:gr32 = MOVSX32rm8 %stack.12.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
    To: ADJCALLSTACKDOWN64 88, 0, 88, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 8
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: FR32=2
FR32X=2
GR16=12
Live In: 
Live Out: %226 %122 %121 %120 %119 %118 %117 %116 
Live Thru: 
  LiveReg: %226
  LiveReg: %122
  LiveReg: %121
  LiveReg: %120
  LiveReg: %119
  LiveReg: %118
  LiveReg: %117
  LiveReg: %116
Top Pressure:

Bottom Pressure:
FR32=2
FR32X=2
GR16=12
Excess PSets: 
SU(0):   %116:gr32 = MOVSX32rm8 %stack.12.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(1):   %117:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(2):   %118:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(3):   %119:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(4):   %120:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(5):   %121:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(6):   %122:fr64 = MOVSDrm_alt %stack.7.mflops, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.mflops)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(7):   undef %226.sub_32bit:gr64_with_sub_8bit = MOV32rm %stack.11.verified, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.verified)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 88, 0, 88, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 8
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(7): Ord  Latency=3 Artificial
    SU(6): Ord  Latency=3 Artificial
    SU(5): Ord  Latency=3 Artificial
    SU(4): Ord  Latency=3 Artificial
    SU(3): Ord  Latency=3 Artificial
    SU(2): Ord  Latency=3 Artificial
    SU(1): Ord  Latency=3 Artificial
    SU(0): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 6 5 4 3 2 1 0 
  Cand SU(7) ORDER                              
Pick Bot ORDER     
Scheduling SU(7) undef %226.sub_32bit:gr64_with_sub_8bit = MOV32rm %stack.11.verified, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.verified)
Bottom Pressure:
FR32=2
FR32X=2
GR16=10
  Ready @3c
  BotQ.A BotLatency SU(7) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 6 5 4 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) %122:fr64 = MOVSDrm_alt %stack.7.mflops, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.mflops)
Bottom Pressure:
FR32=1
FR32X=1
GR16=10
  Ready @3c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 5 4 3 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %121:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
Bottom Pressure:
GR16=10
  Ready @3c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 4 3 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %120:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
Bottom Pressure:
GR16=8
  Ready @3c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 3 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %119:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
Bottom Pressure:
GR16=6
  Ready @3c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %118:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
Bottom Pressure:
GR16=4
  Ready @3c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %117:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
Bottom Pressure:
GR16=2
  Ready @3c
BotQ.A @1c
  Retired: 7
  Executed: 1c
  Critical: 1c, 7 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %116:gr32 = MOVSX32rm8 %stack.12.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
Bottom Pressure:

  Ready @3c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 2c
  Critical: 2c, 8 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.29 ***
SU(0):   %116:gr32 = MOVSX32rm8 %stack.12.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
SU(1):   %117:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
SU(2):   %118:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
SU(3):   %119:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
SU(4):   %120:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
SU(5):   %121:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
SU(6):   %122:fr64 = MOVSDrm_alt %stack.7.mflops, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.mflops)
SU(7):   undef %226.sub_32bit:gr64_with_sub_8bit = MOV32rm %stack.11.verified, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.verified)

********** MI Scheduling **********
main:%bb.32 for.body90
  From: %185:fr64 = COPY killed $xmm0
    To: JMP_1 %bb.31
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %185:fr64 = COPY killed $xmm0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(2): Data Latency=0 Reg=%185
  Single Issue       : false;
SU(1):   %186:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 4
  Successors:
    SU(2): Data Latency=4 Reg=%186
    SU(3): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOVSDmr %stack.10.trecs, 8, %186:gr64_nosp, 0, $noreg, %185:fr64 :: (store 8 into %ir.arrayidx92)
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Data Latency=4 Reg=%186
    SU(0): Data Latency=0 Reg=%185
  Single Issue       : false;
SU(3):   INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Predecessors:
    SU(1): Ord  Latency=0 Memory
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   JMP_1 %bb.31
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 4
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  Ready @3c
  BotQ.A BotLatency SU(3) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOVSDmr %stack.10.trecs, 8, %186:gr64_nosp, 0, $noreg, %185:fr64 :: (store 8 into %ir.arrayidx92)
  Ready @0c
  BotQ.A TopLatency SU(2) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) %186:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  Ready @4c
  BotQ.A BotLatency SU(1) 4c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %185:fr64 = COPY killed $xmm0
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.32 ***
SU(0):   %185:fr64 = COPY killed $xmm0
SU(1):   %186:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
SU(2):   MOVSDmr %stack.10.trecs, 8, %186:gr64_nosp, 0, $noreg, %185:fr64 :: (store 8 into %ir.arrayidx92)
SU(3):   INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)

********** MI Scheduling **********
main:%bb.33 for.end95
  From: %128:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
    To: JCC_1 %bb.35, 5, implicit $eflags
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %128:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=4 Reg=%128
  Single Issue       : false;
SU(1):   %129:fr64 = FsFLD0SD
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(2): Data Latency=1 Reg=%129
  Single Issue       : false;
SU(2):   UCOMISDrr %128:fr64, %129:fr64, implicit-def $eflags
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(1): Data Latency=1 Reg=%129
    SU(0): Data Latency=4 Reg=%128
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.35, 5, implicit $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 5
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) UCOMISDrr %128:fr64, %129:fr64, implicit-def $eflags
  Ready @1c
  BotQ.A TopLatency SU(2) 4c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %129:fr64 = FsFLD0SD
  Ready @2c
  BotQ.A BotLatency SU(1) 2c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %128:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @5c
  BotQ.A BotLatency SU(0) 5c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.33 ***
SU(0):   %128:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
SU(1):   %129:fr64 = FsFLD0SD
SU(2):   UCOMISDrr %128:fr64, %129:fr64, implicit-def $eflags

********** MI Scheduling **********
main:%bb.34 if.then98
  From: %130:gr64 = MOV64ri 4607182418800017408
    To: End RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %130:gr64 = MOV64ri 4607182418800017408
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=1 Reg=%130
  Single Issue       : false;
SU(1):   MOV64mr %stack.9.tmax, 1, $noreg, 0, $noreg, %130:gr64 :: (store 8 into %ir.tmax)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(0): Data Latency=1 Reg=%130
  Single Issue       : false;
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %stack.9.tmax, 1, $noreg, 0, $noreg, %130:gr64 :: (store 8 into %ir.tmax)
  Ready @0c
  BotQ.A TopLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %130:gr64 = MOV64ri 4607182418800017408
  Ready @1c
  BotQ.A BotLatency SU(0) 1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.34 ***
SU(0):   %130:gr64 = MOV64ri 4607182418800017408
SU(1):   MOV64mr %stack.9.tmax, 1, $noreg, 0, $noreg, %130:gr64 :: (store 8 into %ir.tmax)

********** MI Scheduling **********
main:%bb.35 if.end99
  From: MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
    To: End RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   %222:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.6, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %222:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.6, $noreg :: (load 8 from constant-pool)
  Ready @3c
  BotQ.A BotLatency SU(1) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.35 ***
SU(0):   MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
SU(1):   %222:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.6, $noreg :: (load 8 from constant-pool)

********** MI Scheduling **********
main:%bb.35 if.end99
  From: $rdi = MOV32ri64 @.str.41
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.41
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.41
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.35 ***
SU(0):   $rdi = MOV32ri64 @.str.41
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.37 for.body104
  From: $rdi = MOV32ri64 @.str.42
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.42
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %138:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %139:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $xmm1 = COPY %141:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   $al = MOV8ri 2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) $al = MOV8ri 2
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $xmm1 = COPY %141:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $xmm0 = COPY %139:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $rsi = COPY %138:gr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.42
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.37 ***
SU(0):   $rdi = MOV32ri64 @.str.42
SU(1):   $rsi = COPY %138:gr64
SU(2):   $xmm0 = COPY %139:fr64
SU(3):   $xmm1 = COPY %141:fr64
SU(4):   $al = MOV8ri 2

********** MI Scheduling **********
main:%bb.37 for.body104
  From: %137:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %137:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 12
  Successors:
    SU(2): Data Latency=4 Reg=%137
    SU(1): Data Latency=4 Reg=%137
  Single Issue       : false;
SU(1):   %138:gr64 = MOV64rm %stack.13.t_names, 8, %137:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx106)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 3
  Predecessors:
    SU(0): Data Latency=4 Reg=%137
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
SU(2):   %139:fr64 = MOVSDrm_alt %stack.10.trecs, 8, %137:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx110)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 8
  Predecessors:
    SU(0): Data Latency=4 Reg=%137
  Successors:
    SU(3): Data Latency=4 Reg=%139
  Single Issue       : false;
SU(3):   %141:fr64 = COPY %139:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(2): Data Latency=4 Reg=%139
  Successors:
    SU(4): Data Latency=0 Reg=%141
    SU(4): Out  Latency=0
  Single Issue       : false;
SU(4):   %141:fr64 = MULSDrr %141:fr64(tied-def 0), %222:fr64
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(3): Data Latency=0 Reg=%141
    SU(3): Out  Latency=0
  Successors:
    SU(5): Data Latency=1 Reg=%141
    SU(5): Out  Latency=0
  Single Issue       : false;
SU(5):   %141:fr64 = DIVSDrm %141:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 9
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1 Reg=%141
    SU(4): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=3 Artificial
    SU(1): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 12
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 1 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %141:fr64 = DIVSDrm %141:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @3c
  BotQ.A TopLatency SU(5) 9c
  BotQ.A BotLatency SU(5) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 4 
  Cand SU(1) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %141:fr64 = MULSDrr %141:fr64(tied-def 0), %222:fr64
  Ready @4c
  BotQ.A BotLatency SU(4) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 3 
  Cand SU(1) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %141:fr64 = COPY %139:fr64
  Ready @4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %139:fr64 = MOVSDrm_alt %stack.10.trecs, 8, %137:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx110)
  Ready @8c
  BotQ.A BotLatency SU(2) 8c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %138:gr64 = MOV64rm %stack.13.t_names, 8, %137:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx106)
  Ready @3c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %137:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  Ready @12c
  BotQ.A BotLatency SU(0) 12c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.37 ***
SU(0):   %137:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
SU(1):   %138:gr64 = MOV64rm %stack.13.t_names, 8, %137:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx106)
SU(2):   %139:fr64 = MOVSDrm_alt %stack.10.trecs, 8, %137:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx110)
SU(3):   %141:fr64 = COPY %139:fr64
SU(4):   %141:fr64 = MULSDrr %141:fr64(tied-def 0), %222:fr64
SU(5):   %141:fr64 = DIVSDrm %141:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)

********** MI Scheduling **********
main:%bb.38 if.then116
  From: $rdi = MOV32ri64 @.str.43
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.43
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.45
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %179:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $xmm1 = COPY %181:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   $al = MOV8ri 2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) $al = MOV8ri 2
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $xmm1 = COPY %181:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) $xmm0 = COPY %179:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.45
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.43
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.38 ***
SU(0):   $rdi = MOV32ri64 @.str.43
SU(1):   $rsi = MOV32ri64 @.str.45
SU(2):   $xmm0 = COPY %179:fr64
SU(3):   $xmm1 = COPY %181:fr64
SU(4):   $al = MOV8ri 2

********** MI Scheduling **********
main:%bb.38 if.then116
  From: %179:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx125)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %179:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx125)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 12
  Successors:
    SU(1): Data Latency=4 Reg=%179
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %179:fr64 = SUBSDrm %179:fr64(tied-def 0), %stack.8.t, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.t)
  # preds left       : 2
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 8
  Predecessors:
    SU(0): Data Latency=4 Reg=%179
    SU(0): Out  Latency=0
  Successors:
    SU(3): Data Latency=4 Reg=%179
    SU(2): Data Latency=4 Reg=%179
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %179:fr64 :: (store 8 into %ir.t)
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Data Latency=4 Reg=%179
    SU(1): Ord  Latency=0 Memory
  Single Issue       : false;
SU(3):   %181:fr64 = COPY %179:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(1): Data Latency=4 Reg=%179
  Successors:
    SU(4): Data Latency=0 Reg=%181
    SU(4): Out  Latency=0
  Single Issue       : false;
SU(4):   %181:fr64 = MULSDrr %181:fr64(tied-def 0), %222:fr64
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(3): Data Latency=0 Reg=%181
    SU(3): Out  Latency=0
  Successors:
    SU(5): Data Latency=1 Reg=%181
    SU(5): Out  Latency=0
  Single Issue       : false;
SU(5):   %181:fr64 = DIVSDrm %181:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 9
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1 Reg=%181
    SU(4): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 12
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 5 
  Cand SU(2) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %181:fr64 = DIVSDrm %181:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @3c
  BotQ.A TopLatency SU(5) 9c
  BotQ.A BotLatency SU(5) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 4 
  Cand SU(2) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %181:fr64 = MULSDrr %181:fr64(tied-def 0), %222:fr64
  Ready @4c
  BotQ.A BotLatency SU(4) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %181:fr64 = COPY %179:fr64
  Ready @4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %179:fr64 :: (store 8 into %ir.t)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %179:fr64 = SUBSDrm %179:fr64(tied-def 0), %stack.8.t, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.t)
  Ready @8c
  BotQ.A BotLatency SU(1) 8c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %179:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx125)
  Ready @12c
  BotQ.A BotLatency SU(0) 12c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.38 ***
SU(0):   %179:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx125)
SU(1):   %179:fr64 = SUBSDrm %179:fr64(tied-def 0), %stack.8.t, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.t)
SU(2):   MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %179:fr64 :: (store 8 into %ir.t)
SU(3):   %181:fr64 = COPY %179:fr64
SU(4):   %181:fr64 = MULSDrr %181:fr64(tied-def 0), %222:fr64
SU(5):   %181:fr64 = DIVSDrm %181:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)

********** MI Scheduling **********
main:%bb.38 if.then116
  From: $rdi = MOV32ri64 @.str.43
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.43
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.44
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %170:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $xmm1 = COPY %173:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   $al = MOV8ri 2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) $al = MOV8ri 2
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $xmm1 = COPY %173:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) $xmm0 = COPY %170:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.44
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.43
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.38 ***
SU(0):   $rdi = MOV32ri64 @.str.43
SU(1):   $rsi = MOV32ri64 @.str.44
SU(2):   $xmm0 = COPY %170:fr64
SU(3):   $xmm1 = COPY %173:fr64
SU(4):   $al = MOV8ri 2

********** MI Scheduling **********
main:%bb.38 if.then116
  From: %170:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 16, $noreg :: (dereferenceable load 8 from %ir.arrayidx117, align 16)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 7
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %170:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 16, $noreg :: (dereferenceable load 8 from %ir.arrayidx117, align 16)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 16
  Successors:
    SU(1): Data Latency=4 Reg=%170
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %170:fr64 = ADDSDrm %170:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx118)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 12
  Predecessors:
    SU(0): Data Latency=4 Reg=%170
    SU(0): Out  Latency=0
  Successors:
    SU(2): Data Latency=4 Reg=%170
    SU(2): Out  Latency=0
  Single Issue       : false;
SU(2):   %170:fr64 = ADDSDrm %170:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 32, $noreg :: (dereferenceable load 8 from %ir.arrayidx120, align 16)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 8
  Height             : 8
  Predecessors:
    SU(1): Data Latency=4 Reg=%170
    SU(1): Out  Latency=0
  Successors:
    SU(4): Data Latency=4 Reg=%170
    SU(3): Data Latency=4 Reg=%170
  Single Issue       : false;
SU(3):   MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %170:fr64 :: (store 8 into %ir.t)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(2): Data Latency=4 Reg=%170
  Single Issue       : false;
SU(4):   %173:fr64 = COPY %170:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 12
  Height             : 4
  Predecessors:
    SU(2): Data Latency=4 Reg=%170
  Successors:
    SU(5): Data Latency=0 Reg=%173
    SU(5): Out  Latency=0
  Single Issue       : false;
SU(5):   %173:fr64 = MULSDrr %173:fr64(tied-def 0), %222:fr64
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 4
  Predecessors:
    SU(4): Data Latency=0 Reg=%173
    SU(4): Out  Latency=0
  Successors:
    SU(6): Data Latency=1 Reg=%173
    SU(6): Out  Latency=0
  Single Issue       : false;
SU(6):   %173:fr64 = DIVSDrm %173:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 13
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1 Reg=%173
    SU(5): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 16
  Height             : 0
  Predecessors:
    SU(6): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 16
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 6 
  Cand SU(3) ORDER                              
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) %173:fr64 = DIVSDrm %173:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @3c
  BotQ.A TopLatency SU(6) 13c
  BotQ.A BotLatency SU(6) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 5 
  Cand SU(3) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %173:fr64 = MULSDrr %173:fr64(tied-def 0), %222:fr64
  Ready @4c
  BotQ.A BotLatency SU(5) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 4 
  Cand SU(3) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %173:fr64 = COPY %170:fr64
  Ready @4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %170:fr64 :: (store 8 into %ir.t)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %170:fr64 = ADDSDrm %170:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 32, $noreg :: (dereferenceable load 8 from %ir.arrayidx120, align 16)
  Ready @8c
  BotQ.A BotLatency SU(2) 8c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %170:fr64 = ADDSDrm %170:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx118)
  Ready @12c
  BotQ.A BotLatency SU(1) 12c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %170:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 16, $noreg :: (dereferenceable load 8 from %ir.arrayidx117, align 16)
  Ready @16c
  BotQ.A BotLatency SU(0) 16c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 16c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.38 ***
SU(0):   %170:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 16, $noreg :: (dereferenceable load 8 from %ir.arrayidx117, align 16)
SU(1):   %170:fr64 = ADDSDrm %170:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx118)
SU(2):   %170:fr64 = ADDSDrm %170:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 32, $noreg :: (dereferenceable load 8 from %ir.arrayidx120, align 16)
SU(3):   MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %170:fr64 :: (store 8 into %ir.t)
SU(4):   %173:fr64 = COPY %170:fr64
SU(5):   %173:fr64 = MULSDrr %173:fr64(tied-def 0), %222:fr64
SU(6):   %173:fr64 = DIVSDrm %173:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)

********** MI Scheduling **********
main:%bb.40 if.then133
  From: $rdi = MOV32ri64 @.str.43
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.43
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.46
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %161:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $xmm1 = COPY %163:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   $al = MOV8ri 2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) $al = MOV8ri 2
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $xmm1 = COPY %163:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) $xmm0 = COPY %161:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.46
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.43
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.40 ***
SU(0):   $rdi = MOV32ri64 @.str.43
SU(1):   $rsi = MOV32ri64 @.str.46
SU(2):   $xmm0 = COPY %161:fr64
SU(3):   $xmm1 = COPY %163:fr64
SU(4):   $al = MOV8ri 2

********** MI Scheduling **********
main:%bb.40 if.then133
  From: %161:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 64, $noreg :: (dereferenceable load 8 from %ir.arrayidx134, align 16)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 7
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %161:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 64, $noreg :: (dereferenceable load 8 from %ir.arrayidx134, align 16)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 16
  Successors:
    SU(1): Data Latency=4 Reg=%161
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %161:fr64 = SUBSDrm %161:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx135)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 12
  Predecessors:
    SU(0): Data Latency=4 Reg=%161
    SU(0): Out  Latency=0
  Successors:
    SU(2): Data Latency=4 Reg=%161
    SU(2): Out  Latency=0
  Single Issue       : false;
SU(2):   %161:fr64 = SUBSDrm %161:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx137, align 16)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 8
  Height             : 8
  Predecessors:
    SU(1): Data Latency=4 Reg=%161
    SU(1): Out  Latency=0
  Successors:
    SU(4): Data Latency=4 Reg=%161
    SU(3): Data Latency=4 Reg=%161
  Single Issue       : false;
SU(3):   MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %161:fr64 :: (store 8 into %ir.t)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(2): Data Latency=4 Reg=%161
  Single Issue       : false;
SU(4):   %163:fr64 = COPY %161:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 12
  Height             : 4
  Predecessors:
    SU(2): Data Latency=4 Reg=%161
  Successors:
    SU(5): Data Latency=0 Reg=%163
    SU(5): Out  Latency=0
  Single Issue       : false;
SU(5):   %163:fr64 = MULSDrr %163:fr64(tied-def 0), %222:fr64
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 4
  Predecessors:
    SU(4): Data Latency=0 Reg=%163
    SU(4): Out  Latency=0
  Successors:
    SU(6): Data Latency=1 Reg=%163
    SU(6): Out  Latency=0
  Single Issue       : false;
SU(6):   %163:fr64 = DIVSDrm %163:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 13
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1 Reg=%163
    SU(5): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 16
  Height             : 0
  Predecessors:
    SU(6): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 16
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 6 
  Cand SU(3) ORDER                              
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) %163:fr64 = DIVSDrm %163:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @3c
  BotQ.A TopLatency SU(6) 13c
  BotQ.A BotLatency SU(6) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 5 
  Cand SU(3) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %163:fr64 = MULSDrr %163:fr64(tied-def 0), %222:fr64
  Ready @4c
  BotQ.A BotLatency SU(5) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 4 
  Cand SU(3) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %163:fr64 = COPY %161:fr64
  Ready @4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %161:fr64 :: (store 8 into %ir.t)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %161:fr64 = SUBSDrm %161:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx137, align 16)
  Ready @8c
  BotQ.A BotLatency SU(2) 8c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %161:fr64 = SUBSDrm %161:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx135)
  Ready @12c
  BotQ.A BotLatency SU(1) 12c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %161:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 64, $noreg :: (dereferenceable load 8 from %ir.arrayidx134, align 16)
  Ready @16c
  BotQ.A BotLatency SU(0) 16c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 16c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.40 ***
SU(0):   %161:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 64, $noreg :: (dereferenceable load 8 from %ir.arrayidx134, align 16)
SU(1):   %161:fr64 = SUBSDrm %161:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx135)
SU(2):   %161:fr64 = SUBSDrm %161:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx137, align 16)
SU(3):   MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %161:fr64 :: (store 8 into %ir.t)
SU(4):   %163:fr64 = COPY %161:fr64
SU(5):   %163:fr64 = MULSDrr %163:fr64(tied-def 0), %222:fr64
SU(6):   %163:fr64 = DIVSDrm %163:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)

********** MI Scheduling **********
main:%bb.42 if.then145
  From: $rdi = MOV32ri64 @.str.43
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.43
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.47
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %152:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $xmm1 = COPY %154:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   $al = MOV8ri 2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) $al = MOV8ri 2
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $xmm1 = COPY %154:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) $xmm0 = COPY %152:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.47
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.43
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.42 ***
SU(0):   $rdi = MOV32ri64 @.str.43
SU(1):   $rsi = MOV32ri64 @.str.47
SU(2):   $xmm0 = COPY %152:fr64
SU(3):   $xmm1 = COPY %154:fr64
SU(4):   $al = MOV8ri 2

********** MI Scheduling **********
main:%bb.42 if.then145
  From: %152:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx146)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %152:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx146)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 12
  Successors:
    SU(1): Data Latency=4 Reg=%152
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %152:fr64 = ADDSDrm %152:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx147, align 16)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 8
  Predecessors:
    SU(0): Data Latency=4 Reg=%152
    SU(0): Out  Latency=0
  Successors:
    SU(3): Data Latency=4 Reg=%152
    SU(2): Data Latency=4 Reg=%152
  Single Issue       : false;
SU(2):   MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %152:fr64 :: (store 8 into %ir.t)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Data Latency=4 Reg=%152
  Single Issue       : false;
SU(3):   %154:fr64 = COPY %152:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(1): Data Latency=4 Reg=%152
  Successors:
    SU(4): Data Latency=0 Reg=%154
    SU(4): Out  Latency=0
  Single Issue       : false;
SU(4):   %154:fr64 = MULSDrr %154:fr64(tied-def 0), %222:fr64
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(3): Data Latency=0 Reg=%154
    SU(3): Out  Latency=0
  Successors:
    SU(5): Data Latency=1 Reg=%154
    SU(5): Out  Latency=0
  Single Issue       : false;
SU(5):   %154:fr64 = DIVSDrm %154:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 9
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1 Reg=%154
    SU(4): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 12
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 5 
  Cand SU(2) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %154:fr64 = DIVSDrm %154:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @3c
  BotQ.A TopLatency SU(5) 9c
  BotQ.A BotLatency SU(5) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 4 
  Cand SU(2) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %154:fr64 = MULSDrr %154:fr64(tied-def 0), %222:fr64
  Ready @4c
  BotQ.A BotLatency SU(4) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %154:fr64 = COPY %152:fr64
  Ready @4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %152:fr64 :: (store 8 into %ir.t)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %152:fr64 = ADDSDrm %152:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx147, align 16)
  Ready @8c
  BotQ.A BotLatency SU(1) 8c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %152:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx146)
  Ready @12c
  BotQ.A BotLatency SU(0) 12c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.42 ***
SU(0):   %152:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx146)
SU(1):   %152:fr64 = ADDSDrm %152:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx147, align 16)
SU(2):   MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %152:fr64 :: (store 8 into %ir.t)
SU(3):   %154:fr64 = COPY %152:fr64
SU(4):   %154:fr64 = MULSDrr %154:fr64(tied-def 0), %222:fr64
SU(5):   %154:fr64 = DIVSDrm %154:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)

********** MI Scheduling **********
main:%bb.45 return
  From: %220:gr32 = MOV32rm %stack.0.retval, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.retval)
    To: RET 0, killed $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %220:gr32 = MOV32rm %stack.0.retval, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.retval)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 4
  Successors:
    SU(1): Data Latency=4 Reg=%220
  Single Issue       : false;
SU(1):   $eax = COPY %220:gr32
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(0): Data Latency=4 Reg=%220
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   RET 0, killed $eax
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 4
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) $eax = COPY %220:gr32
  Ready @0c
  BotQ.A TopLatency SU(1) 4c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %220:gr32 = MOV32rm %stack.0.retval, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.retval)
  Ready @4c
  BotQ.A BotLatency SU(0) 4c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.45 ***
SU(0):   %220:gr32 = MOV32rm %stack.0.retval, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.retval)
SU(1):   $eax = COPY %220:gr32

********** INTERVALS **********
DIL [0B,32r:0)[144r,176r:32)[592r,608r:31)[768r,800r:30)[880r,912r:29)[1104r,1136r:27)[1256r,1296r:26)[1408r,1424r:25)[1672r,1696r:24)[1808r,1824r:23)[2136r,2160r:22)[2256r,2272r:21)[2400r,2432r:28)[2688r,2768r:20)[2880r,2944r:19)[3008r,3040r:18)[3376r,3456r:9)[3520r,3552r:8)[4048r,4064r:1)[4560r,4576r:2)[4688r,4704r:7)[5296r,5344r:10)[5552r,5568r:6)[5616r,5632r:5)[5760r,5808r:4)[6816r,7136r:17)[7360r,7376r:3)[7728r,7760r:16)[8144r,8224r:15)[8496r,8576r:12)[8752r,8832r:11)[9136r,9216r:13)[9488r,9568r:14)  0@0B-phi 1@4048r 2@4560r 3@7360r 4@5760r 5@5616r 6@5552r 7@4688r 8@3520r 9@3376r 10@5296r 11@8752r 12@8496r 13@9136r 14@9488r 15@8144r 16@7728r 17@6816r 18@3008r 19@2880r 20@2688r 21@2256r 22@2136r 23@1808r 24@1672r 25@1408r 26@1256r 27@1104r 28@2400r 29@880r 30@768r 31@592r 32@144r
DIH [0B,32r:0)[144r,176r:32)[592r,608r:31)[768r,800r:30)[880r,912r:29)[1104r,1136r:27)[1256r,1296r:26)[1408r,1424r:25)[1672r,1696r:24)[1808r,1824r:23)[2136r,2160r:22)[2256r,2272r:21)[2400r,2432r:28)[2688r,2768r:20)[2880r,2944r:19)[3008r,3040r:18)[3376r,3456r:9)[3520r,3552r:8)[4048r,4064r:1)[4560r,4576r:2)[4688r,4704r:7)[5296r,5344r:10)[5552r,5568r:6)[5616r,5632r:5)[5760r,5808r:4)[6816r,7136r:17)[7360r,7376r:3)[7728r,7760r:16)[8144r,8224r:15)[8496r,8576r:12)[8752r,8832r:11)[9136r,9216r:13)[9488r,9568r:14)  0@0B-phi 1@4048r 2@4560r 3@7360r 4@5760r 5@5616r 6@5552r 7@4688r 8@3520r 9@3376r 10@5296r 11@8752r 12@8496r 13@9136r 14@9488r 15@8144r 16@7728r 17@6816r 18@3008r 19@2880r 20@2688r 21@2256r 22@2136r 23@1808r 24@1672r 25@1408r 26@1256r 27@1104r 28@2400r 29@880r 30@768r 31@592r 32@144r
HDI [0B,32r:0)[144r,176r:32)[592r,608r:31)[768r,800r:30)[880r,912r:29)[1104r,1136r:27)[1256r,1296r:26)[1408r,1424r:25)[1672r,1696r:24)[1808r,1824r:23)[2136r,2160r:22)[2256r,2272r:21)[2400r,2432r:28)[2688r,2768r:20)[2880r,2944r:19)[3008r,3040r:18)[3376r,3456r:9)[3520r,3552r:8)[4048r,4064r:1)[4560r,4576r:2)[4688r,4704r:7)[5296r,5344r:10)[5552r,5568r:6)[5616r,5632r:5)[5760r,5808r:4)[6816r,7136r:17)[7360r,7376r:3)[7728r,7760r:16)[8144r,8224r:15)[8496r,8576r:12)[8752r,8832r:11)[9136r,9216r:13)[9488r,9568r:14)  0@0B-phi 1@4048r 2@4560r 3@7360r 4@5760r 5@5616r 6@5552r 7@4688r 8@3520r 9@3376r 10@5296r 11@8752r 12@8496r 13@9136r 14@9488r 15@8144r 16@7728r 17@6816r 18@3008r 19@2880r 20@2688r 21@2256r 22@2136r 23@1808r 24@1672r 25@1408r 26@1256r 27@1104r 28@2400r 29@880r 30@768r 31@592r 32@144r
SIL [0B,16r:0)[160r,176r:16)[896r,912r:15)[1248r,1296r:14)[1648r,1696r:13)[2080r,2160r:12)[2704r,2768r:5)[2896r,2944r:4)[3392r,3456r:1)[5312r,5344r:2)[5776r,5808r:11)[6832r,7136r:3)[8160r,8224r:10)[8512r,8576r:7)[8768r,8832r:6)[9152r,9216r:8)[9504r,9568r:9)  0@0B-phi 1@3392r 2@5312r 3@6832r 4@2896r 5@2704r 6@8768r 7@8512r 8@9152r 9@9504r 10@8160r 11@5776r 12@2080r 13@1648r 14@1248r 15@896r 16@160r
SIH [0B,16r:0)[160r,176r:16)[896r,912r:15)[1248r,1296r:14)[1648r,1696r:13)[2080r,2160r:12)[2704r,2768r:5)[2896r,2944r:4)[3392r,3456r:1)[5312r,5344r:2)[5776r,5808r:11)[6832r,7136r:3)[8160r,8224r:10)[8512r,8576r:7)[8768r,8832r:6)[9152r,9216r:8)[9504r,9568r:9)  0@0B-phi 1@3392r 2@5312r 3@6832r 4@2896r 5@2704r 6@8768r 7@8512r 8@9152r 9@9504r 10@8160r 11@5776r 12@2080r 13@1648r 14@1248r 15@896r 16@160r
HSI [0B,16r:0)[160r,176r:16)[896r,912r:15)[1248r,1296r:14)[1648r,1696r:13)[2080r,2160r:12)[2704r,2768r:5)[2896r,2944r:4)[3392r,3456r:1)[5312r,5344r:2)[5776r,5808r:11)[6832r,7136r:3)[8160r,8224r:10)[8512r,8576r:7)[8768r,8832r:6)[9152r,9216r:8)[9504r,9568r:9)  0@0B-phi 1@3392r 2@5312r 3@6832r 4@2896r 5@2704r 6@8768r 7@8512r 8@9152r 9@9504r 10@8160r 11@5776r 12@2080r 13@1648r 14@1248r 15@896r 16@160r
%0 [32r,64r:0)  0@32r weight:0.000000e+00
%1 [16r,80r:0)  0@16r weight:0.000000e+00
%4 [208r,240r:0)  0@208r weight:0.000000e+00
%5 [560r,592r:0)  0@560r weight:0.000000e+00
%13 [944r,976r:0)  0@944r weight:0.000000e+00
%18 [2480r,2496r:0)  0@2480r weight:0.000000e+00
%19 [2512r,2528r:0)  0@2512r weight:0.000000e+00
%24 [1168r,1256r:0)  0@1168r weight:0.000000e+00
%26 [1216r,1264r:0)  0@1216r weight:0.000000e+00
%27 [1328r,1344r:0)  0@1328r weight:0.000000e+00
%28 [1376r,1408r:0)  0@1376r weight:0.000000e+00
%29 [1456r,1472r:0)  0@1456r weight:0.000000e+00
%31 [1536r,1672r:0)  0@1536r weight:0.000000e+00
%36 [1728r,1744r:0)  0@1728r weight:0.000000e+00
%37 [1776r,1808r:0)  0@1776r weight:0.000000e+00
%38 [1856r,1872r:0)  0@1856r weight:0.000000e+00
%40 [1936r,2136r:0)  0@1936r weight:0.000000e+00
%47 [2192r,2208r:0)  0@2192r weight:0.000000e+00
%48 [2224r,2256r:0)  0@2224r weight:0.000000e+00
%50 [2576r,2704r:0)  0@2576r weight:0.000000e+00
%51 [2592r,2720r:0)  0@2592r weight:0.000000e+00
%52 [2608r,2736r:0)  0@2608r weight:0.000000e+00
%57 [2800r,2896r:0)  0@2800r weight:0.000000e+00
%58 [2816r,2912r:0)  0@2816r weight:0.000000e+00
%71 [3632r,3664r:0)[3664r,3680r:1)  0@3632r 1@3664r weight:0.000000e+00
%73 [3696r,3728r:0)[3728r,3744r:1)  0@3696r 1@3728r weight:0.000000e+00
%75 [3760r,3792r:0)[3792r,3808r:1)  0@3760r 1@3792r weight:0.000000e+00
%85 [4800r,4816r:0)  0@4800r weight:0.000000e+00
%88 [5664r,5680r:0)  0@5664r weight:0.000000e+00
%89 [5696r,5760r:0)  0@5696r weight:0.000000e+00
%90 [5728r,5776r:0)  0@5728r weight:0.000000e+00
%91 [5744r,5792r:0)  0@5744r weight:0.000000e+00
%92 [5840r,5872r:0)  0@5840r weight:0.000000e+00
%93 [5856r,5872r:0)  0@5856r weight:0.000000e+00
%95 [5968r,6096r:0)  0@5968r weight:0.000000e+00
%97 [5984r,6128r:0)  0@5984r weight:0.000000e+00
%98 [6000r,6016r:2)[6016r,6048r:0)[6048r,6208r:1)  0@6016r 1@6048r 2@6000r weight:0.000000e+00
%100 [5952r,6096r:2)[6096r,6128r:0)[6128r,6144r:1)  0@6096r 1@6128r 2@5952r weight:0.000000e+00
%104 [6208r,6240r:0)[6240r,6336r:1)  0@6208r 1@6240r weight:0.000000e+00
%106 [6256r,6272r:2)[6272r,6304r:0)[6304r,6336r:1)[6336r,6400r:3)  0@6272r 1@6304r 2@6256r 3@6336r weight:0.000000e+00
%108 [6144r,6176r:2)[6176r,6368r:0)[6368r,6400r:1)[6400r,6432r:3)[6432r,6480r:4)  0@6176r 1@6368r 2@6144r 3@6400r 4@6432r weight:0.000000e+00
%114 [6496r,6528r:0)[6528r,6560r:1)  0@6496r 1@6528r weight:0.000000e+00
%115 [6448r,6480r:2)[6480r,6560r:0)[6560r,6576r:1)  0@6480r 1@6560r 2@6448r weight:0.000000e+00
%116 [6656r,6832r:0)  0@6656r weight:0.000000e+00
%117 [6672r,6848r:0)  0@6672r weight:0.000000e+00
%118 [6688r,6864r:0)  0@6688r weight:0.000000e+00
%119 [6704r,6880r:0)  0@6704r weight:0.000000e+00
%120 [6720r,6896r:0)  0@6720r weight:0.000000e+00
%121 [6736r,6912r:0)  0@6736r weight:0.000000e+00
%122 [6752r,6928r:0)  0@6752r weight:0.000000e+00
%128 [7504r,7536r:0)  0@7504r weight:0.000000e+00
%129 [7520r,7536r:0)  0@7520r weight:0.000000e+00
%130 [7616r,7632r:0)  0@7616r weight:0.000000e+00
%137 [8016r,8048r:0)  0@8016r weight:0.000000e+00
%138 [8032r,8160r:0)  0@8032r weight:0.000000e+00
%139 [8048r,8176r:0)  0@8048r weight:0.000000e+00
%141 [8064r,8080r:2)[8080r,8112r:0)[8112r,8192r:1)  0@8080r 1@8112r 2@8064r weight:0.000000e+00
%152 [9344r,9376r:0)[9376r,9520r:1)  0@9344r 1@9376r weight:0.000000e+00
%154 [9408r,9424r:2)[9424r,9456r:0)[9456r,9536r:1)  0@9424r 1@9456r 2@9408r weight:0.000000e+00
%161 [8960r,8992r:2)[8992r,9024r:0)[9024r,9168r:1)  0@8992r 1@9024r 2@8960r weight:0.000000e+00
%163 [9056r,9072r:2)[9072r,9104r:0)[9104r,9184r:1)  0@9072r 1@9104r 2@9056r weight:0.000000e+00
%170 [8320r,8352r:2)[8352r,8384r:0)[8384r,8528r:1)  0@8352r 1@8384r 2@8320r weight:0.000000e+00
%173 [8416r,8432r:2)[8432r,8464r:0)[8464r,8544r:1)  0@8432r 1@8464r 2@8416r weight:0.000000e+00
%179 [8608r,8640r:0)[8640r,8784r:1)  0@8608r 1@8640r weight:0.000000e+00
%181 [8672r,8688r:2)[8688r,8720r:0)[8720r,8800r:1)  0@8688r 1@8720r 2@8672r weight:0.000000e+00
%184 [7328r,7360r:0)  0@7328r weight:0.000000e+00
%185 [7408r,7440r:0)  0@7408r weight:0.000000e+00
%186 [7424r,7440r:0)  0@7424r weight:0.000000e+00
%187 [4880r,5120r:0)  0@4880r weight:0.000000e+00
%190 [4928r,4944r:0)[4944r,5040r:1)  0@4928r 1@4944r weight:0.000000e+00
%196 [4912r,4992r:3)[4992r,5040r:0)[5040r,5072r:1)[5072r,5104r:2)  0@4992r 1@5040r 2@5072r 3@4912r weight:0.000000e+00
%198 [5104r,5120r:0)  0@5104r weight:0.000000e+00
%202 [5248r,5312r:0)  0@5248r weight:0.000000e+00
%209 [4528r,4560r:0)  0@4528r weight:0.000000e+00
%210 [4016r,4048r:0)  0@4016r weight:0.000000e+00
%211 [3264r,3392r:0)  0@3264r weight:0.000000e+00
%212 [3280r,3408r:0)  0@3280r weight:0.000000e+00
%213 [3296r,3424r:0)  0@3296r weight:0.000000e+00
%220 [9696r,9712r:0)  0@9696r weight:0.000000e+00
%222 [7808r,9648B:0)  0@7808r weight:0.000000e+00
%226 [6768r,7104r:0)  0@6768r weight:0.000000e+00
RegMasks: 176r 608r 800r 912r 1136r 1296r 1424r 1696r 1824r 2160r 2272r 2432r 2768r 2944r 3040r 3456r 3552r 3888r 4064r 4208r 4272r 4336r 4400r 4576r 4704r 5344r 5440r 5568r 5632r 5808r 7136r 7376r 7760r 8224r 8576r 8832r 9216r 9568r
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=4, align=4, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=4, align=4, at location [SP+8]
  fi#6: size=4, align=4, at location [SP+8]
  fi#7: size=8, align=8, at location [SP+8]
  fi#8: size=8, align=8, at location [SP+8]
  fi#9: size=8, align=8, at location [SP+8]
  fi#10: size=128, align=16, at location [SP+8]
  fi#11: size=4, align=4, at location [SP+8]
  fi#12: size=1, align=1, at location [SP+8]
  fi#13: size=128, align=16, at location [SP+8]
  fi#14: size=8, align=8, at location [SP+8]
  fi#15: size=4, align=4, at location [SP+8]
Constant Pool:
  cp#0: 3.000000e+00, align=8
  cp#1: 0x408B89645A1CAC08, align=8
  cp#2: -4.683910e+03, align=8
  cp#3: 1.148450e+04, align=8
  cp#4: -1.927240e+04, align=8
  cp#5: 1.000000e+06, align=8
  cp#6: 1.000000e+02, align=8
Function Live Ins: $edi in %0, $rsi in %1

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $edi, $rsi
16B	  %1:gr64 = COPY $rsi
32B	  %0:gr32 = COPY $edi
48B	  MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
64B	  MOV32mr %stack.1.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
80B	  MOV64mr %stack.2.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
96B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
144B	  $rdi = MOV32ri64 @.str
160B	  $rsi = MOV32ri64 @.str.1
176B	  CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %4:gr64 = COPY killed $rax
224B	  MOV64mr %stack.14.fp, 1, $noreg, 0, $noreg, %4:gr64 :: (store 8 into %ir.fp)
240B	  TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
256B	  JCC_1 %bb.2, 4, implicit killed $eflags
272B	  JMP_1 %bb.1

288B	bb.1.if.then:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

304B	  MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
320B	  MOV64mi32 %stack.13.t_names, 1, $noreg, 8, $noreg, @.str.2 :: (store 8 into %ir.arrayidx)
336B	  MOV64mi32 %stack.13.t_names, 1, $noreg, 16, $noreg, @.str.3 :: (store 8 into %ir.arrayidx1, align 16)
352B	  MOV64mi32 %stack.13.t_names, 1, $noreg, 24, $noreg, @.str.4 :: (store 8 into %ir.arrayidx2)
368B	  MOV64mi32 %stack.13.t_names, 1, $noreg, 32, $noreg, @.str.5 :: (store 8 into %ir.arrayidx3, align 16)
384B	  MOV64mi32 %stack.13.t_names, 1, $noreg, 40, $noreg, @.str.6 :: (store 8 into %ir.arrayidx4)
400B	  MOV64mi32 %stack.13.t_names, 1, $noreg, 48, $noreg, @.str.7 :: (store 8 into %ir.arrayidx5, align 16)
416B	  MOV64mi32 %stack.13.t_names, 1, $noreg, 56, $noreg, @.str.8 :: (store 8 into %ir.arrayidx6)
432B	  MOV64mi32 %stack.13.t_names, 1, $noreg, 64, $noreg, @.str.9 :: (store 8 into %ir.arrayidx7, align 16)
448B	  MOV64mi32 %stack.13.t_names, 1, $noreg, 72, $noreg, @.str.10 :: (store 8 into %ir.arrayidx8)
464B	  MOV64mi32 %stack.13.t_names, 1, $noreg, 80, $noreg, @.str.11 :: (store 8 into %ir.arrayidx9, align 16)
480B	  MOV64mi32 %stack.13.t_names, 1, $noreg, 112, $noreg, @.str.12 :: (store 8 into %ir.arrayidx10, align 16)
496B	  MOV64mi32 %stack.13.t_names, 1, $noreg, 104, $noreg, @.str.13 :: (store 8 into %ir.arrayidx11)
512B	  MOV64mi32 %stack.13.t_names, 1, $noreg, 96, $noreg, @.str.14 :: (store 8 into %ir.arrayidx12, align 16)
528B	  MOV64mi32 %stack.13.t_names, 1, $noreg, 88, $noreg, @.str.15 :: (store 8 into %ir.arrayidx13)
544B	  MOV64mi32 %stack.13.t_names, 1, $noreg, 120, $noreg, @.str.16 :: (store 8 into %ir.arrayidx14)
560B	  %5:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
576B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
592B	  $rdi = COPY %5:gr64
608B	  CALL64pcrel32 @fclose, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
624B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
640B	  JMP_1 %bb.3

656B	bb.2.if.else:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

672B	  MOV32mi $rip, 1, $noreg, @timeron, $noreg, 0 :: (store 4 into @timeron)

688B	bb.3.if.end:
	; predecessors: %bb.2, %bb.1
	  successors: %bb.4(0x50000000), %bb.9(0x30000000); %bb.4(62.50%), %bb.9(37.50%)

704B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
768B	  $rdi = MOV32ri64 @.str.17
784B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
800B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
816B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
832B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
880B	  $rdi = MOV32ri64 @.str.18
896B	  $rsi = MOV32ri64 @.str.1
912B	  CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
928B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
944B	  %13:gr64 = COPY killed $rax
960B	  MOV64mr %stack.14.fp, 1, $noreg, 0, $noreg, %13:gr64 :: (store 8 into %ir.fp)
976B	  TEST64rr %13:gr64, %13:gr64, implicit-def $eflags
992B	  JCC_1 %bb.9, 4, implicit killed $eflags
1008B	  JMP_1 %bb.4

1024B	bb.4.if.then19:
	; predecessors: %bb.3
	  successors: %bb.5(0x80000000); %bb.5(100.00%)

1040B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1104B	  $rdi = MOV32ri64 @.str.19
1120B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1136B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1152B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1168B	  %24:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
1184B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1216B	  %26:gr64 = LEA64r %stack.4.niter, 1, $noreg, 0, $noreg
1248B	  $rsi = MOV32ri64 @.str.20
1256B	  $rdi = COPY %24:gr64
1264B	  $rdx = COPY %26:gr64
1280B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1296B	  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1312B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1328B	  %27:gr32 = COPY killed $eax
1344B	  MOV32mr %stack.15.result, 1, $noreg, 0, $noreg, %27:gr32 :: (store 4 into %ir.result)

1360B	bb.5.while.cond:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

1376B	  %28:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
1392B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1408B	  $rdi = COPY %28:gr64
1424B	  CALL64pcrel32 @fgetc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1440B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1456B	  %29:gr32 = COPY killed $eax
1472B	  CMP32ri8 %29:gr32, 10, implicit-def $eflags
1488B	  JCC_1 %bb.5, 5, implicit killed $eflags
1504B	  JMP_1 %bb.6

1520B	bb.6.while.end:
	; predecessors: %bb.5
	  successors: %bb.7(0x80000000); %bb.7(100.00%)

1536B	  %31:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
1552B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1648B	  $rsi = MOV32ri64 @.str.21
1664B	  $rdx = MOV32ri64 @dt
1672B	  $rdi = COPY %31:gr64
1680B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1696B	  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1712B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1728B	  %36:gr32 = COPY killed $eax
1744B	  MOV32mr %stack.15.result, 1, $noreg, 0, $noreg, %36:gr32 :: (store 4 into %ir.result)

1760B	bb.7.while.cond25:
	; predecessors: %bb.6, %bb.7
	  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)

1776B	  %37:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
1792B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1808B	  $rdi = COPY %37:gr64
1824B	  CALL64pcrel32 @fgetc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1840B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1856B	  %38:gr32 = COPY killed $eax
1872B	  CMP32ri8 %38:gr32, 10, implicit-def $eflags
1888B	  JCC_1 %bb.7, 5, implicit killed $eflags
1904B	  JMP_1 %bb.8

1920B	bb.8.while.end29:
	; predecessors: %bb.7
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1936B	  %40:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
1952B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2080B	  $rsi = MOV32ri64 @.str.22
2096B	  $rdx = MOV32ri64 @grid_points
2112B	  $rcx = MOV32ri64 @grid_points + 4
2128B	  $r8 = MOV32ri64 @grid_points + 8
2136B	  $rdi = COPY %40:gr64
2144B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
2160B	  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
2176B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2192B	  %47:gr32 = COPY killed $eax
2208B	  MOV32mr %stack.15.result, 1, $noreg, 0, $noreg, %47:gr32 :: (store 4 into %ir.result)
2224B	  %48:gr64 = MOV64rm %stack.14.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
2240B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2256B	  $rdi = COPY %48:gr64
2272B	  CALL64pcrel32 @fclose, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
2288B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2304B	  JMP_1 %bb.10

2320B	bb.9.if.else32:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

2336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2400B	  $rdi = MOV32ri64 @.str.23
2416B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
2432B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
2448B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2464B	  MOV32mi %stack.4.niter, 1, $noreg, 0, $noreg, 400 :: (store 4 into %ir.niter)
2480B	  %18:gr64 = MOV64ri 4562254508917369340
2496B	  MOV64mr $rip, 1, $noreg, @dt, $noreg, %18:gr64 :: (store 8 into @dt)
2512B	  %19:gr64 = MOV64ri 438086664294
2528B	  MOV64mr $rip, 1, $noreg, @grid_points, $noreg, %19:gr64 :: (store 8 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`, align 4)
2544B	  MOV32mi $rip, 1, $noreg, @grid_points + 8, $noreg, 102 :: (store 4 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)

2560B	bb.10.if.end34:
	; predecessors: %bb.9, %bb.8
	  successors: %bb.13(0x40000000), %bb.11(0x40000000); %bb.13(50.00%), %bb.11(50.00%)

2576B	  %50:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
2592B	  %51:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
2608B	  %52:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
2624B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2688B	  $rdi = MOV32ri64 @.str.24
2704B	  $esi = COPY %50:gr32
2720B	  $edx = COPY %51:gr32
2736B	  $ecx = COPY %52:gr32
2752B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
2768B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
2784B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2800B	  %57:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
2816B	  %58:fr64 = MOVSDrm_alt $rip, 1, $noreg, @dt, $noreg :: (dereferenceable load 8 from @dt)
2832B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2880B	  $rdi = MOV32ri64 @.str.25
2896B	  $esi = COPY %57:gr32
2912B	  $xmm0 = COPY %58:fr64
2928B	  $al = MOV8ri 1
2944B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
2960B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2976B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3008B	  $rdi = MOV32ri64 @.str.26
3024B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
3040B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
3056B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3072B	  CMP32mi8 $rip, 1, $noreg, @grid_points, $noreg, 102, implicit-def $eflags :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
3088B	  JCC_1 %bb.13, 15, implicit killed $eflags
3104B	  JMP_1 %bb.11

3120B	bb.11.lor.lhs.false:
	; predecessors: %bb.10
	  successors: %bb.13(0x40000000), %bb.12(0x40000000); %bb.13(50.00%), %bb.12(50.00%)

3136B	  CMP32mi8 $rip, 1, $noreg, @grid_points + 4, $noreg, 102, implicit-def $eflags :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
3152B	  JCC_1 %bb.13, 15, implicit killed $eflags
3168B	  JMP_1 %bb.12

3184B	bb.12.lor.lhs.false40:
	; predecessors: %bb.11
	  successors: %bb.13(0x40000000), %bb.14(0x40000000); %bb.13(50.00%), %bb.14(50.00%)

3200B	  CMP32mi8 $rip, 1, $noreg, @grid_points + 8, $noreg, 103, implicit-def $eflags :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
3216B	  JCC_1 %bb.14, 12, implicit killed $eflags
3232B	  JMP_1 %bb.13

3248B	bb.13.if.then42:
	; predecessors: %bb.10, %bb.11, %bb.12
	  successors: %bb.45(0x80000000); %bb.45(100.00%)

3264B	  %211:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
3280B	  %212:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
3296B	  %213:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
3312B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3376B	  $rdi = MOV32ri64 @.str.27
3392B	  $esi = COPY %211:gr32
3408B	  $edx = COPY %212:gr32
3424B	  $ecx = COPY %213:gr32
3440B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
3456B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
3472B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3488B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3520B	  $rdi = MOV32ri64 @.str.28
3536B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
3552B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
3568B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3584B	  MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
3600B	  JMP_1 %bb.45

3616B	bb.14.if.end45:
	; predecessors: %bb.12
	  successors: %bb.15(0x80000000); %bb.15(100.00%)

3632B	  %71:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
3664B	  %71:gr32 = ADD32ri8 %71:gr32(tied-def 0), -2, implicit-def dead $eflags
3680B	  MOV32mr $rip, 1, $noreg, @nx2, $noreg, %71:gr32 :: (store 4 into @nx2)
3696B	  %73:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
3728B	  %73:gr32 = ADD32ri8 %73:gr32(tied-def 0), -2, implicit-def dead $eflags
3744B	  MOV32mr $rip, 1, $noreg, @ny2, $noreg, %73:gr32 :: (store 4 into @ny2)
3760B	  %75:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
3792B	  %75:gr32 = ADD32ri8 %75:gr32(tied-def 0), -2, implicit-def dead $eflags
3808B	  MOV32mr $rip, 1, $noreg, @nz2, $noreg, %75:gr32 :: (store 4 into @nz2)
3824B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3872B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
3888B	  CALL64pcrel32 @set_constants, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
3904B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3920B	  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

3936B	bb.15.for.cond:
	; predecessors: %bb.14, %bb.16
	  successors: %bb.16(0x7c000000), %bb.17(0x04000000); %bb.16(96.88%), %bb.17(3.12%)

3952B	  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 15, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
3968B	  JCC_1 %bb.17, 15, implicit killed $eflags
3984B	  JMP_1 %bb.16

4000B	bb.16.for.body:
	; predecessors: %bb.15
	  successors: %bb.15(0x80000000); %bb.15(100.00%)

4016B	  %210:gr32 = MOV32rm %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
4032B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4048B	  $edi = COPY %210:gr32
4064B	  CALL64pcrel32 @timer_clear, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
4080B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4096B	  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
4112B	  JMP_1 %bb.15

4128B	bb.17.for.end:
	; predecessors: %bb.15
	  successors: %bb.18(0x80000000); %bb.18(100.00%)

4144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4192B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
4208B	  CALL64pcrel32 @exact_rhs, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
4224B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4240B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4256B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
4272B	  CALL64pcrel32 @initialize, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
4288B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4304B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4320B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
4336B	  CALL64pcrel32 @adi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
4352B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4368B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4384B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
4400B	  CALL64pcrel32 @initialize, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
4416B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4432B	  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

4448B	bb.18.for.cond49:
	; predecessors: %bb.17, %bb.19
	  successors: %bb.19(0x7c000000), %bb.20(0x04000000); %bb.19(96.88%), %bb.20(3.12%)

4464B	  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 15, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
4480B	  JCC_1 %bb.20, 15, implicit killed $eflags
4496B	  JMP_1 %bb.19

4512B	bb.19.for.body51:
	; predecessors: %bb.18
	  successors: %bb.18(0x80000000); %bb.18(100.00%)

4528B	  %209:gr32 = MOV32rm %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
4544B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4560B	  $edi = COPY %209:gr32
4576B	  CALL64pcrel32 @timer_clear, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
4592B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4608B	  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
4624B	  JMP_1 %bb.18

4640B	bb.20.for.end54:
	; predecessors: %bb.18
	  successors: %bb.21(0x80000000); %bb.21(100.00%)

4656B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4688B	  $edi = MOV32ri 1
4704B	  CALL64pcrel32 @timer_start, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
4720B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4736B	  MOV32mi %stack.5.step, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.step)

4784B	bb.21.for.cond55:
	; predecessors: %bb.20, %bb.25
	  successors: %bb.22(0x7c000000), %bb.26(0x04000000); %bb.22(96.88%), %bb.26(3.12%)

4800B	  %85:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
4816B	  CMP32rm %85:gr32, %stack.4.niter, 1, $noreg, 0, $noreg, implicit-def $eflags :: (dereferenceable load 4 from %ir.niter)
4832B	  JCC_1 %bb.26, 15, implicit killed $eflags
4848B	  JMP_1 %bb.22

4864B	bb.22.for.body57:
	; predecessors: %bb.21
	  successors: %bb.24(0x30000000), %bb.23(0x50000000); %bb.24(37.50%), %bb.23(62.50%)

4880B	  %187:gr64_with_sub_8bit = MOVSX64rm32 %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
4912B	  %196:gr64_nosp = IMUL64rri32 %187:gr64_with_sub_8bit, 1717986919, implicit-def dead $eflags
4928B	  %190:gr64_with_sub_8bit = COPY %196:gr64_nosp
4944B	  %190:gr64_with_sub_8bit = SHR64ri %190:gr64_with_sub_8bit(tied-def 0), 63, implicit-def dead $eflags
4992B	  %196:gr64_nosp = SAR64ri %196:gr64_nosp(tied-def 0), 35, implicit-def dead $eflags
5040B	  %196.sub_32bit:gr64_nosp = ADD32rr %196.sub_32bit:gr64_nosp(tied-def 0), %190.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags
5072B	  %196.sub_32bit:gr64_nosp = SHL32ri %196.sub_32bit:gr64_nosp(tied-def 0), 2, implicit-def dead $eflags
5104B	  %198:gr32 = LEA64_32r %196:gr64_nosp, 4, %196:gr64_nosp, 0, $noreg
5120B	  CMP32rr %187.sub_32bit:gr64_with_sub_8bit, %198:gr32, implicit-def $eflags
5136B	  JCC_1 %bb.24, 4, implicit killed $eflags
5152B	  JMP_1 %bb.23

5168B	bb.23.lor.lhs.false59:
	; predecessors: %bb.22
	  successors: %bb.24(0x40000000), %bb.25(0x40000000); %bb.24(50.00%), %bb.25(50.00%)

5184B	  CMP32mi8 %stack.5.step, 1, $noreg, 0, $noreg, 1, implicit-def $eflags :: (dereferenceable load 4 from %ir.step)
5200B	  JCC_1 %bb.25, 5, implicit killed $eflags
5216B	  JMP_1 %bb.24

5232B	bb.24.if.then61:
	; predecessors: %bb.22, %bb.23
	  successors: %bb.25(0x80000000); %bb.25(100.00%)

5248B	  %202:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
5264B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5296B	  $rdi = MOV32ri64 @.str.29
5312B	  $esi = COPY %202:gr32
5328B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
5344B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
5360B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

5376B	bb.25.if.end63:
	; predecessors: %bb.23, %bb.24
	  successors: %bb.21(0x80000000); %bb.21(100.00%)

5392B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5424B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
5440B	  CALL64pcrel32 @adi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
5456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5472B	  INC32m %stack.5.step, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.step), (dereferenceable load 4 from %ir.step)
5488B	  JMP_1 %bb.21

5504B	bb.26.for.end66:
	; predecessors: %bb.21
	  successors: %bb.27(0x50000000), %bb.28(0x30000000); %bb.27(62.50%), %bb.28(37.50%)

5520B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5552B	  $edi = MOV32ri 1
5568B	  CALL64pcrel32 @timer_stop, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
5584B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5600B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5616B	  $edi = MOV32ri 1
5632B	  CALL64pcrel32 @timer_read, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
5648B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5664B	  %88:fr64 = COPY killed $xmm0
5680B	  MOVSDmr %stack.9.tmax, 1, $noreg, 0, $noreg, %88:fr64 :: (store 8 into %ir.tmax)
5696B	  %89:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
5712B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5728B	  %90:gr64 = LEA64r %stack.12.Class, 1, $noreg, 0, $noreg
5744B	  %91:gr64 = LEA64r %stack.11.verified, 1, $noreg, 0, $noreg
5760B	  $edi = COPY %89:gr32
5776B	  $rsi = COPY %90:gr64
5792B	  $rdx = COPY %91:gr64
5808B	  CALL64pcrel32 @verify, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp
5824B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5840B	  %92:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
5856B	  %93:fr64 = FsFLD0SD
5872B	  UCOMISDrr %92:fr64, %93:fr64, implicit-def $eflags
5888B	  JCC_1 %bb.27, 5, implicit $eflags
5904B	  JCC_1 %bb.27, 10, implicit killed $eflags
5920B	  JMP_1 %bb.28

5936B	bb.27.if.then69:
	; predecessors: %bb.26
	  successors: %bb.29(0x80000000); %bb.29(100.00%)

5952B	  %100:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
5968B	  %95:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
5984B	  %97:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
6000B	  %98:gr32 = COPY %95:gr32
6016B	  %98:gr32 = IMUL32rr %98:gr32(tied-def 0), %97:gr32, implicit-def dead $eflags
6048B	  %98:gr32 = IMUL32rr %98:gr32(tied-def 0), %100:gr32, implicit-def dead $eflags
6064B	  MOV32mr %stack.6.n3, 1, $noreg, 0, $noreg, %98:gr32 :: (store 4 into %ir.n3)
6096B	  %100:gr32 = nsw ADD32rr %100:gr32(tied-def 0), %95:gr32, implicit-def dead $eflags
6128B	  %100:gr32 = nsw ADD32rr %100:gr32(tied-def 0), %97:gr32, implicit-def dead $eflags
6144B	  %108:fr64 = CVTSI2SDrr %100:gr32
6176B	  %108:fr64 = DIVSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
6192B	  MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %108:fr64 :: (store 8 into %ir.t)
6208B	  %104:fr64 = CVTSI2SDrr %98:gr32
6240B	  %104:fr64 = MULSDrm %104:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
6256B	  %106:fr64 = COPY %108:fr64
6272B	  %106:fr64 = MULSDrr %106:fr64(tied-def 0), %106:fr64
6304B	  %106:fr64 = MULSDrm %106:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
6336B	  %106:fr64 = ADDSDrr %106:fr64(tied-def 0), %104:fr64
6368B	  %108:fr64 = MULSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
6400B	  %108:fr64 = ADDSDrr %108:fr64(tied-def 0), %106:fr64
6432B	  %108:fr64 = ADDSDrm %108:fr64(tied-def 0), $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
6448B	  %115:fr64 = CVTSI2SDrm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
6480B	  %115:fr64 = MULSDrr %115:fr64(tied-def 0), %108:fr64
6496B	  %114:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
6528B	  %114:fr64 = MULSDrm %114:fr64(tied-def 0), $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
6560B	  %115:fr64 = DIVSDrr %115:fr64(tied-def 0), %114:fr64
6576B	  MOVSDmr %stack.7.mflops, 1, $noreg, 0, $noreg, %115:fr64 :: (store 8 into %ir.mflops)
6592B	  JMP_1 %bb.29

6608B	bb.28.if.else84:
	; predecessors: %bb.26
	  successors: %bb.29(0x80000000); %bb.29(100.00%)

6624B	  MOV64mi32 %stack.7.mflops, 1, $noreg, 0, $noreg, 0 :: (store 8 into %ir.mflops)

6640B	bb.29.if.end85:
	; predecessors: %bb.28, %bb.27
	  successors: %bb.30(0x50000000), %bb.44(0x30000000); %bb.30(62.50%), %bb.44(37.50%)

6656B	  %116:gr32 = MOVSX32rm8 %stack.12.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
6672B	  %117:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
6688B	  %118:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
6704B	  %119:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
6720B	  %120:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
6736B	  %121:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
6752B	  %122:fr64 = MOVSDrm_alt %stack.7.mflops, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.mflops)
6768B	  undef %226.sub_32bit:gr64_with_sub_8bit = MOV32rm %stack.11.verified, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.verified)
6784B	  ADJCALLSTACKDOWN64 88, 0, 88, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6816B	  $rdi = MOV32ri64 @.str.30
6832B	  $esi = COPY %116:gr32
6848B	  $edx = COPY %117:gr32
6864B	  $ecx = COPY %118:gr32
6880B	  $r8d = COPY %119:gr32
6896B	  $r9d = COPY %120:gr32
6912B	  $xmm0 = COPY %121:fr64
6928B	  $xmm1 = COPY %122:fr64
6944B	  PUSH64i32 @.str.40, implicit-def $rsp, implicit $rsp
6960B	  PUSH64i32 @.str.39, implicit-def $rsp, implicit $rsp
6976B	  PUSH64i32 @.str.38, implicit-def $rsp, implicit $rsp
6992B	  PUSH64i32 @.str.37, implicit-def $rsp, implicit $rsp
7008B	  PUSH64i32 @.str.36, implicit-def $rsp, implicit $rsp
7024B	  PUSH64i32 @.str.35, implicit-def $rsp, implicit $rsp
7040B	  PUSH64i32 @.str.34, implicit-def $rsp, implicit $rsp
7056B	  PUSH64i32 @.str.33, implicit-def $rsp, implicit $rsp
7072B	  PUSH64i32 @.str.32, implicit-def $rsp, implicit $rsp
7104B	  PUSH64r %226:gr64_with_sub_8bit, implicit-def $rsp, implicit $rsp
7120B	  PUSH64i32 @.str.31, implicit-def $rsp, implicit $rsp
7136B	  CALL64pcrel32 @print_results, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $r8d, implicit killed $r9d, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp
7152B	  ADJCALLSTACKUP64 88, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
7168B	  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
7184B	  JCC_1 %bb.44, 4, implicit killed $eflags
7200B	  JMP_1 %bb.30

7216B	bb.30.if.then86:
	; predecessors: %bb.29
	  successors: %bb.31(0x80000000); %bb.31(100.00%)

7232B	  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

7248B	bb.31.for.cond87:
	; predecessors: %bb.30, %bb.32
	  successors: %bb.32(0x7c000000), %bb.33(0x04000000); %bb.32(96.88%), %bb.33(3.12%)

7264B	  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 15, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
7280B	  JCC_1 %bb.33, 15, implicit killed $eflags
7296B	  JMP_1 %bb.32

7312B	bb.32.for.body90:
	; predecessors: %bb.31
	  successors: %bb.31(0x80000000); %bb.31(100.00%)

7328B	  %184:gr32 = MOV32rm %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
7344B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
7360B	  $edi = COPY %184:gr32
7376B	  CALL64pcrel32 @timer_read, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
7392B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
7408B	  %185:fr64 = COPY killed $xmm0
7424B	  %186:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
7440B	  MOVSDmr %stack.10.trecs, 8, %186:gr64_nosp, 0, $noreg, %185:fr64 :: (store 8 into %ir.arrayidx92)
7456B	  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
7472B	  JMP_1 %bb.31

7488B	bb.33.for.end95:
	; predecessors: %bb.31
	  successors: %bb.34(0x50000000), %bb.35(0x30000000); %bb.34(62.50%), %bb.35(37.50%)

7504B	  %128:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
7520B	  %129:fr64 = FsFLD0SD
7536B	  UCOMISDrr %128:fr64, %129:fr64, implicit-def $eflags
7552B	  JCC_1 %bb.35, 5, implicit $eflags
7568B	  JCC_1 %bb.35, 10, implicit killed $eflags
7584B	  JMP_1 %bb.34

7600B	bb.34.if.then98:
	; predecessors: %bb.33
	  successors: %bb.35(0x80000000); %bb.35(100.00%)

7616B	  %130:gr64 = MOV64ri 4607182418800017408
7632B	  MOV64mr %stack.9.tmax, 1, $noreg, 0, $noreg, %130:gr64 :: (store 8 into %ir.tmax)

7648B	bb.35.if.end99:
	; predecessors: %bb.33, %bb.34
	  successors: %bb.36(0x80000000); %bb.36(100.00%)

7664B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
7728B	  $rdi = MOV32ri64 @.str.41
7744B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
7760B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
7776B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
7792B	  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
7808B	  %222:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.6, $noreg :: (load 8 from constant-pool)

7936B	bb.36.for.cond101:
	; predecessors: %bb.35, %bb.43
	  successors: %bb.37(0x7c000000), %bb.44(0x04000000); %bb.37(96.88%), %bb.44(3.12%)

7952B	  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 15, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
7968B	  JCC_1 %bb.44, 15, implicit killed $eflags
7984B	  JMP_1 %bb.37

8000B	bb.37.for.body104:
	; predecessors: %bb.36
	  successors: %bb.38(0x40000000), %bb.39(0x40000000); %bb.38(50.00%), %bb.39(50.00%)

8016B	  %137:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
8032B	  %138:gr64 = MOV64rm %stack.13.t_names, 8, %137:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx106)
8048B	  %139:fr64 = MOVSDrm_alt %stack.10.trecs, 8, %137:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx110)
8064B	  %141:fr64 = COPY %139:fr64
8080B	  %141:fr64 = MULSDrr %141:fr64(tied-def 0), %222:fr64
8112B	  %141:fr64 = DIVSDrm %141:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
8128B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8144B	  $rdi = MOV32ri64 @.str.42
8160B	  $rsi = COPY %138:gr64
8176B	  $xmm0 = COPY %139:fr64
8192B	  $xmm1 = COPY %141:fr64
8208B	  $al = MOV8ri 2
8224B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
8240B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8256B	  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 5, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
8272B	  JCC_1 %bb.39, 5, implicit killed $eflags
8288B	  JMP_1 %bb.38

8304B	bb.38.if.then116:
	; predecessors: %bb.37
	  successors: %bb.43(0x80000000); %bb.43(100.00%)

8320B	  %170:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 16, $noreg :: (dereferenceable load 8 from %ir.arrayidx117, align 16)
8352B	  %170:fr64 = ADDSDrm %170:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx118)
8384B	  %170:fr64 = ADDSDrm %170:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 32, $noreg :: (dereferenceable load 8 from %ir.arrayidx120, align 16)
8400B	  MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %170:fr64 :: (store 8 into %ir.t)
8416B	  %173:fr64 = COPY %170:fr64
8432B	  %173:fr64 = MULSDrr %173:fr64(tied-def 0), %222:fr64
8464B	  %173:fr64 = DIVSDrm %173:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
8480B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8496B	  $rdi = MOV32ri64 @.str.43
8512B	  $rsi = MOV32ri64 @.str.44
8528B	  $xmm0 = COPY %170:fr64
8544B	  $xmm1 = COPY %173:fr64
8560B	  $al = MOV8ri 2
8576B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
8592B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8608B	  %179:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx125)
8640B	  %179:fr64 = SUBSDrm %179:fr64(tied-def 0), %stack.8.t, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.t)
8656B	  MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %179:fr64 :: (store 8 into %ir.t)
8672B	  %181:fr64 = COPY %179:fr64
8688B	  %181:fr64 = MULSDrr %181:fr64(tied-def 0), %222:fr64
8720B	  %181:fr64 = DIVSDrm %181:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
8736B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8752B	  $rdi = MOV32ri64 @.str.43
8768B	  $rsi = MOV32ri64 @.str.45
8784B	  $xmm0 = COPY %179:fr64
8800B	  $xmm1 = COPY %181:fr64
8816B	  $al = MOV8ri 2
8832B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
8848B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8864B	  JMP_1 %bb.43

8880B	bb.39.if.else130:
	; predecessors: %bb.37
	  successors: %bb.40(0x40000000), %bb.41(0x40000000); %bb.40(50.00%), %bb.41(50.00%)

8896B	  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 8, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
8912B	  JCC_1 %bb.41, 5, implicit killed $eflags
8928B	  JMP_1 %bb.40

8944B	bb.40.if.then133:
	; predecessors: %bb.39
	  successors: %bb.43(0x80000000); %bb.43(100.00%)

8960B	  %161:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 64, $noreg :: (dereferenceable load 8 from %ir.arrayidx134, align 16)
8992B	  %161:fr64 = SUBSDrm %161:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx135)
9024B	  %161:fr64 = SUBSDrm %161:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx137, align 16)
9040B	  MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %161:fr64 :: (store 8 into %ir.t)
9056B	  %163:fr64 = COPY %161:fr64
9072B	  %163:fr64 = MULSDrr %163:fr64(tied-def 0), %222:fr64
9104B	  %163:fr64 = DIVSDrm %163:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
9120B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
9136B	  $rdi = MOV32ri64 @.str.43
9152B	  $rsi = MOV32ri64 @.str.46
9168B	  $xmm0 = COPY %161:fr64
9184B	  $xmm1 = COPY %163:fr64
9200B	  $al = MOV8ri 2
9216B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
9232B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
9248B	  JMP_1 %bb.43

9264B	bb.41.if.else142:
	; predecessors: %bb.39
	  successors: %bb.42(0x40000000), %bb.43(0x40000000); %bb.42(50.00%), %bb.43(50.00%)

9280B	  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 10, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
9296B	  JCC_1 %bb.43, 5, implicit killed $eflags
9312B	  JMP_1 %bb.42

9328B	bb.42.if.then145:
	; predecessors: %bb.41
	  successors: %bb.43(0x80000000); %bb.43(100.00%)

9344B	  %152:fr64 = MOVSDrm_alt %stack.10.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx146)
9376B	  %152:fr64 = ADDSDrm %152:fr64(tied-def 0), %stack.10.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx147, align 16)
9392B	  MOVSDmr %stack.8.t, 1, $noreg, 0, $noreg, %152:fr64 :: (store 8 into %ir.t)
9408B	  %154:fr64 = COPY %152:fr64
9424B	  %154:fr64 = MULSDrr %154:fr64(tied-def 0), %222:fr64
9456B	  %154:fr64 = DIVSDrm %154:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
9472B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
9488B	  $rdi = MOV32ri64 @.str.43
9504B	  $rsi = MOV32ri64 @.str.47
9520B	  $xmm0 = COPY %152:fr64
9536B	  $xmm1 = COPY %154:fr64
9552B	  $al = MOV8ri 2
9568B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
9584B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

9600B	bb.43.if.end154:
	; predecessors: %bb.41, %bb.42, %bb.40, %bb.38
	  successors: %bb.36(0x80000000); %bb.36(100.00%)

9616B	  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
9632B	  JMP_1 %bb.36

9648B	bb.44.if.end158:
	; predecessors: %bb.29, %bb.36
	  successors: %bb.45(0x80000000); %bb.45(100.00%)

9664B	  MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)

9680B	bb.45.return:
	; predecessors: %bb.44, %bb.13

9696B	  %220:gr32 = MOV32rm %stack.0.retval, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.retval)
9712B	  $eax = COPY %220:gr32
9728B	  RET 0, killed $eax

# End machine code for function main.

