Before MISched:
# Machine code for function main: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=4, align=4, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=4, align=4, at location [SP+8]
  fi#6: size=8, align=8, at location [SP+8]
  fi#7: size=8, align=8, at location [SP+8]
  fi#8: size=8, align=8, at location [SP+8]
  fi#9: size=8, align=8, at location [SP+8]
  fi#10: size=8, align=8, at location [SP+8]
  fi#11: size=96, align=16, at location [SP+8]
  fi#12: size=4, align=4, at location [SP+8]
  fi#13: size=1, align=1, at location [SP+8]
  fi#14: size=96, align=16, at location [SP+8]
  fi#15: size=8, align=8, at location [SP+8]
  fi#16: size=4, align=4, at location [SP+8]
Constant Pool:
  cp#0: 3.000000e+00, align=8
  cp#1: 0x3EB0C6F7A0B5ED8D, align=8
  cp#2: 3.478800e+03, align=8
  cp#3: -1.765570e+04, align=8
  cp#4: 2.802370e+04, align=8
  cp#5: 1.000000e+02, align=8
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
  MOV32mr %stack.1.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.2.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str
  $rsi = MOV32ri64 @.str.1
  CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %4:gr64 = COPY killed $rax
  MOV64mr %stack.15.fp, 1, $noreg, 0, $noreg, %4:gr64 :: (store 8 into %ir.fp)
  TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
  JCC_1 %bb.2, 4, implicit killed $eflags
  JMP_1 %bb.1

bb.1.if.then:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
  MOV64mi32 %stack.14.t_names, 1, $noreg, 8, $noreg, @.str.2 :: (store 8 into %ir.arrayidx)
  MOV64mi32 %stack.14.t_names, 1, $noreg, 16, $noreg, @.str.3 :: (store 8 into %ir.arrayidx1, align 16)
  MOV64mi32 %stack.14.t_names, 1, $noreg, 24, $noreg, @.str.4 :: (store 8 into %ir.arrayidx2)
  MOV64mi32 %stack.14.t_names, 1, $noreg, 32, $noreg, @.str.5 :: (store 8 into %ir.arrayidx3, align 16)
  MOV64mi32 %stack.14.t_names, 1, $noreg, 40, $noreg, @.str.6 :: (store 8 into %ir.arrayidx4)
  MOV64mi32 %stack.14.t_names, 1, $noreg, 48, $noreg, @.str.7 :: (store 8 into %ir.arrayidx5, align 16)
  MOV64mi32 %stack.14.t_names, 1, $noreg, 56, $noreg, @.str.8 :: (store 8 into %ir.arrayidx6)
  MOV64mi32 %stack.14.t_names, 1, $noreg, 64, $noreg, @.str.9 :: (store 8 into %ir.arrayidx7, align 16)
  MOV64mi32 %stack.14.t_names, 1, $noreg, 72, $noreg, @.str.10 :: (store 8 into %ir.arrayidx8)
  MOV64mi32 %stack.14.t_names, 1, $noreg, 80, $noreg, @.str.11 :: (store 8 into %ir.arrayidx9, align 16)
  MOV64mi32 %stack.14.t_names, 1, $noreg, 88, $noreg, @.str.12 :: (store 8 into %ir.arrayidx10)
  %5:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @fclose, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  JMP_1 %bb.3

bb.2.if.else:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  MOV32mi $rip, 1, $noreg, @timeron, $noreg, 0 :: (store 4 into @timeron)

bb.3.if.end:
; predecessors: %bb.2, %bb.1
  successors: %bb.4(0x50000000), %bb.9(0x30000000); %bb.4(62.50%), %bb.9(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.13
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.14
  $rsi = MOV32ri64 @.str.1
  CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %13:gr64 = COPY killed $rax
  MOV64mr %stack.15.fp, 1, $noreg, 0, $noreg, %13:gr64 :: (store 8 into %ir.fp)
  TEST64rr %13:gr64, %13:gr64, implicit-def $eflags
  JCC_1 %bb.9, 4, implicit killed $eflags
  JMP_1 %bb.4

bb.4.if.then15:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.15
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %24:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %26:gr64 = LEA64r %stack.4.niter, 1, $noreg, 0, $noreg
  $rdi = COPY %24:gr64
  $rsi = MOV32ri64 @.str.16
  $rdx = COPY %26:gr64
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %27:gr32 = COPY killed $eax
  MOV32mr %stack.16.result, 1, $noreg, 0, $noreg, %27:gr32 :: (store 4 into %ir.result)

bb.5.while.cond:
; predecessors: %bb.4, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %28:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %28:gr64
  CALL64pcrel32 @fgetc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %29:gr32 = COPY killed $eax
  CMP32ri8 %29:gr32, 10, implicit-def $eflags
  JCC_1 %bb.5, 5, implicit killed $eflags
  JMP_1 %bb.6

bb.6.while.end:
; predecessors: %bb.5
  successors: %bb.7(0x80000000); %bb.7(100.00%)

  %31:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %31:gr64
  $rsi = MOV32ri64 @.str.17
  $rdx = MOV32ri64 @dt
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %36:gr32 = COPY killed $eax
  MOV32mr %stack.16.result, 1, $noreg, 0, $noreg, %36:gr32 :: (store 4 into %ir.result)

bb.7.while.cond21:
; predecessors: %bb.6, %bb.7
  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)

  %37:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %37:gr64
  CALL64pcrel32 @fgetc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %38:gr32 = COPY killed $eax
  CMP32ri8 %38:gr32, 10, implicit-def $eflags
  JCC_1 %bb.7, 5, implicit killed $eflags
  JMP_1 %bb.8

bb.8.while.end25:
; predecessors: %bb.7
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %40:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %40:gr64
  $rsi = MOV32ri64 @.str.18
  $rdx = MOV32ri64 @grid_points
  $rcx = MOV32ri64 @grid_points + 4
  $r8 = MOV32ri64 @grid_points + 8
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %47:gr32 = COPY killed $eax
  MOV32mr %stack.16.result, 1, $noreg, 0, $noreg, %47:gr32 :: (store 4 into %ir.result)
  %48:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %48:gr64
  CALL64pcrel32 @fclose, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  JMP_1 %bb.10

bb.9.if.else28:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.19
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi %stack.4.niter, 1, $noreg, 0, $noreg, 200 :: (store 4 into %ir.niter)
  %18:gr64 = MOV64ri 4554169646866313825
  MOV64mr $rip, 1, $noreg, @dt, $noreg, %18:gr64 :: (store 8 into @dt)
  %19:gr64 = MOV64ri 438086664294
  MOV64mr $rip, 1, $noreg, @grid_points, $noreg, %19:gr64 :: (store 8 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`, align 4)
  MOV32mi $rip, 1, $noreg, @grid_points + 8, $noreg, 102 :: (store 4 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)

bb.10.if.end30:
; predecessors: %bb.9, %bb.8
  successors: %bb.13(0x40000000), %bb.11(0x40000000); %bb.13(50.00%), %bb.11(50.00%)

  %50:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  %51:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  %52:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.20
  $esi = COPY %50:gr32
  $edx = COPY %51:gr32
  $ecx = COPY %52:gr32
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  %58:fr64 = MOVSDrm_alt $rip, 1, $noreg, @dt, $noreg :: (dereferenceable load 8 from @dt)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.21
  $esi = COPY %57:gr32
  $xmm0 = COPY %58:fr64
  $al = MOV8ri 1
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.22
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 $rip, 1, $noreg, @grid_points, $noreg, 102, implicit-def $eflags :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  JCC_1 %bb.13, 15, implicit killed $eflags
  JMP_1 %bb.11

bb.11.lor.lhs.false:
; predecessors: %bb.10
  successors: %bb.13(0x40000000), %bb.12(0x40000000); %bb.13(50.00%), %bb.12(50.00%)

  CMP32mi8 $rip, 1, $noreg, @grid_points + 4, $noreg, 102, implicit-def $eflags :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  JCC_1 %bb.13, 15, implicit killed $eflags
  JMP_1 %bb.12

bb.12.lor.lhs.false36:
; predecessors: %bb.11
  successors: %bb.13(0x40000000), %bb.14(0x40000000); %bb.13(50.00%), %bb.14(50.00%)

  CMP32mi8 $rip, 1, $noreg, @grid_points + 8, $noreg, 103, implicit-def $eflags :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  JCC_1 %bb.14, 12, implicit killed $eflags
  JMP_1 %bb.13

bb.13.if.then38:
; predecessors: %bb.10, %bb.11, %bb.12
  successors: %bb.45(0x80000000); %bb.45(100.00%)

  %207:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  %208:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  %209:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.23
  $esi = COPY %207:gr32
  $edx = COPY %208:gr32
  $ecx = COPY %209:gr32
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.24
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
  JMP_1 %bb.45

bb.14.if.end41:
; predecessors: %bb.12
  successors: %bb.15(0x80000000); %bb.15(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @set_constants, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

bb.15.for.cond:
; predecessors: %bb.14, %bb.16
  successors: %bb.16(0x7c000000), %bb.17(0x04000000); %bb.16(96.88%), %bb.17(3.12%)

  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 11, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.17, 15, implicit killed $eflags
  JMP_1 %bb.16

bb.16.for.body:
; predecessors: %bb.15
  successors: %bb.15(0x80000000); %bb.15(100.00%)

  %206:gr32 = MOV32rm %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %206:gr32
  CALL64pcrel32 @timer_clear, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  JMP_1 %bb.15

bb.17.for.end:
; predecessors: %bb.15
  successors: %bb.18(0x80000000); %bb.18(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @initialize, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @exact_rhs, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @adi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @initialize, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

bb.18.for.cond43:
; predecessors: %bb.17, %bb.19
  successors: %bb.19(0x7c000000), %bb.20(0x04000000); %bb.19(96.88%), %bb.20(3.12%)

  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 11, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.20, 15, implicit killed $eflags
  JMP_1 %bb.19

bb.19.for.body45:
; predecessors: %bb.18
  successors: %bb.18(0x80000000); %bb.18(100.00%)

  %205:gr32 = MOV32rm %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %205:gr32
  CALL64pcrel32 @timer_clear, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  JMP_1 %bb.18

bb.20.for.end48:
; predecessors: %bb.18
  successors: %bb.21(0x80000000); %bb.21(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 1
  CALL64pcrel32 @timer_start, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi %stack.5.step, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.step)

bb.21.for.cond49:
; predecessors: %bb.20, %bb.25
  successors: %bb.22(0x7c000000), %bb.26(0x04000000); %bb.22(96.88%), %bb.26(3.12%)

  %79:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  CMP32rm %79:gr32, %stack.4.niter, 1, $noreg, 0, $noreg, implicit-def $eflags :: (dereferenceable load 4 from %ir.niter)
  JCC_1 %bb.26, 15, implicit killed $eflags
  JMP_1 %bb.22

bb.22.for.body51:
; predecessors: %bb.21
  successors: %bb.24(0x30000000), %bb.23(0x50000000); %bb.24(37.50%), %bb.23(62.50%)

  %183:gr64_with_sub_8bit = MOVSX64rm32 %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  %192:gr64_nosp = IMUL64rri32 %183:gr64_with_sub_8bit, 1717986919, implicit-def dead $eflags
  %186:gr64_with_sub_8bit = COPY %192:gr64_nosp
  %186:gr64_with_sub_8bit = SHR64ri %186:gr64_with_sub_8bit(tied-def 0), 63, implicit-def dead $eflags
  %192:gr64_nosp = SAR64ri %192:gr64_nosp(tied-def 0), 35, implicit-def dead $eflags
  %192.sub_32bit:gr64_nosp = ADD32rr %192.sub_32bit:gr64_nosp(tied-def 0), %186.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags
  %192.sub_32bit:gr64_nosp = SHL32ri %192.sub_32bit:gr64_nosp(tied-def 0), 2, implicit-def dead $eflags
  %194:gr32 = LEA64_32r %192:gr64_nosp, 4, %192:gr64_nosp, 0, $noreg
  CMP32rr %183.sub_32bit:gr64_with_sub_8bit, %194:gr32, implicit-def $eflags
  JCC_1 %bb.24, 4, implicit killed $eflags
  JMP_1 %bb.23

bb.23.lor.lhs.false53:
; predecessors: %bb.22
  successors: %bb.24(0x40000000), %bb.25(0x40000000); %bb.24(50.00%), %bb.25(50.00%)

  CMP32mi8 %stack.5.step, 1, $noreg, 0, $noreg, 1, implicit-def $eflags :: (dereferenceable load 4 from %ir.step)
  JCC_1 %bb.25, 5, implicit killed $eflags
  JMP_1 %bb.24

bb.24.if.then55:
; predecessors: %bb.22, %bb.23
  successors: %bb.25(0x80000000); %bb.25(100.00%)

  %198:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.25
  $esi = COPY %198:gr32
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.25.if.end57:
; predecessors: %bb.23, %bb.24
  successors: %bb.21(0x80000000); %bb.21(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @adi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  INC32m %stack.5.step, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.step), (dereferenceable load 4 from %ir.step)
  JMP_1 %bb.21

bb.26.for.end60:
; predecessors: %bb.21
  successors: %bb.27(0x50000000), %bb.28(0x30000000); %bb.27(62.50%), %bb.28(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 1
  CALL64pcrel32 @timer_stop, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = MOV32ri 1
  CALL64pcrel32 @timer_read, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %82:fr64 = COPY killed $xmm0
  MOVSDmr %stack.9.tmax, 1, $noreg, 0, $noreg, %82:fr64 :: (store 8 into %ir.tmax)
  %83:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %84:gr64 = LEA64r %stack.13.Class, 1, $noreg, 0, $noreg
  %85:gr64 = LEA64r %stack.12.verified, 1, $noreg, 0, $noreg
  $edi = COPY %83:gr32
  $rsi = COPY %84:gr64
  $rdx = COPY %85:gr64
  CALL64pcrel32 @verify, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %95:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  %87:fr64 = CVTSI2SDrr %95:gr32
  %88:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  %90:fr64 = CVTSI2SDrr %88:gr32
  %90:fr64 = MULSDrr %90:fr64(tied-def 0), %87:fr64
  %91:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  %93:fr64 = CVTSI2SDrr %91:gr32
  %93:fr64 = MULSDrr %93:fr64(tied-def 0), %90:fr64
  MOVSDmr %stack.8.n3, 1, $noreg, 0, $noreg, %93:fr64 :: (store 8 into %ir.n3)
  %95:gr32 = nsw ADD32rr %95:gr32(tied-def 0), %88:gr32, implicit-def dead $eflags
  %95:gr32 = nsw ADD32rr %95:gr32(tied-def 0), %91:gr32, implicit-def dead $eflags
  %97:fr64 = CVTSI2SDrr %95:gr32
  %97:fr64 = DIVSDrm %97:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  MOVSDmr %stack.6.navg, 1, $noreg, 0, $noreg, %97:fr64 :: (store 8 into %ir.navg)
  %98:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  %99:fr64 = FsFLD0SD
  UCOMISDrr %98:fr64, %99:fr64, implicit-def $eflags
  JCC_1 %bb.27, 5, implicit $eflags
  JCC_1 %bb.27, 10, implicit killed $eflags
  JMP_1 %bb.28

bb.27.if.then70:
; predecessors: %bb.26
  successors: %bb.29(0x80000000); %bb.29(100.00%)

  %101:fr64 = CVTSI2SDrm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  %101:fr64 = MULSDrm %101:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  %103:fr64 = MOVSDrm_alt %stack.8.n3, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.n3)
  %103:fr64 = MULSDrm %103:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  %109:fr64 = MOVSDrm_alt %stack.6.navg, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.navg)
  %106:fr64 = COPY %109:fr64
  %106:fr64 = MULSDrr %106:fr64(tied-def 0), %106:fr64
  %106:fr64 = MULSDrm %106:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %106:fr64 = ADDSDrr %106:fr64(tied-def 0), %103:fr64
  %109:fr64 = MULSDrm %109:fr64(tied-def 0), $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
  %109:fr64 = ADDSDrr %109:fr64(tied-def 0), %106:fr64
  %109:fr64 = MULSDrr %109:fr64(tied-def 0), %101:fr64
  %109:fr64 = DIVSDrm %109:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  MOVSDmr %stack.7.mflops, 1, $noreg, 0, $noreg, %109:fr64 :: (store 8 into %ir.mflops)
  JMP_1 %bb.29

bb.28.if.else80:
; predecessors: %bb.26
  successors: %bb.29(0x80000000); %bb.29(100.00%)

  MOV64mi32 %stack.7.mflops, 1, $noreg, 0, $noreg, 0 :: (store 8 into %ir.mflops)

bb.29.if.end81:
; predecessors: %bb.28, %bb.27
  successors: %bb.30(0x50000000), %bb.44(0x30000000); %bb.30(62.50%), %bb.44(37.50%)

  %112:gr32 = MOVSX32rm8 %stack.13.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
  %113:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  %114:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  %115:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  %116:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  %117:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  %118:fr64 = MOVSDrm_alt %stack.7.mflops, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.mflops)
  undef %221.sub_32bit:gr64_with_sub_8bit = MOV32rm %stack.12.verified, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.verified)
  ADJCALLSTACKDOWN64 88, 0, 88, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.26
  $esi = COPY %112:gr32
  $edx = COPY %113:gr32
  $ecx = COPY %114:gr32
  $r8d = COPY %115:gr32
  $r9d = COPY %116:gr32
  $xmm0 = COPY %117:fr64
  $xmm1 = COPY %118:fr64
  PUSH64i32 @.str.36, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.35, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.34, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.33, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.32, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.31, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.30, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.29, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.28, implicit-def $rsp, implicit $rsp
  PUSH64r %221:gr64_with_sub_8bit, implicit-def $rsp, implicit $rsp
  PUSH64i32 @.str.27, implicit-def $rsp, implicit $rsp
  CALL64pcrel32 @print_results, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $r8d, implicit killed $r9d, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 88, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
  JCC_1 %bb.44, 4, implicit killed $eflags
  JMP_1 %bb.30

bb.30.if.then82:
; predecessors: %bb.29
  successors: %bb.31(0x80000000); %bb.31(100.00%)

  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

bb.31.for.cond83:
; predecessors: %bb.30, %bb.32
  successors: %bb.32(0x7c000000), %bb.33(0x04000000); %bb.32(96.88%), %bb.33(3.12%)

  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 11, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.33, 15, implicit killed $eflags
  JMP_1 %bb.32

bb.32.for.body86:
; predecessors: %bb.31
  successors: %bb.31(0x80000000); %bb.31(100.00%)

  %180:gr32 = MOV32rm %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %180:gr32
  CALL64pcrel32 @timer_read, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %181:fr64 = COPY killed $xmm0
  %182:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOVSDmr %stack.11.trecs, 8, %182:gr64_nosp, 0, $noreg, %181:fr64 :: (store 8 into %ir.arrayidx88)
  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  JMP_1 %bb.31

bb.33.for.end91:
; predecessors: %bb.31
  successors: %bb.34(0x50000000), %bb.35(0x30000000); %bb.34(62.50%), %bb.35(37.50%)

  %124:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  %125:fr64 = FsFLD0SD
  UCOMISDrr %124:fr64, %125:fr64, implicit-def $eflags
  JCC_1 %bb.35, 5, implicit $eflags
  JCC_1 %bb.35, 10, implicit killed $eflags
  JMP_1 %bb.34

bb.34.if.then94:
; predecessors: %bb.33
  successors: %bb.35(0x80000000); %bb.35(100.00%)

  %126:gr64 = MOV64ri 4607182418800017408
  MOV64mr %stack.9.tmax, 1, $noreg, 0, $noreg, %126:gr64 :: (store 8 into %ir.tmax)

bb.35.if.end95:
; predecessors: %bb.33, %bb.34
  successors: %bb.36(0x80000000); %bb.36(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.37
  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
  %217:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)

bb.36.for.cond97:
; predecessors: %bb.35, %bb.43
  successors: %bb.37(0x7c000000), %bb.44(0x04000000); %bb.37(96.88%), %bb.44(3.12%)

  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 11, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.44, 15, implicit killed $eflags
  JMP_1 %bb.37

bb.37.for.body100:
; predecessors: %bb.36
  successors: %bb.38(0x40000000), %bb.39(0x40000000); %bb.38(50.00%), %bb.39(50.00%)

  %133:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %134:gr64 = MOV64rm %stack.14.t_names, 8, %133:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx102)
  %135:fr64 = MOVSDrm_alt %stack.11.trecs, 8, %133:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx106)
  %137:fr64 = COPY %135:fr64
  %137:fr64 = MULSDrr %137:fr64(tied-def 0), %217:fr64
  %137:fr64 = DIVSDrm %137:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.38
  $rsi = COPY %134:gr64
  $xmm0 = COPY %135:fr64
  $xmm1 = COPY %137:fr64
  $al = MOV8ri 2
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 5, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.39, 5, implicit killed $eflags
  JMP_1 %bb.38

bb.38.if.then112:
; predecessors: %bb.37
  successors: %bb.43(0x80000000); %bb.43(100.00%)

  %166:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 16, $noreg :: (dereferenceable load 8 from %ir.arrayidx113, align 16)
  %166:fr64 = ADDSDrm %166:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx114)
  %166:fr64 = ADDSDrm %166:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 32, $noreg :: (dereferenceable load 8 from %ir.arrayidx116, align 16)
  MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %166:fr64 :: (store 8 into %ir.t)
  %169:fr64 = COPY %166:fr64
  %169:fr64 = MULSDrr %169:fr64(tied-def 0), %217:fr64
  %169:fr64 = DIVSDrm %169:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.39
  $rsi = MOV32ri64 @.str.40
  $xmm0 = COPY %166:fr64
  $xmm1 = COPY %169:fr64
  $al = MOV8ri 2
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %175:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx121)
  %175:fr64 = SUBSDrm %175:fr64(tied-def 0), %stack.10.t, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.t)
  MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %175:fr64 :: (store 8 into %ir.t)
  %177:fr64 = COPY %175:fr64
  %177:fr64 = MULSDrr %177:fr64(tied-def 0), %217:fr64
  %177:fr64 = DIVSDrm %177:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.39
  $rsi = MOV32ri64 @.str.41
  $xmm0 = COPY %175:fr64
  $xmm1 = COPY %177:fr64
  $al = MOV8ri 2
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  JMP_1 %bb.43

bb.39.if.else126:
; predecessors: %bb.37
  successors: %bb.40(0x40000000), %bb.41(0x40000000); %bb.40(50.00%), %bb.41(50.00%)

  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 8, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.41, 5, implicit killed $eflags
  JMP_1 %bb.40

bb.40.if.then129:
; predecessors: %bb.39
  successors: %bb.43(0x80000000); %bb.43(100.00%)

  %157:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 64, $noreg :: (dereferenceable load 8 from %ir.arrayidx130, align 16)
  %157:fr64 = SUBSDrm %157:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx131)
  %157:fr64 = SUBSDrm %157:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx133, align 16)
  MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %157:fr64 :: (store 8 into %ir.t)
  %159:fr64 = COPY %157:fr64
  %159:fr64 = MULSDrr %159:fr64(tied-def 0), %217:fr64
  %159:fr64 = DIVSDrm %159:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.39
  $rsi = MOV32ri64 @.str.42
  $xmm0 = COPY %157:fr64
  $xmm1 = COPY %159:fr64
  $al = MOV8ri 2
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  JMP_1 %bb.43

bb.41.if.else138:
; predecessors: %bb.39
  successors: %bb.42(0x40000000), %bb.43(0x40000000); %bb.42(50.00%), %bb.43(50.00%)

  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 10, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
  JCC_1 %bb.43, 5, implicit killed $eflags
  JMP_1 %bb.42

bb.42.if.then141:
; predecessors: %bb.41
  successors: %bb.43(0x80000000); %bb.43(100.00%)

  %148:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx142)
  %148:fr64 = ADDSDrm %148:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx143, align 16)
  MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %148:fr64 :: (store 8 into %ir.t)
  %150:fr64 = COPY %148:fr64
  %150:fr64 = MULSDrr %150:fr64(tied-def 0), %217:fr64
  %150:fr64 = DIVSDrm %150:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str.39
  $rsi = MOV32ri64 @.str.43
  $xmm0 = COPY %148:fr64
  $xmm1 = COPY %150:fr64
  $al = MOV8ri 2
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.43.if.end150:
; predecessors: %bb.41, %bb.42, %bb.40, %bb.38
  successors: %bb.36(0x80000000); %bb.36(100.00%)

  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  JMP_1 %bb.36

bb.44.if.end154:
; predecessors: %bb.29, %bb.36
  successors: %bb.45(0x80000000); %bb.45(100.00%)

  MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)

bb.45.return:
; predecessors: %bb.44, %bb.13

  %216:gr32 = MOV32rm %stack.0.retval, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.retval)
  $eax = COPY %216:gr32
  RET 0, killed $eax

# End machine code for function main.

********** MI Scheduling **********
main:%bb.0 entry
  From: %4:gr64 = COPY killed $rax
    To: JCC_1 %bb.2, 4, implicit killed $eflags
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %4:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(2): Data Latency=0 Reg=%4
    SU(1): Data Latency=0 Reg=%4
  Single Issue       : false;
SU(1):   MOV64mr %stack.15.fp, 1, $noreg, 0, $noreg, %4:gr64 :: (store 8 into %ir.fp)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%4
  Single Issue       : false;
SU(2):   TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%4
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.2, 4, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %stack.15.fp, 1, $noreg, 0, $noreg, %4:gr64 :: (store 8 into %ir.fp)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %4:gr64 = COPY killed $rax
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %4:gr64 = COPY killed $rax
SU(1):   MOV64mr %stack.15.fp, 1, $noreg, 0, $noreg, %4:gr64 :: (store 8 into %ir.fp)
SU(2):   TEST64rr %4:gr64, %4:gr64, implicit-def $eflags

********** MI Scheduling **********
main:%bb.0 entry
  From: $rdi = MOV32ri64 @.str
    To: CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.1
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   $rdi = MOV32ri64 @.str
SU(1):   $rsi = MOV32ri64 @.str.1

********** MI Scheduling **********
main:%bb.0 entry
  From: %1:gr64 = COPY $rsi
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %1:gr64 = COPY $rsi
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(4): Data Latency=0 Reg=%1
  Single Issue       : false;
SU(1):   %0:gr32 = COPY $edi
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(3): Data Latency=0 Reg=%0
  Single Issue       : false;
SU(2):   MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(3):   MOV32mr %stack.1.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Data Latency=0 Reg=%0
  Single Issue       : false;
SU(4):   MOV64mr %stack.2.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%1
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) MOV64mr %stack.2.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 0 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) MOV32mr %stack.1.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 0 1 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %0:gr32 = COPY $edi
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %1:gr64 = COPY $rsi
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %1:gr64 = COPY $rsi
SU(1):   %0:gr32 = COPY $edi
SU(2):   MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
SU(3):   MOV32mr %stack.1.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
SU(4):   MOV64mr %stack.2.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)

********** MI Scheduling **********
main:%bb.1 if.then
  From: MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 13
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GR16=2
Live In: 
Live Out: %5 
Live Thru: 
  LiveReg: %5
Top Pressure:

Bottom Pressure:
GR16=2
Excess PSets: 
SU(0):   MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : 
  Single Issue       : false;
SU(1):   MOV64mi32 %stack.14.t_names, 1, $noreg, 8, $noreg, @.str.2 :: (store 8 into %ir.arrayidx)
  # preds left       : 0
  # succs left       : 10
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(2):   MOV64mi32 %stack.14.t_names, 1, $noreg, 16, $noreg, @.str.3 :: (store 8 into %ir.arrayidx1, align 16)
  # preds left       : 1
  # succs left       : 9
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(3):   MOV64mi32 %stack.14.t_names, 1, $noreg, 24, $noreg, @.str.4 :: (store 8 into %ir.arrayidx2)
  # preds left       : 2
  # succs left       : 8
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(4):   MOV64mi32 %stack.14.t_names, 1, $noreg, 32, $noreg, @.str.5 :: (store 8 into %ir.arrayidx3, align 16)
  # preds left       : 3
  # succs left       : 7
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(5):   MOV64mi32 %stack.14.t_names, 1, $noreg, 40, $noreg, @.str.6 :: (store 8 into %ir.arrayidx4)
  # preds left       : 4
  # succs left       : 6
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(6):   MOV64mi32 %stack.14.t_names, 1, $noreg, 48, $noreg, @.str.7 :: (store 8 into %ir.arrayidx5, align 16)
  # preds left       : 5
  # succs left       : 5
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   MOV64mi32 %stack.14.t_names, 1, $noreg, 56, $noreg, @.str.8 :: (store 8 into %ir.arrayidx6)
  # preds left       : 6
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(8):   MOV64mi32 %stack.14.t_names, 1, $noreg, 64, $noreg, @.str.9 :: (store 8 into %ir.arrayidx7, align 16)
  # preds left       : 7
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(9):   MOV64mi32 %stack.14.t_names, 1, $noreg, 72, $noreg, @.str.10 :: (store 8 into %ir.arrayidx8)
  # preds left       : 8
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(11): Ord  Latency=0 Memory
    SU(10): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(10):   MOV64mi32 %stack.14.t_names, 1, $noreg, 80, $noreg, @.str.11 :: (store 8 into %ir.arrayidx9, align 16)
  # preds left       : 9
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Successors:
    SU(11): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(11):   MOV64mi32 %stack.14.t_names, 1, $noreg, 88, $noreg, @.str.12 :: (store 8 into %ir.arrayidx10)
  # preds left       : 10
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(10): Ord  Latency=0 Memory
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(4): Ord  Latency=0 Memory
    SU(3): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(12):   %5:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(12): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 11 0 12 
  Cand SU(11) ORDER                              
  Cand SU(12) ORDER                              
Pick Bot ORDER     
Scheduling SU(12) %5:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
Bottom Pressure:

  Ready @3c
  BotQ.A BotLatency SU(12) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 11 0 
  Cand SU(11) ORDER                              
Pick Bot ORDER     
Scheduling SU(11) MOV64mi32 %stack.14.t_names, 1, $noreg, 88, $noreg, @.str.12 :: (store 8 into %ir.arrayidx10)
Bottom Pressure:

  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 10 
  Cand SU(0) ORDER                              
  Cand SU(10) ORDER                              
Pick Bot ORDER     
Scheduling SU(10) MOV64mi32 %stack.14.t_names, 1, $noreg, 80, $noreg, @.str.11 :: (store 8 into %ir.arrayidx9, align 16)
Bottom Pressure:

  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 9 
  Cand SU(0) ORDER                              
  Cand SU(9) ORDER                              
Pick Bot ORDER     
Scheduling SU(9) MOV64mi32 %stack.14.t_names, 1, $noreg, 72, $noreg, @.str.10 :: (store 8 into %ir.arrayidx8)
Bottom Pressure:

  Ready @0c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 8 
  Cand SU(0) ORDER                              
  Cand SU(8) ORDER                              
Pick Bot ORDER     
Scheduling SU(8) MOV64mi32 %stack.14.t_names, 1, $noreg, 64, $noreg, @.str.9 :: (store 8 into %ir.arrayidx7, align 16)
Bottom Pressure:

  Ready @1c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 7 
  Cand SU(0) ORDER                              
  Cand SU(7) ORDER                              
Pick Bot ORDER     
Scheduling SU(7) MOV64mi32 %stack.14.t_names, 1, $noreg, 56, $noreg, @.str.8 :: (store 8 into %ir.arrayidx6)
Bottom Pressure:

  Ready @1c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 6 
  Cand SU(0) ORDER                              
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) MOV64mi32 %stack.14.t_names, 1, $noreg, 48, $noreg, @.str.7 :: (store 8 into %ir.arrayidx5, align 16)
Bottom Pressure:

  Ready @1c
BotQ.A @1c
  Retired: 7
  Executed: 1c
  Critical: 1c, 7 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 5 
  Cand SU(0) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) MOV64mi32 %stack.14.t_names, 1, $noreg, 40, $noreg, @.str.6 :: (store 8 into %ir.arrayidx4)
Bottom Pressure:

  Ready @1c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 2c
  Critical: 2c, 8 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 4 
  Cand SU(0) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) MOV64mi32 %stack.14.t_names, 1, $noreg, 32, $noreg, @.str.5 :: (store 8 into %ir.arrayidx3, align 16)
Bottom Pressure:

  Ready @2c
BotQ.A @2c
  Retired: 9
  Executed: 2c
  Critical: 2c, 9 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 
  Cand SU(0) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) MOV64mi32 %stack.14.t_names, 1, $noreg, 24, $noreg, @.str.4 :: (store 8 into %ir.arrayidx2)
Bottom Pressure:

  Ready @2c
BotQ.A @2c
  Retired: 10
  Executed: 2c
  Critical: 2c, 10 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 
  Cand SU(0) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) MOV64mi32 %stack.14.t_names, 1, $noreg, 16, $noreg, @.str.3 :: (store 8 into %ir.arrayidx1, align 16)
Bottom Pressure:

  Ready @2c
BotQ.A @2c
  Retired: 11
  Executed: 2c
  Critical: 2c, 11 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) MOV64mi32 %stack.14.t_names, 1, $noreg, 8, $noreg, @.str.2 :: (store 8 into %ir.arrayidx)
Bottom Pressure:

  Ready @2c
  *** Max MOps 4 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 12
  Executed: 3c
  Critical: 3c, 12 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
Bottom Pressure:

  Ready @3c
BotQ.A @3c
  Retired: 13
  Executed: 3c
  Critical: 3c, 13 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.1 ***
SU(0):   MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
SU(1):   MOV64mi32 %stack.14.t_names, 1, $noreg, 8, $noreg, @.str.2 :: (store 8 into %ir.arrayidx)
SU(2):   MOV64mi32 %stack.14.t_names, 1, $noreg, 16, $noreg, @.str.3 :: (store 8 into %ir.arrayidx1, align 16)
SU(3):   MOV64mi32 %stack.14.t_names, 1, $noreg, 24, $noreg, @.str.4 :: (store 8 into %ir.arrayidx2)
SU(4):   MOV64mi32 %stack.14.t_names, 1, $noreg, 32, $noreg, @.str.5 :: (store 8 into %ir.arrayidx3, align 16)
SU(5):   MOV64mi32 %stack.14.t_names, 1, $noreg, 40, $noreg, @.str.6 :: (store 8 into %ir.arrayidx4)
SU(6):   MOV64mi32 %stack.14.t_names, 1, $noreg, 48, $noreg, @.str.7 :: (store 8 into %ir.arrayidx5, align 16)
SU(7):   MOV64mi32 %stack.14.t_names, 1, $noreg, 56, $noreg, @.str.8 :: (store 8 into %ir.arrayidx6)
SU(8):   MOV64mi32 %stack.14.t_names, 1, $noreg, 64, $noreg, @.str.9 :: (store 8 into %ir.arrayidx7, align 16)
SU(9):   MOV64mi32 %stack.14.t_names, 1, $noreg, 72, $noreg, @.str.10 :: (store 8 into %ir.arrayidx8)
SU(10):   MOV64mi32 %stack.14.t_names, 1, $noreg, 80, $noreg, @.str.11 :: (store 8 into %ir.arrayidx9, align 16)
SU(11):   MOV64mi32 %stack.14.t_names, 1, $noreg, 88, $noreg, @.str.12 :: (store 8 into %ir.arrayidx10)
SU(12):   %5:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)

********** MI Scheduling **********
main:%bb.3 if.end
  From: %13:gr64 = COPY killed $rax
    To: JCC_1 %bb.9, 4, implicit killed $eflags
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %13:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(2): Data Latency=0 Reg=%13
    SU(1): Data Latency=0 Reg=%13
  Single Issue       : false;
SU(1):   MOV64mr %stack.15.fp, 1, $noreg, 0, $noreg, %13:gr64 :: (store 8 into %ir.fp)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%13
  Single Issue       : false;
SU(2):   TEST64rr %13:gr64, %13:gr64, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%13
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.9, 4, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) TEST64rr %13:gr64, %13:gr64, implicit-def $eflags
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %stack.15.fp, 1, $noreg, 0, $noreg, %13:gr64 :: (store 8 into %ir.fp)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %13:gr64 = COPY killed $rax
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.3 ***
SU(0):   %13:gr64 = COPY killed $rax
SU(1):   MOV64mr %stack.15.fp, 1, $noreg, 0, $noreg, %13:gr64 :: (store 8 into %ir.fp)
SU(2):   TEST64rr %13:gr64, %13:gr64, implicit-def $eflags

********** MI Scheduling **********
main:%bb.3 if.end
  From: $rdi = MOV32ri64 @.str.14
    To: CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.14
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.1
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.14
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.3 ***
SU(0):   $rdi = MOV32ri64 @.str.14
SU(1):   $rsi = MOV32ri64 @.str.1

********** MI Scheduling **********
main:%bb.3 if.end
  From: $rdi = MOV32ri64 @.str.13
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.13
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.13
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.3 ***
SU(0):   $rdi = MOV32ri64 @.str.13
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.4 if.then15
  From: %27:gr32 = COPY killed $eax
    To: End RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %27:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Data Latency=0 Reg=%27
  Single Issue       : false;
SU(1):   MOV32mr %stack.16.result, 1, $noreg, 0, $noreg, %27:gr32 :: (store 4 into %ir.result)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%27
  Single Issue       : false;
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV32mr %stack.16.result, 1, $noreg, 0, $noreg, %27:gr32 :: (store 4 into %ir.result)
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %27:gr32 = COPY killed $eax
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   %27:gr32 = COPY killed $eax
SU(1):   MOV32mr %stack.16.result, 1, $noreg, 0, $noreg, %27:gr32 :: (store 4 into %ir.result)

********** MI Scheduling **********
main:%bb.4 if.then15
  From: %26:gr64 = LEA64r %stack.4.niter, 1, $noreg, 0, $noreg
    To: CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %26:gr64 = LEA64r %stack.4.niter, 1, $noreg, 0, $noreg
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(3): Data Latency=1 Reg=%26
  Single Issue       : false;
SU(1):   $rdi = COPY %24:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $rsi = MOV32ri64 @.str.16
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(3):   $rdx = COPY %26:gr64
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(0): Data Latency=1 Reg=%26
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 3 2 
  Cand SU(1) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) $rdx = COPY %26:gr64
  Ready @0c
  BotQ.A TopLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) $rdi = COPY %24:gr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 
  Cand SU(0) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $rsi = MOV32ri64 @.str.16
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %26:gr64 = LEA64r %stack.4.niter, 1, $noreg, 0, $noreg
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   %26:gr64 = LEA64r %stack.4.niter, 1, $noreg, 0, $noreg
SU(2):   $rsi = MOV32ri64 @.str.16
SU(1):   $rdi = COPY %24:gr64
SU(3):   $rdx = COPY %26:gr64
SU(4):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.4 if.then15
  From: $rdi = MOV32ri64 @.str.15
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.15
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.15
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   $rdi = MOV32ri64 @.str.15
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.5 while.cond
  From: %29:gr32 = COPY killed $eax
    To: JCC_1 %bb.5, 5, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %29:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%29
  Single Issue       : false;
SU(1):   CMP32ri8 %29:gr32, 10, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%29
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.5, 5, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32ri8 %29:gr32, 10, implicit-def $eflags
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %29:gr32 = COPY killed $eax
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.5 ***
SU(0):   %29:gr32 = COPY killed $eax
SU(1):   CMP32ri8 %29:gr32, 10, implicit-def $eflags

********** MI Scheduling **********
main:%bb.6 while.end
  From: %36:gr32 = COPY killed $eax
    To: End RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %36:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Data Latency=0 Reg=%36
  Single Issue       : false;
SU(1):   MOV32mr %stack.16.result, 1, $noreg, 0, $noreg, %36:gr32 :: (store 4 into %ir.result)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%36
  Single Issue       : false;
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV32mr %stack.16.result, 1, $noreg, 0, $noreg, %36:gr32 :: (store 4 into %ir.result)
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %36:gr32 = COPY killed $eax
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(0):   %36:gr32 = COPY killed $eax
SU(1):   MOV32mr %stack.16.result, 1, $noreg, 0, $noreg, %36:gr32 :: (store 4 into %ir.result)

********** MI Scheduling **********
main:%bb.6 while.end
  From: $rdi = COPY %31:gr64
    To: CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %31:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.17
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $rdx = MOV32ri64 @dt
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(3):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=1 Artificial
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 1 0 
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 1 
  Cand SU(0) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(0) $rdi = COPY %31:gr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $rdx = MOV32ri64 @dt
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) $rsi = MOV32ri64 @.str.17
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(1):   $rsi = MOV32ri64 @.str.17
SU(2):   $rdx = MOV32ri64 @dt
SU(0):   $rdi = COPY %31:gr64
SU(3):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.7 while.cond21
  From: %38:gr32 = COPY killed $eax
    To: JCC_1 %bb.7, 5, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %38:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=0 Reg=%38
  Single Issue       : false;
SU(1):   CMP32ri8 %38:gr32, 10, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Predecessors:
    SU(0): Data Latency=0 Reg=%38
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.7, 5, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32ri8 %38:gr32, 10, implicit-def $eflags
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %38:gr32 = COPY killed $eax
  Ready @1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.7 ***
SU(0):   %38:gr32 = COPY killed $eax
SU(1):   CMP32ri8 %38:gr32, 10, implicit-def $eflags

********** MI Scheduling **********
main:%bb.8 while.end25
  From: %47:gr32 = COPY killed $eax
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %47:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Data Latency=0 Reg=%47
  Single Issue       : false;
SU(1):   MOV32mr %stack.16.result, 1, $noreg, 0, $noreg, %47:gr32 :: (store 4 into %ir.result)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%47
  Single Issue       : false;
SU(2):   %48:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %48:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
  Ready @3c
  BotQ.A BotLatency SU(2) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV32mr %stack.16.result, 1, $noreg, 0, $noreg, %47:gr32 :: (store 4 into %ir.result)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %47:gr32 = COPY killed $eax
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.8 ***
SU(0):   %47:gr32 = COPY killed $eax
SU(1):   MOV32mr %stack.16.result, 1, $noreg, 0, $noreg, %47:gr32 :: (store 4 into %ir.result)
SU(2):   %48:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)

********** MI Scheduling **********
main:%bb.8 while.end25
  From: $rdi = COPY %40:gr64
    To: CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %40:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.18
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $rdx = MOV32ri64 @grid_points
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(3):   $rcx = MOV32ri64 @grid_points + 4
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(4):   $r8 = MOV32ri64 @grid_points + 8
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(5):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  # preds left       : 6
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=1 Artificial
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=1 Artificial
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 4 3 2 1 0 
  Cand SU(5) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(5) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(5) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 4 3 2 1 
  Cand SU(0) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(0) $rdi = COPY %40:gr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 4 3 2 
  Cand SU(1) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) $r8 = MOV32ri64 @grid_points + 8
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 3 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) $rcx = MOV32ri64 @grid_points + 4
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $rdx = MOV32ri64 @grid_points
  Ready @1c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) $rsi = MOV32ri64 @.str.18
  Ready @1c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.8 ***
SU(1):   $rsi = MOV32ri64 @.str.18
SU(2):   $rdx = MOV32ri64 @grid_points
SU(3):   $rcx = MOV32ri64 @grid_points + 4
SU(4):   $r8 = MOV32ri64 @grid_points + 8
SU(0):   $rdi = COPY %40:gr64
SU(5):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.9 if.else28
  From: MOV32mi %stack.4.niter, 1, $noreg, 0, $noreg, 200 :: (store 4 into %ir.niter)
    To: End RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV32mi %stack.4.niter, 1, $noreg, 0, $noreg, 200 :: (store 4 into %ir.niter)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   %18:gr64 = MOV64ri 4554169646866313825
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(2): Data Latency=1 Reg=%18
  Single Issue       : false;
SU(2):   MOV64mr $rip, 1, $noreg, @dt, $noreg, %18:gr64 :: (store 8 into @dt)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%18
  Single Issue       : false;
SU(3):   %19:gr64 = MOV64ri 438086664294
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(4): Data Latency=1 Reg=%19
  Single Issue       : false;
SU(4):   MOV64mr $rip, 1, $noreg, @grid_points, $noreg, %19:gr64 :: (store 8 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`, align 4)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(3): Data Latency=1 Reg=%19
  Successors:
    SU(5): Ord  Latency=0 Memory
  Single Issue       : false;
SU(5):   MOV32mi $rip, 1, $noreg, @grid_points + 8, $noreg, 102 :: (store 4 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=0 Memory
  Single Issue       : false;
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 2 0 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) MOV32mi $rip, 1, $noreg, @grid_points + 8, $noreg, 102 :: (store 4 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  Ready @0c
  BotQ.A TopLatency SU(5) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 4 
  Cand SU(0) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) MOV64mr $rip, 1, $noreg, @grid_points, $noreg, %19:gr64 :: (store 8 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`, align 4)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 3 
  Cand SU(0) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %19:gr64 = MOV64ri 438086664294
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 
  Cand SU(0) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) MOV64mr $rip, 1, $noreg, @dt, $noreg, %18:gr64 :: (store 8 into @dt)
  Ready @0c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %18:gr64 = MOV64ri 4554169646866313825
  Ready @1c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV32mi %stack.4.niter, 1, $noreg, 0, $noreg, 200 :: (store 4 into %ir.niter)
  Ready @1c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.9 ***
SU(0):   MOV32mi %stack.4.niter, 1, $noreg, 0, $noreg, 200 :: (store 4 into %ir.niter)
SU(1):   %18:gr64 = MOV64ri 4554169646866313825
SU(2):   MOV64mr $rip, 1, $noreg, @dt, $noreg, %18:gr64 :: (store 8 into @dt)
SU(3):   %19:gr64 = MOV64ri 438086664294
SU(4):   MOV64mr $rip, 1, $noreg, @grid_points, $noreg, %19:gr64 :: (store 8 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`, align 4)
SU(5):   MOV32mi $rip, 1, $noreg, @grid_points + 8, $noreg, 102 :: (store 4 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)

********** MI Scheduling **********
main:%bb.9 if.else28
  From: $rdi = MOV32ri64 @.str.19
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.19
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.19
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.9 ***
SU(0):   $rdi = MOV32ri64 @.str.19
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.10 if.end30
  From: $rdi = MOV32ri64 @.str.22
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.22
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.22
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(0):   $rdi = MOV32ri64 @.str.22
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.10 if.end30
  From: $rdi = MOV32ri64 @.str.21
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.21
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %57:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %58:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $al = MOV8ri 1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=1 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 1 0 
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) $al = MOV8ri 1
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 1 
  Cand SU(0) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) $xmm0 = COPY %58:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %57:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.21
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(0):   $rdi = MOV32ri64 @.str.21
SU(1):   $esi = COPY %57:gr32
SU(2):   $xmm0 = COPY %58:fr64
SU(3):   $al = MOV8ri 1

********** MI Scheduling **********
main:%bb.10 if.end30
  From: %57:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %57:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
SU(1):   %58:fr64 = MOVSDrm_alt $rip, 1, $noreg, @dt, $noreg :: (dereferenceable load 8 from @dt)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=3 Artificial
    SU(0): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %58:fr64 = MOVSDrm_alt $rip, 1, $noreg, @dt, $noreg :: (dereferenceable load 8 from @dt)
  Ready @3c
  BotQ.A BotLatency SU(1) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %57:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  Ready @3c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(0):   %57:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
SU(1):   %58:fr64 = MOVSDrm_alt $rip, 1, $noreg, @dt, $noreg :: (dereferenceable load 8 from @dt)

********** MI Scheduling **********
main:%bb.10 if.end30
  From: $rdi = MOV32ri64 @.str.20
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.20
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %50:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $edx = COPY %51:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $ecx = COPY %52:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $ecx = COPY %52:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $edx = COPY %51:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %50:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.20
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(0):   $rdi = MOV32ri64 @.str.20
SU(1):   $esi = COPY %50:gr32
SU(2):   $edx = COPY %51:gr32
SU(3):   $ecx = COPY %52:gr32
SU(4):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.10 if.end30
  From: %50:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %50:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
SU(1):   %51:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
SU(2):   %52:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=3 Artificial
    SU(1): Ord  Latency=3 Artificial
    SU(0): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %52:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  Ready @3c
  BotQ.A BotLatency SU(2) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %51:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  Ready @3c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %50:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  Ready @3c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(0):   %50:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
SU(1):   %51:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
SU(2):   %52:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)

********** MI Scheduling **********
main:%bb.13 if.then38
  From: $rdi = MOV32ri64 @.str.24
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.24
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.24
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.13 ***
SU(0):   $rdi = MOV32ri64 @.str.24
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.13 if.then38
  From: $rdi = MOV32ri64 @.str.23
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.23
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %207:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $edx = COPY %208:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $ecx = COPY %209:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $ecx = COPY %209:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $edx = COPY %208:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %207:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.23
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.13 ***
SU(0):   $rdi = MOV32ri64 @.str.23
SU(1):   $esi = COPY %207:gr32
SU(2):   $edx = COPY %208:gr32
SU(3):   $ecx = COPY %209:gr32
SU(4):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.13 if.then38
  From: %207:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %207:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
SU(1):   %208:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
SU(2):   %209:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=3 Artificial
    SU(1): Ord  Latency=3 Artificial
    SU(0): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %209:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  Ready @3c
  BotQ.A BotLatency SU(2) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %208:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  Ready @3c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %207:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  Ready @3c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.13 ***
SU(0):   %207:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
SU(1):   %208:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
SU(2):   %209:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)

********** MI Scheduling **********
main:%bb.21 for.cond49
  From: %79:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
    To: JCC_1 %bb.26, 15, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %79:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 8
  Successors:
    SU(1): Data Latency=4 Reg=%79
  Single Issue       : false;
SU(1):   CMP32rm %79:gr32, %stack.4.niter, 1, $noreg, 0, $noreg, implicit-def $eflags :: (dereferenceable load 4 from %ir.niter)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 4
  Predecessors:
    SU(0): Data Latency=4 Reg=%79
  Successors:
    ExitSU: Ord  Latency=4 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.26, 15, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=4 Artificial
Critical Path(GS-RR ): 8
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32rm %79:gr32, %stack.4.niter, 1, $noreg, 0, $noreg, implicit-def $eflags :: (dereferenceable load 4 from %ir.niter)
  Ready @4c
  BotQ.A TopLatency SU(1) 4c
  BotQ.A BotLatency SU(1) 4c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %79:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  Ready @8c
  BotQ.A BotLatency SU(0) 8c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.21 ***
SU(0):   %79:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
SU(1):   CMP32rm %79:gr32, %stack.4.niter, 1, $noreg, 0, $noreg, implicit-def $eflags :: (dereferenceable load 4 from %ir.niter)

********** MI Scheduling **********
main:%bb.22 for.body51
  From: %183:gr64_with_sub_8bit = MOVSX64rm32 %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
    To: JCC_1 %bb.24, 4, implicit killed $eflags
 RegionInstrs: 9
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GR16=6
Live In: 
Live Out: 
Live Thru: 
Top Pressure:

Bottom Pressure:

Excess PSets: 
SU(0):   %183:gr64_with_sub_8bit = MOVSX64rm32 %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 10
  Successors:
    SU(8): Data Latency=4 Reg=%183
    SU(1): Data Latency=4 Reg=%183
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(1):   %192:gr64_nosp = IMUL64rri32 %183:gr64_with_sub_8bit, 1717986919, implicit-def dead $eflags
  # preds left       : 1
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(0): Data Latency=4 Reg=%183
  Successors:
    SU(4): Data Latency=1 Reg=%192
    SU(2): Data Latency=1 Reg=%192
    SU(4): Out  Latency=0
    SU(8): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(2):   %186:gr64_with_sub_8bit = COPY %192:gr64_nosp
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 0
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(1): Data Latency=1 Reg=%192
  Successors:
    SU(3): Data Latency=0 Reg=%186
    SU(3): Out  Latency=0
    SU(4): Anti Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(3):   %186:gr64_with_sub_8bit = SHR64ri %186:gr64_with_sub_8bit(tied-def 0), 63, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(2): Data Latency=0 Reg=%186
    SU(2): Out  Latency=0
  Successors:
    SU(5): Data Latency=1 Reg=%186
    SU(8): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(4):   %192:gr64_nosp = SAR64ri %192:gr64_nosp(tied-def 0), 35, implicit-def dead $eflags
  # preds left       : 3
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(2): Anti Latency=0
    SU(1): Data Latency=1 Reg=%192
    SU(1): Out  Latency=0
  Successors:
    SU(5): Data Latency=1 Reg=%192
    SU(5): Out  Latency=0
    SU(8): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(5):   %192.sub_32bit:gr64_nosp = ADD32rr %192.sub_32bit:gr64_nosp(tied-def 0), %186.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags
  # preds left       : 3
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(4): Data Latency=1 Reg=%192
    SU(4): Out  Latency=0
    SU(3): Data Latency=1 Reg=%186
  Successors:
    SU(6): Data Latency=1 Reg=%192
    SU(6): Out  Latency=0
    SU(8): Out  Latency=0
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(6):   %192.sub_32bit:gr64_nosp = SHL32ri %192.sub_32bit:gr64_nosp(tied-def 0), 2, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1 Reg=%192
    SU(5): Out  Latency=0
  Successors:
    SU(7): Data Latency=1 Reg=%192
    SU(8): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   %194:gr32 = LEA64_32r %192:gr64_nosp, 4, %192:gr64_nosp, 0, $noreg
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1 Reg=%192
  Successors:
    SU(8): Data Latency=1 Reg=%194
  Pressure Diff      : 
  Single Issue       : false;
SU(8):   CMP32rr %183.sub_32bit:gr64_with_sub_8bit, %194:gr32, implicit-def $eflags
  # preds left       : 7
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(7): Data Latency=1 Reg=%194
    SU(6): Out  Latency=0
    SU(5): Out  Latency=0
    SU(4): Out  Latency=0
    SU(3): Out  Latency=0
    SU(1): Out  Latency=0
    SU(0): Data Latency=4 Reg=%183
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Pressure Diff      : GR16 4
  Single Issue       : false;
ExitSU:   JCC_1 %bb.24, 4, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(8): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 10
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 
Scheduling SU(8) CMP32rr %183.sub_32bit:gr64_with_sub_8bit, %194:gr32, implicit-def $eflags
Bottom Pressure:
GR16=4
  LiveReg: %183
  UpdateRegP: SU(1) %192:gr64_nosp = IMUL64rri32 %183:gr64_with_sub_8bit, 1717986919, implicit-def dead $eflags
              to GR16 -2
  UpdateRegP: SU(8) CMP32rr %183.sub_32bit:gr64_with_sub_8bit, %194:gr32, implicit-def $eflags
              to GR16 2
  LiveReg: %194
  UpdateRegP: SU(8) CMP32rr %183.sub_32bit:gr64_with_sub_8bit, %194:gr32, implicit-def $eflags
              to 
  Ready @1c
  BotQ.A TopLatency SU(8) 9c
  BotQ.A BotLatency SU(8) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 
Scheduling SU(7) %194:gr32 = LEA64_32r %192:gr64_nosp, 4, %192:gr64_nosp, 0, $noreg
Bottom Pressure:
GR16=4
  LiveReg: %192
  UpdateRegP: SU(7) %194:gr32 = LEA64_32r %192:gr64_nosp, 4, %192:gr64_nosp, 0, $noreg
              to GR16 -2
  Ready @2c
  BotQ.A BotLatency SU(7) 2c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 
Scheduling SU(6) %192.sub_32bit:gr64_nosp = SHL32ri %192.sub_32bit:gr64_nosp(tied-def 0), 2, implicit-def dead $eflags
Bottom Pressure:
GR16=4
  LiveReg: %192
  UpdateRegP: SU(6) %192.sub_32bit:gr64_nosp = SHL32ri %192.sub_32bit:gr64_nosp(tied-def 0), 2, implicit-def dead $eflags
              to GR16 -2
  Ready @3c
  BotQ.A BotLatency SU(6) 3c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 
Scheduling SU(5) %192.sub_32bit:gr64_nosp = ADD32rr %192.sub_32bit:gr64_nosp(tied-def 0), %186.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags
Bottom Pressure:
GR16=6
  LiveReg: %192
  UpdateRegP: SU(5) %192.sub_32bit:gr64_nosp = ADD32rr %192.sub_32bit:gr64_nosp(tied-def 0), %186.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags
              to 
  LiveReg: %186
  UpdateRegP: SU(5) %192.sub_32bit:gr64_nosp = ADD32rr %192.sub_32bit:gr64_nosp(tied-def 0), %186.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags
              to GR16 -2
  Ready @4c
  BotQ.A BotLatency SU(5) 4c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %192:gr64_nosp = SAR64ri %192:gr64_nosp(tied-def 0), 35, implicit-def dead $eflags
Bottom Pressure:
GR16=6
  LiveReg: %192
  UpdateRegP: SU(2) %186:gr64_with_sub_8bit = COPY %192:gr64_nosp
              to GR16 -2
  UpdateRegP: SU(4) %192:gr64_nosp = SAR64ri %192:gr64_nosp(tied-def 0), 35, implicit-def dead $eflags
              to GR16 -2
  Ready @5c
  BotQ.A BotLatency SU(4) 5c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) %186:gr64_with_sub_8bit = SHR64ri %186:gr64_with_sub_8bit(tied-def 0), 63, implicit-def dead $eflags
Bottom Pressure:
GR16=6
  LiveReg: %186
  UpdateRegP: SU(3) %186:gr64_with_sub_8bit = SHR64ri %186:gr64_with_sub_8bit(tied-def 0), 63, implicit-def dead $eflags
              to GR16 -2
  Ready @5c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %186:gr64_with_sub_8bit = COPY %192:gr64_nosp
Bottom Pressure:
GR16=4
  Ready @5c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %192:gr64_nosp = IMUL64rri32 %183:gr64_with_sub_8bit, 1717986919, implicit-def dead $eflags
Bottom Pressure:
GR16=2
  Ready @6c
  BotQ.A BotLatency SU(1) 6c
BotQ.A @1c
  Retired: 7
  Executed: 1c
  Critical: 1c, 7 MOps
  ExpectedLatency: 6c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %183:gr64_with_sub_8bit = MOVSX64rm32 %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
Bottom Pressure:

  Ready @10c
  BotQ.A BotLatency SU(0) 10c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 2c
  Critical: 2c, 8 MOps
  ExpectedLatency: 10c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.22 ***
SU(0):   %183:gr64_with_sub_8bit = MOVSX64rm32 %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
SU(1):   %192:gr64_nosp = IMUL64rri32 %183:gr64_with_sub_8bit, 1717986919, implicit-def dead $eflags
SU(2):   %186:gr64_with_sub_8bit = COPY %192:gr64_nosp
SU(3):   %186:gr64_with_sub_8bit = SHR64ri %186:gr64_with_sub_8bit(tied-def 0), 63, implicit-def dead $eflags
SU(4):   %192:gr64_nosp = SAR64ri %192:gr64_nosp(tied-def 0), 35, implicit-def dead $eflags
SU(5):   %192.sub_32bit:gr64_nosp = ADD32rr %192.sub_32bit:gr64_nosp(tied-def 0), %186.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags
SU(6):   %192.sub_32bit:gr64_nosp = SHL32ri %192.sub_32bit:gr64_nosp(tied-def 0), 2, implicit-def dead $eflags
SU(7):   %194:gr32 = LEA64_32r %192:gr64_nosp, 4, %192:gr64_nosp, 0, $noreg
SU(8):   CMP32rr %183.sub_32bit:gr64_with_sub_8bit, %194:gr32, implicit-def $eflags

********** MI Scheduling **********
main:%bb.24 if.then55
  From: $rdi = MOV32ri64 @.str.25
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.25
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %198:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %198:gr32
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.25
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.24 ***
SU(0):   $rdi = MOV32ri64 @.str.25
SU(1):   $esi = COPY %198:gr32
SU(2):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.26 for.end60
  From: %95:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
    To: JCC_1 %bb.27, 5, implicit $eflags
 RegionInstrs: 17
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: FR32=2
FR32X=2
GR16=6
Live In: 
Live Out: 
Live Thru: 
Top Pressure:

Bottom Pressure:

Excess PSets: 
SU(0):   %95:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 11
  Successors:
    SU(9): Data Latency=4 Reg=%95
    SU(1): Data Latency=4 Reg=%95
    SU(9): Out  Latency=0
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(1):   %87:fr64 = CVTSI2SDrr %95:gr32
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 7
  Predecessors:
    SU(0): Data Latency=4 Reg=%95
  Successors:
    SU(4): Data Latency=1 Reg=%87
    SU(9): Anti Latency=0
  Pressure Diff      : FR32 -1    FR32X -1    GR16 2
  Single Issue       : false;
SU(2):   %88:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 11
  Successors:
    SU(9): Data Latency=4 Reg=%88
    SU(3): Data Latency=4 Reg=%88
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(3):   %90:fr64 = CVTSI2SDrr %88:gr32
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 3
  Predecessors:
    SU(2): Data Latency=4 Reg=%88
  Successors:
    SU(4): Data Latency=1 Reg=%90
    SU(4): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1    GR16 2
  Single Issue       : false;
SU(4):   %90:fr64 = MULSDrr %90:fr64(tied-def 0), %87:fr64
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1 Reg=%90
    SU(3): Out  Latency=0
    SU(1): Data Latency=1 Reg=%87
  Successors:
    SU(7): Data Latency=1 Reg=%90
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(5):   %91:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 10
  Successors:
    SU(10): Data Latency=4 Reg=%91
    SU(6): Data Latency=4 Reg=%91
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(6):   %93:fr64 = CVTSI2SDrr %91:gr32
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
    SU(5): Data Latency=4 Reg=%91
  Successors:
    SU(7): Data Latency=1 Reg=%93
    SU(7): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1    GR16 2
  Single Issue       : false;
SU(7):   %93:fr64 = MULSDrr %93:fr64(tied-def 0), %90:fr64
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 1
  Predecessors:
    SU(4): Data Latency=1 Reg=%90
    SU(6): Out  Latency=0
    SU(6): Data Latency=1 Reg=%93
  Successors:
    SU(8): Data Latency=1 Reg=%93
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(8):   MOVSDmr %stack.8.n3, 1, $noreg, 0, $noreg, %93:fr64 :: (store 8 into %ir.n3)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 0
  Predecessors:
    SU(7): Data Latency=1 Reg=%93
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(9):   %95:gr32 = nsw ADD32rr %95:gr32(tied-def 0), %88:gr32, implicit-def dead $eflags
  # preds left       : 4
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 7
  Predecessors:
    SU(2): Data Latency=4 Reg=%88
    SU(1): Anti Latency=0
    SU(0): Data Latency=4 Reg=%95
    SU(0): Out  Latency=0
  Successors:
    SU(10): Data Latency=1 Reg=%95
    SU(10): Out  Latency=0
    SU(16): Out  Latency=0
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(10):   %95:gr32 = nsw ADD32rr %95:gr32(tied-def 0), %91:gr32, implicit-def dead $eflags
  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 6
  Predecessors:
    SU(9): Data Latency=1 Reg=%95
    SU(9): Out  Latency=0
    SU(5): Data Latency=4 Reg=%91
  Successors:
    SU(11): Data Latency=1 Reg=%95
    SU(16): Out  Latency=0
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(11):   %97:fr64 = CVTSI2SDrr %95:gr32
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 5
  Predecessors:
    SU(10): Data Latency=1 Reg=%95
  Successors:
    SU(12): Data Latency=1 Reg=%97
    SU(12): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1    GR16 2
  Single Issue       : false;
SU(12):   %97:fr64 = DIVSDrm %97:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 7
  Height             : 4
  Predecessors:
    SU(11): Data Latency=1 Reg=%97
    SU(11): Out  Latency=0
  Successors:
    SU(13): Data Latency=4 Reg=%97
  Pressure Diff      : 
  Single Issue       : false;
SU(13):   MOVSDmr %stack.6.navg, 1, $noreg, 0, $noreg, %97:fr64 :: (store 8 into %ir.navg)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 11
  Height             : 0
  Predecessors:
    SU(12): Data Latency=4 Reg=%97
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(14):   %98:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
    SU(16): Data Latency=4 Reg=%98
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(15):   %99:fr64 = FsFLD0SD
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(16): Data Latency=1 Reg=%99
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(16):   UCOMISDrr %98:fr64, %99:fr64, implicit-def $eflags
  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
    SU(15): Data Latency=1 Reg=%99
    SU(14): Data Latency=4 Reg=%98
    SU(10): Out  Latency=0
    SU(9): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Pressure Diff      : FR32 2    FR32X 2
  Single Issue       : false;
ExitSU:   JCC_1 %bb.27, 5, implicit $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 0
  Predecessors:
    SU(16): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 11
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 13 8 16 
  Cand SU(13) ORDER                              
  Cand SU(16) ORDER                              
Pick Bot ORDER     
Scheduling SU(16) UCOMISDrr %98:fr64, %99:fr64, implicit-def $eflags
Bottom Pressure:
FR32=2
FR32X=2
  LiveReg: %98
  UpdateRegP: SU(16) UCOMISDrr %98:fr64, %99:fr64, implicit-def $eflags
              to FR32 1    FR32X 1
  LiveReg: %99
  UpdateRegP: SU(16) UCOMISDrr %98:fr64, %99:fr64, implicit-def $eflags
              to 
  Ready @1c
  BotQ.A TopLatency SU(16) 5c
  BotQ.A BotLatency SU(16) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 13 8 15 14 
  Cand SU(13) ORDER                              
  Cand SU(15) REG-MAX                            
Pick Bot REG-MAX   
Scheduling SU(15) %99:fr64 = FsFLD0SD
Bottom Pressure:
FR32=1
FR32X=1
  Ready @2c
  BotQ.A BotLatency SU(15) 2c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 13 8 14 
  Cand SU(13) ORDER                              
  Cand SU(14) ORDER                              
Pick Bot ORDER     
Scheduling SU(14) %98:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
Bottom Pressure:

  Ready @5c
  BotQ.A BotLatency SU(14) 5c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 13 8 
  Cand SU(13) ORDER                              
Pick Bot ORDER     
Scheduling SU(13) MOVSDmr %stack.6.navg, 1, $noreg, 0, $noreg, %97:fr64 :: (store 8 into %ir.navg)
Bottom Pressure:
FR32=1
FR32X=1
  LiveReg: %97
  UpdateRegP: SU(13) MOVSDmr %stack.6.navg, 1, $noreg, 0, $noreg, %97:fr64 :: (store 8 into %ir.navg)
              to 
  Ready @0c
  BotQ.A TopLatency SU(13) 11c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 12 
  Cand SU(8) ORDER                              
  Cand SU(12) ORDER                              
Pick Bot ORDER     
Scheduling SU(12) %97:fr64 = DIVSDrm %97:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
Bottom Pressure:
FR32=1
FR32X=1
  LiveReg: %97
  UpdateRegP: SU(12) %97:fr64 = DIVSDrm %97:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
              to FR32 -1    FR32X -1
  Ready @4c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 11 
  Cand SU(8) ORDER                              
  Cand SU(11) ORDER                              
Pick Bot ORDER     
Scheduling SU(11) %97:fr64 = CVTSI2SDrr %95:gr32
Bottom Pressure:
GR16=2
  LiveReg: %95
  UpdateRegP: SU(11) %97:fr64 = CVTSI2SDrr %95:gr32
              to FR32 -1    FR32X -1
  Ready @5c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 10 
  Cand SU(8) ORDER                              
  Cand SU(10) ORDER                              
Pick Bot ORDER     
Scheduling SU(10) %95:gr32 = nsw ADD32rr %95:gr32(tied-def 0), %91:gr32, implicit-def dead $eflags
Bottom Pressure:
GR16=4
  LiveReg: %95
  UpdateRegP: SU(10) %95:gr32 = nsw ADD32rr %95:gr32(tied-def 0), %91:gr32, implicit-def dead $eflags
              to 
  LiveReg: %91
  UpdateRegP: SU(6) %93:fr64 = CVTSI2SDrr %91:gr32
              to FR32 -1    FR32X -1
  UpdateRegP: SU(10) %95:gr32 = nsw ADD32rr %95:gr32(tied-def 0), %91:gr32, implicit-def dead $eflags
              to GR16 -2
  Ready @6c
  BotQ.A BotLatency SU(10) 6c
BotQ.A @1c
  Retired: 7
  Executed: 1c
  Critical: 1c, 7 MOps
  ExpectedLatency: 6c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 9 
  Cand SU(8) ORDER                              
  Cand SU(9) ORDER                              
Pick Bot ORDER     
Scheduling SU(9) %95:gr32 = nsw ADD32rr %95:gr32(tied-def 0), %88:gr32, implicit-def dead $eflags
Bottom Pressure:
GR16=6
  LiveReg: %95
  UpdateRegP: SU(1) %87:fr64 = CVTSI2SDrr %95:gr32
              to FR32 -1    FR32X -1
  UpdateRegP: SU(9) %95:gr32 = nsw ADD32rr %95:gr32(tied-def 0), %88:gr32, implicit-def dead $eflags
              to 
  LiveReg: %88
  UpdateRegP: SU(3) %90:fr64 = CVTSI2SDrr %88:gr32
              to FR32 -1    FR32X -1
  UpdateRegP: SU(9) %95:gr32 = nsw ADD32rr %95:gr32(tied-def 0), %88:gr32, implicit-def dead $eflags
              to GR16 -2
  Ready @7c
  BotQ.A BotLatency SU(9) 7c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 2c
  Critical: 2c, 8 MOps
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 
Scheduling SU(8) MOVSDmr %stack.8.n3, 1, $noreg, 0, $noreg, %93:fr64 :: (store 8 into %ir.n3)
Bottom Pressure:
FR32=1
FR32X=1
GR16=6
  LiveReg: %93
  UpdateRegP: SU(8) MOVSDmr %stack.8.n3, 1, $noreg, 0, $noreg, %93:fr64 :: (store 8 into %ir.n3)
              to 
  Ready @2c
BotQ.A @2c
  Retired: 9
  Executed: 2c
  Critical: 2c, 9 MOps
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 
Scheduling SU(7) %93:fr64 = MULSDrr %93:fr64(tied-def 0), %90:fr64
Bottom Pressure:
FR32=2
FR32X=2
GR16=6
  LiveReg: %93
  UpdateRegP: SU(7) %93:fr64 = MULSDrr %93:fr64(tied-def 0), %90:fr64
              to 
  LiveReg: %90
  UpdateRegP: SU(7) %93:fr64 = MULSDrr %93:fr64(tied-def 0), %90:fr64
              to FR32 -1    FR32X -1
  Ready @3c
BotQ.A @2c
  Retired: 10
  Executed: 2c
  Critical: 2c, 10 MOps
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 6 
  Cand SU(4) ORDER                              
  Cand SU(6) REG-MAX                            
Pick Bot REG-MAX   
Scheduling SU(6) %93:fr64 = CVTSI2SDrr %91:gr32
Bottom Pressure:
FR32=1
FR32X=1
GR16=6
  Ready @4c
BotQ.A @2c
  Retired: 11
  Executed: 2c
  Critical: 2c, 11 MOps
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 5 
  Cand SU(4) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %91:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
Bottom Pressure:
FR32=1
FR32X=1
GR16=4
  Ready @10c
  BotQ.A BotLatency SU(5) 10c
  *** Max MOps 4 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 12
  Executed: 3c
  Critical: 3c, 12 MOps
  ExpectedLatency: 10c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) %90:fr64 = MULSDrr %90:fr64(tied-def 0), %87:fr64
Bottom Pressure:
FR32=2
FR32X=2
GR16=4
  LiveReg: %90
  UpdateRegP: SU(4) %90:fr64 = MULSDrr %90:fr64(tied-def 0), %87:fr64
              to 
  LiveReg: %87
  UpdateRegP: SU(4) %90:fr64 = MULSDrr %90:fr64(tied-def 0), %87:fr64
              to FR32 -1    FR32X -1
  Ready @4c
BotQ.A @3c
  Retired: 13
  Executed: 3c
  Critical: 3c, 13 MOps
  ExpectedLatency: 10c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 1 
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %90:fr64 = CVTSI2SDrr %88:gr32
Bottom Pressure:
FR32=1
FR32X=1
GR16=4
  Ready @5c
BotQ.A @3c
  Retired: 14
  Executed: 3c
  Critical: 3c, 14 MOps
  ExpectedLatency: 10c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %88:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
Bottom Pressure:
FR32=1
FR32X=1
GR16=2
  Ready @11c
  BotQ.A BotLatency SU(2) 11c
BotQ.A @3c
  Retired: 15
  Executed: 3c
  Critical: 3c, 15 MOps
  ExpectedLatency: 11c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %87:fr64 = CVTSI2SDrr %95:gr32
Bottom Pressure:
GR16=2
  Ready @7c
  *** Max MOps 4 at cycle 3
Cycle: 4 BotQ.A
BotQ.A @4c
  Retired: 16
  Executed: 4c
  Critical: 4c, 16 MOps
  ExpectedLatency: 11c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %95:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
Bottom Pressure:

  Ready @11c
BotQ.A @4c
  Retired: 17
  Executed: 4c
  Critical: 4c, 17 MOps
  ExpectedLatency: 11c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.26 ***
SU(0):   %95:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
SU(1):   %87:fr64 = CVTSI2SDrr %95:gr32
SU(2):   %88:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
SU(3):   %90:fr64 = CVTSI2SDrr %88:gr32
SU(4):   %90:fr64 = MULSDrr %90:fr64(tied-def 0), %87:fr64
SU(5):   %91:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
SU(6):   %93:fr64 = CVTSI2SDrr %91:gr32
SU(7):   %93:fr64 = MULSDrr %93:fr64(tied-def 0), %90:fr64
SU(8):   MOVSDmr %stack.8.n3, 1, $noreg, 0, $noreg, %93:fr64 :: (store 8 into %ir.n3)
SU(9):   %95:gr32 = nsw ADD32rr %95:gr32(tied-def 0), %88:gr32, implicit-def dead $eflags
SU(10):   %95:gr32 = nsw ADD32rr %95:gr32(tied-def 0), %91:gr32, implicit-def dead $eflags
SU(11):   %97:fr64 = CVTSI2SDrr %95:gr32
SU(12):   %97:fr64 = DIVSDrm %97:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
SU(13):   MOVSDmr %stack.6.navg, 1, $noreg, 0, $noreg, %97:fr64 :: (store 8 into %ir.navg)
SU(14):   %98:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
SU(15):   %99:fr64 = FsFLD0SD
SU(16):   UCOMISDrr %98:fr64, %99:fr64, implicit-def $eflags

********** MI Scheduling **********
main:%bb.26 for.end60
  From: %84:gr64 = LEA64r %stack.13.Class, 1, $noreg, 0, $noreg
    To: CALL64pcrel32 @verify, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %84:gr64 = LEA64r %stack.13.Class, 1, $noreg, 0, $noreg
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(3): Data Latency=1 Reg=%84
  Single Issue       : false;
SU(1):   %85:gr64 = LEA64r %stack.12.verified, 1, $noreg, 0, $noreg
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(4): Data Latency=1 Reg=%85
  Single Issue       : false;
SU(2):   $edi = COPY %83:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $rsi = COPY %84:gr64
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(0): Data Latency=1 Reg=%84
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   $rdx = COPY %85:gr64
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1 Reg=%85
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @verify, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=0 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) $rdx = COPY %85:gr64
  Ready @0c
  BotQ.A TopLatency SU(4) 1c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 1 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(3) $rsi = COPY %84:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) $edi = COPY %83:gr32
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %85:gr64 = LEA64r %stack.12.verified, 1, $noreg, 0, $noreg
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %84:gr64 = LEA64r %stack.13.Class, 1, $noreg, 0, $noreg
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.26 ***
SU(0):   %84:gr64 = LEA64r %stack.13.Class, 1, $noreg, 0, $noreg
SU(1):   %85:gr64 = LEA64r %stack.12.verified, 1, $noreg, 0, $noreg
SU(2):   $edi = COPY %83:gr32
SU(3):   $rsi = COPY %84:gr64
SU(4):   $rdx = COPY %85:gr64

********** MI Scheduling **********
main:%bb.26 for.end60
  From: %82:fr64 = COPY killed $xmm0
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %82:fr64 = COPY killed $xmm0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Data Latency=0 Reg=%82
  Single Issue       : false;
SU(1):   MOVSDmr %stack.9.tmax, 1, $noreg, 0, $noreg, %82:fr64 :: (store 8 into %ir.tmax)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%82
  Single Issue       : false;
SU(2):   %83:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %83:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  Ready @3c
  BotQ.A BotLatency SU(2) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOVSDmr %stack.9.tmax, 1, $noreg, 0, $noreg, %82:fr64 :: (store 8 into %ir.tmax)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %82:fr64 = COPY killed $xmm0
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.26 ***
SU(0):   %82:fr64 = COPY killed $xmm0
SU(1):   MOVSDmr %stack.9.tmax, 1, $noreg, 0, $noreg, %82:fr64 :: (store 8 into %ir.tmax)
SU(2):   %83:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)

********** MI Scheduling **********
main:%bb.27 if.then70
  From: %101:fr64 = CVTSI2SDrm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
    To: JMP_1 %bb.29
 RegionInstrs: 14
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: FR32=4
FR32X=4
Live In: 
Live Out: 
Live Thru: 
Top Pressure:

Bottom Pressure:

Excess PSets: 
SU(0):   %101:fr64 = CVTSI2SDrm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 13
  Successors:
    SU(1): Data Latency=4 Reg=%101
    SU(1): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(1):   %101:fr64 = MULSDrm %101:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 9
  Predecessors:
    SU(0): Data Latency=4 Reg=%101
    SU(0): Out  Latency=0
  Successors:
    SU(11): Data Latency=4 Reg=%101
  Pressure Diff      : 
  Single Issue       : false;
SU(2):   %103:fr64 = MOVSDrm_alt %stack.8.n3, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.n3)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 15
  Successors:
    SU(3): Data Latency=4 Reg=%103
    SU(3): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(3):   %103:fr64 = MULSDrm %103:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 11
  Predecessors:
    SU(2): Data Latency=4 Reg=%103
    SU(2): Out  Latency=0
  Successors:
    SU(8): Data Latency=4 Reg=%103
  Pressure Diff      : 
  Single Issue       : false;
SU(4):   %109:fr64 = MOVSDrm_alt %stack.6.navg, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.navg)
  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 16
  Successors:
    SU(9): Data Latency=4 Reg=%109
    SU(5): Data Latency=4 Reg=%109
    SU(9): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(5):   %106:fr64 = COPY %109:fr64
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 12
  Predecessors:
    SU(4): Data Latency=4 Reg=%109
  Successors:
    SU(6): Data Latency=0 Reg=%106
    SU(6): Out  Latency=0
    SU(9): Anti Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(6):   %106:fr64 = MULSDrr %106:fr64(tied-def 0), %106:fr64
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 12
  Predecessors:
    SU(5): Data Latency=0 Reg=%106
    SU(5): Out  Latency=0
  Successors:
    SU(7): Data Latency=1 Reg=%106
    SU(7): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   %106:fr64 = MULSDrm %106:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 5
  Height             : 11
  Predecessors:
    SU(6): Data Latency=1 Reg=%106
    SU(6): Out  Latency=0
  Successors:
    SU(8): Data Latency=4 Reg=%106
    SU(8): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(8):   %106:fr64 = ADDSDrr %106:fr64(tied-def 0), %103:fr64
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 7
  Predecessors:
    SU(7): Data Latency=4 Reg=%106
    SU(7): Out  Latency=0
    SU(3): Data Latency=4 Reg=%103
  Successors:
    SU(10): Data Latency=1 Reg=%106
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(9):   %109:fr64 = MULSDrm %109:fr64(tied-def 0), $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 10
  Predecessors:
    SU(5): Anti Latency=0
    SU(4): Data Latency=4 Reg=%109
    SU(4): Out  Latency=0
  Successors:
    SU(10): Data Latency=4 Reg=%109
    SU(10): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(10):   %109:fr64 = ADDSDrr %109:fr64(tied-def 0), %106:fr64
  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 6
  Predecessors:
    SU(8): Data Latency=1 Reg=%106
    SU(9): Out  Latency=0
    SU(9): Data Latency=4 Reg=%109
  Successors:
    SU(11): Data Latency=1 Reg=%109
    SU(11): Out  Latency=0
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(11):   %109:fr64 = MULSDrr %109:fr64(tied-def 0), %101:fr64
  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 11
  Height             : 5
  Predecessors:
    SU(10): Data Latency=1 Reg=%109
    SU(10): Out  Latency=0
    SU(1): Data Latency=4 Reg=%101
  Successors:
    SU(12): Data Latency=1 Reg=%109
    SU(12): Out  Latency=0
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(12):   %109:fr64 = DIVSDrm %109:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 12
  Height             : 4
  Predecessors:
    SU(11): Data Latency=1 Reg=%109
    SU(11): Out  Latency=0
  Successors:
    SU(13): Data Latency=4 Reg=%109
  Pressure Diff      : 
  Single Issue       : false;
SU(13):   MOVSDmr %stack.7.mflops, 1, $noreg, 0, $noreg, %109:fr64 :: (store 8 into %ir.mflops)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 16
  Height             : 0
  Predecessors:
    SU(12): Data Latency=4 Reg=%109
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
ExitSU:   JMP_1 %bb.29
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 16
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 13 
Scheduling SU(13) MOVSDmr %stack.7.mflops, 1, $noreg, 0, $noreg, %109:fr64 :: (store 8 into %ir.mflops)
Bottom Pressure:
FR32=1
FR32X=1
  LiveReg: %109
  UpdateRegP: SU(13) MOVSDmr %stack.7.mflops, 1, $noreg, 0, $noreg, %109:fr64 :: (store 8 into %ir.mflops)
              to 
  Ready @0c
  BotQ.A TopLatency SU(13) 16c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 12 
Scheduling SU(12) %109:fr64 = DIVSDrm %109:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
Bottom Pressure:
FR32=1
FR32X=1
  LiveReg: %109
  UpdateRegP: SU(12) %109:fr64 = DIVSDrm %109:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
              to FR32 -1    FR32X -1
  Ready @4c
  BotQ.A BotLatency SU(12) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 11 
Scheduling SU(11) %109:fr64 = MULSDrr %109:fr64(tied-def 0), %101:fr64
Bottom Pressure:
FR32=2
FR32X=2
  LiveReg: %109
  UpdateRegP: SU(11) %109:fr64 = MULSDrr %109:fr64(tied-def 0), %101:fr64
              to 
  LiveReg: %101
  UpdateRegP: SU(11) %109:fr64 = MULSDrr %109:fr64(tied-def 0), %101:fr64
              to FR32 -1    FR32X -1
  Ready @5c
  BotQ.A BotLatency SU(11) 5c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 10 1 
  Cand SU(10) ORDER                              
Pick Bot ORDER     
Scheduling SU(10) %109:fr64 = ADDSDrr %109:fr64(tied-def 0), %106:fr64
Bottom Pressure:
FR32=3
FR32X=3
  LiveReg: %109
  UpdateRegP: SU(10) %109:fr64 = ADDSDrr %109:fr64(tied-def 0), %106:fr64
              to 
  LiveReg: %106
  UpdateRegP: SU(10) %109:fr64 = ADDSDrr %109:fr64(tied-def 0), %106:fr64
              to FR32 -1    FR32X -1
  Ready @6c
  BotQ.A BotLatency SU(10) 6c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 6c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 8 9 
  Cand SU(1) ORDER                              
  Cand SU(8) ORDER                              
  Cand SU(9) ORDER                              
Pick Bot ORDER     
Scheduling SU(9) %109:fr64 = MULSDrm %109:fr64(tied-def 0), $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
Bottom Pressure:
FR32=3
FR32X=3
  LiveReg: %109
  UpdateRegP: SU(5) %106:fr64 = COPY %109:fr64
              to FR32 -1    FR32X -1
  UpdateRegP: SU(9) %109:fr64 = MULSDrm %109:fr64(tied-def 0), $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
              to FR32 -1    FR32X -1
  Ready @10c
  BotQ.A BotLatency SU(9) 10c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 10c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 8 
  Cand SU(1) ORDER                              
  Cand SU(8) ORDER                              
Pick Bot ORDER     
Scheduling SU(8) %106:fr64 = ADDSDrr %106:fr64(tied-def 0), %103:fr64
Bottom Pressure:
FR32=4
FR32X=4
  LiveReg: %106
  UpdateRegP: SU(8) %106:fr64 = ADDSDrr %106:fr64(tied-def 0), %103:fr64
              to 
  LiveReg: %103
  UpdateRegP: SU(8) %106:fr64 = ADDSDrr %106:fr64(tied-def 0), %103:fr64
              to FR32 -1    FR32X -1
  Ready @7c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 10c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 7 3 
  Cand SU(1) ORDER                              
  Cand SU(7) ORDER                              
Pick Bot ORDER     
Scheduling SU(7) %106:fr64 = MULSDrm %106:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
Bottom Pressure:
FR32=4
FR32X=4
  LiveReg: %106
  UpdateRegP: SU(7) %106:fr64 = MULSDrm %106:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
              to FR32 -1    FR32X -1
  Ready @11c
  BotQ.A BotLatency SU(7) 11c
BotQ.A @1c
  Retired: 7
  Executed: 1c
  Critical: 1c, 7 MOps
  ExpectedLatency: 11c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 3 6 
  Cand SU(1) ORDER                              
  Cand SU(3) ORDER                              
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) %106:fr64 = MULSDrr %106:fr64(tied-def 0), %106:fr64
Bottom Pressure:
FR32=4
FR32X=4
  LiveReg: %106
  UpdateRegP: SU(6) %106:fr64 = MULSDrr %106:fr64(tied-def 0), %106:fr64
              to FR32 -1    FR32X -1
  Ready @12c
  BotQ.A BotLatency SU(6) 12c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 2c
  Critical: 2c, 8 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 3 5 
  Cand SU(1) ORDER                              
  Cand SU(3) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %106:fr64 = COPY %109:fr64
Bottom Pressure:
FR32=3
FR32X=3
  Ready @12c
BotQ.A @2c
  Retired: 8
  Executed: 2c
  Critical: 2c, 8 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 3 4 
  Cand SU(1) ORDER                              
  Cand SU(3) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %109:fr64 = MOVSDrm_alt %stack.6.navg, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.navg)
Bottom Pressure:
FR32=2
FR32X=2
  Ready @16c
  BotQ.A BotLatency SU(4) 16c
BotQ.A @2c
  Retired: 9
  Executed: 2c
  Critical: 2c, 9 MOps
  ExpectedLatency: 16c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 3 
  Cand SU(1) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %103:fr64 = MULSDrm %103:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
Bottom Pressure:
FR32=2
FR32X=2
  LiveReg: %103
  UpdateRegP: SU(3) %103:fr64 = MULSDrm %103:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
              to FR32 -1    FR32X -1
  Ready @11c
BotQ.A @2c
  Retired: 10
  Executed: 2c
  Critical: 2c, 10 MOps
  ExpectedLatency: 16c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %103:fr64 = MOVSDrm_alt %stack.8.n3, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.n3)
Bottom Pressure:
FR32=1
FR32X=1
  Ready @15c
BotQ.A @2c
  Retired: 11
  Executed: 2c
  Critical: 2c, 11 MOps
  ExpectedLatency: 16c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %101:fr64 = MULSDrm %101:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
Bottom Pressure:
FR32=1
FR32X=1
  LiveReg: %101
  UpdateRegP: SU(1) %101:fr64 = MULSDrm %101:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
              to FR32 -1    FR32X -1
  Ready @9c
  *** Max MOps 4 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 12
  Executed: 3c
  Critical: 3c, 12 MOps
  ExpectedLatency: 16c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %101:fr64 = CVTSI2SDrm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
Bottom Pressure:

  Ready @13c
BotQ.A @3c
  Retired: 13
  Executed: 3c
  Critical: 3c, 13 MOps
  ExpectedLatency: 16c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.27 ***
SU(0):   %101:fr64 = CVTSI2SDrm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
SU(1):   %101:fr64 = MULSDrm %101:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
SU(2):   %103:fr64 = MOVSDrm_alt %stack.8.n3, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.n3)
SU(3):   %103:fr64 = MULSDrm %103:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
SU(4):   %109:fr64 = MOVSDrm_alt %stack.6.navg, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.navg)
SU(5):   %106:fr64 = COPY %109:fr64
SU(6):   %106:fr64 = MULSDrr %106:fr64(tied-def 0), %106:fr64
SU(7):   %106:fr64 = MULSDrm %106:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
SU(8):   %106:fr64 = ADDSDrr %106:fr64(tied-def 0), %103:fr64
SU(9):   %109:fr64 = MULSDrm %109:fr64(tied-def 0), $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
SU(10):   %109:fr64 = ADDSDrr %109:fr64(tied-def 0), %106:fr64
SU(11):   %109:fr64 = MULSDrr %109:fr64(tied-def 0), %101:fr64
SU(12):   %109:fr64 = DIVSDrm %109:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
SU(13):   MOVSDmr %stack.7.mflops, 1, $noreg, 0, $noreg, %109:fr64 :: (store 8 into %ir.mflops)

********** MI Scheduling **********
main:%bb.29 if.end81
  From: $rdi = MOV32ri64 @.str.26
    To: PUSH64i32 @.str.36, implicit-def $rsp, implicit $rsp
 RegionInstrs: 8
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=6
GR32_BPSP+GR64_TCW64=6
GR8=8
GR8+GR32_DIBP=8
GR8+GR32_BSI=8
GR64_TC+GR64_TCW64=8
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=8
GR8+GR64_NOREX=8
GR64_TC=8
GR8+GR64_TCW64=8
GR8+GR64_TC=8
FR32X=2
GR16=11
Live In: %118 %117 %116 %115 %114 %113 %112 
Live Out: XMM1 XMM0 R9B R9BH R9WH R8B R8BH R8WH CH CL HCX DH DL HDX SIL SIH HSI DIL DIH HDI 
Live Thru: 
Top Pressure:
FR32=2
FR32X=2
GR16=10
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=6
GR32_BPSP+GR64_TCW64=6
GR8=8
GR8+GR32_DIBP=8
GR8+GR32_BSI=8
GR64_TC+GR64_TCW64=8
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=8
GR8+GR64_NOREX=8
GR64_TC=8
GR8+GR64_TCW64=8
GR8+GR64_TC=8
FR32X=2
GR16=8
Excess PSets: 
SU(0):   $rdi = MOV32ri64 @.str.26
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR32_BPSP -1    GR32_SIDI -1    GR32_DIBP+GR32_SIDI -1    GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR64_NOREX -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1    GR16 -1
  Single Issue       : false;
SU(1):   $esi = COPY %112:gr32
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR32_BSI -1    GR32_SIDI -1    GR32_DIBP+GR32_SIDI -1    GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -1    GR64_NOREX -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1
  Single Issue       : false;
SU(2):   $edx = COPY %113:gr32
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -2    GR32_TC -2    GR32_BPSP+GR32_TC -2    GR64_NOREX -2    GR64_TCW64 -2    GR32_BPSP+GR64_TCW64 -2    GR8 -2    GR8+GR32_DIBP -2    GR8+GR32_BSI -2    GR64_TC+GR64_TCW64 -2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -2    GR8+GR64_NOREX -2    GR64_TC -2    GR8+GR64_TCW64 -2
  Single Issue       : false;
SU(3):   $ecx = COPY %114:gr32
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR32_BSI -2    GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -2    GR32_TC -2    GR32_BPSP+GR32_TC -2    GR64_NOREX -2    GR64_TCW64 -2    GR32_BPSP+GR64_TCW64 -2    GR8 -2    GR8+GR32_DIBP -2    GR8+GR32_BSI -2    GR64_TC+GR64_TCW64 -2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -2    GR8+GR64_NOREX -2    GR64_TC -2
  Single Issue       : false;
SU(4):   $r8d = COPY %115:gr32
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR64_TCW64 -1    GR32_BPSP+GR64_TCW64 -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1    GR16 1
  Single Issue       : false;
SU(5):   $r9d = COPY %116:gr32
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR64_TCW64 -1    GR32_BPSP+GR64_TCW64 -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1    GR16 1
  Single Issue       : false;
SU(6):   $xmm0 = COPY %117:fr64
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   $xmm1 = COPY %118:fr64
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : 
  Single Issue       : false;
ExitSU:   PUSH64i32 @.str.36, implicit-def $rsp, implicit $rsp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 6 5 4 3 2 1 0 
  Cand SU(7) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(7) $xmm1 = COPY %118:fr64
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=6
GR32_BPSP+GR64_TCW64=6
GR8=8
GR8+GR32_DIBP=8
GR8+GR32_BSI=8
GR64_TC+GR64_TCW64=8
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=8
GR8+GR64_NOREX=8
GR64_TC=8
GR8+GR64_TCW64=8
GR8+GR64_TC=8
FR32X=2
GR16=8
  LiveReg: %118
  UpdateRegP: SU(7) $xmm1 = COPY %118:fr64
              to FR32 -1    FR32X -1
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 6 5 4 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(6) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(6) $xmm0 = COPY %117:fr64
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=6
GR32_BPSP+GR64_TCW64=6
GR8=8
GR8+GR32_DIBP=8
GR8+GR32_BSI=8
GR64_TC+GR64_TCW64=8
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=8
GR8+GR64_NOREX=8
GR64_TC=8
GR8+GR64_TCW64=8
GR8+GR64_TC=8
FR32X=2
GR16=8
  LiveReg: %117
  UpdateRegP: SU(6) $xmm0 = COPY %117:fr64
              to FR32 -1    FR32X -1
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 5 4 3 2 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) $r9d = COPY %116:gr32
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=5
GR32_BPSP+GR64_TCW64=5
GR8=7
GR8+GR32_DIBP=7
GR8+GR32_BSI=7
GR64_TC+GR64_TCW64=7
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=7
GR8+GR64_NOREX=7
GR64_TC=7
GR8+GR64_TCW64=7
GR8+GR64_TC=7
FR32X=2
GR16=9
  LiveReg: %116
  UpdateRegP: SU(5) $r9d = COPY %116:gr32
              to GR64_TCW64 -1    GR32_BPSP+GR64_TCW64 -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1    GR16 -1
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 4 3 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) $r8d = COPY %115:gr32
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=3
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=3
GR8_ABCD_L+GR32_BSI=3
GR8_NOREX=5
GR32_TC=4
GR32_BPSP+GR32_TC=4
FR32=2
GR64_NOREX=6
GR64_TCW64=4
GR32_BPSP+GR64_TCW64=4
GR8=6
GR8+GR32_DIBP=6
GR8+GR32_BSI=6
GR64_TC+GR64_TCW64=6
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=6
GR8+GR64_NOREX=6
GR64_TC=6
GR8+GR64_TCW64=6
GR8+GR64_TC=6
FR32X=2
GR16=10
  LiveReg: %115
  UpdateRegP: SU(4) $r8d = COPY %115:gr32
              to GR64_TCW64 -1    GR32_BPSP+GR64_TCW64 -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1    GR16 -1
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 3 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) $ecx = COPY %114:gr32
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=1
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=2
GR8_ABCD_L+GR32_BSI=2
GR8_NOREX=3
GR32_TC=2
GR32_BPSP+GR32_TC=2
FR32=2
GR64_NOREX=4
GR64_TCW64=2
GR32_BPSP+GR64_TCW64=2
GR8=4
GR8+GR32_DIBP=4
GR8+GR32_BSI=4
GR64_TC+GR64_TCW64=4
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=4
GR8+GR64_NOREX=4
GR64_TC=4
GR8+GR64_TCW64=4
GR8+GR64_TC=4
FR32X=2
GR16=10
  GR8_NOREX: 5 <= 6(+ 0 livethru)
  LiveReg: %114
  UpdateRegP: SU(3) $ecx = COPY %114:gr32
              to GR32_BSI -2    GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -2    GR32_TC -2    GR32_BPSP+GR32_TC -2    GR64_NOREX -2    GR64_TCW64 -2    GR32_BPSP+GR64_TCW64 -2    GR8 -2    GR8+GR32_DIBP -2    GR8+GR32_BSI -2    GR64_TC+GR64_TCW64 -2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -2    GR8+GR64_NOREX -2    GR64_TC -2
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $edx = COPY %113:gr32
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=1
GR32_SIDI=2
GR32_DIBP+GR32_SIDI=2
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H+GR32_BSI=1
GR8_ABCD_L+GR32_BSI=1
GR8_NOREX=1
FR32=2
GR64_NOREX=2
GR8=2
GR8+GR32_DIBP=2
GR8+GR32_BSI=2
GR64_TC+GR64_TCW64=2
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=2
GR8+GR64_NOREX=2
GR64_TC=2
GR8+GR64_TCW64=2
GR8+GR64_TC=2
FR32X=2
GR16=10
  GR8_NOREX: 5 <= 6(+ 0 livethru)
  LiveReg: %113
  UpdateRegP: SU(2) $edx = COPY %113:gr32
              to GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -2    GR32_TC -2    GR32_BPSP+GR32_TC -2    GR64_NOREX -2    GR64_TCW64 -2    GR32_BPSP+GR64_TCW64 -2    GR8 -2    GR8+GR32_DIBP -2    GR8+GR32_BSI -2    GR64_TC+GR64_TCW64 -2    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -2    GR8+GR64_NOREX -2    GR64_TC -2    GR8+GR64_TCW64 -2
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %112:gr32
Bottom Pressure:
GR32_BPSP=1
GR32_SIDI=1
GR32_DIBP+GR32_SIDI=1
GR32_DIBP+LOW32_ADDR_ACCESS_with_sub_32bit=1
FR32=2
GR64_NOREX=1
GR8=1
GR8+GR32_DIBP=1
GR8+GR32_BSI=1
GR64_TC+GR64_TCW64=1
GR8+LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8+GR64_NOREX=1
GR64_TC=1
GR8+GR64_TCW64=1
GR8+GR64_TC=1
FR32X=2
GR16=11
  GR32_DIBP+GR32_SIDI: 2 <= 4(+ 0 livethru)
  GR8_NOREX: 5 <= 6(+ 0 livethru)
  LiveReg: %112
  UpdateRegP: SU(1) $esi = COPY %112:gr32
              to GR32_BSI -1    GR32_SIDI -1    GR32_DIBP+GR32_SIDI -1    GR8_ABCD_H+GR32_BSI -1    GR8_ABCD_L+GR32_BSI -1    GR8_NOREX -1    GR64_NOREX -1    GR8 -1    GR8+GR32_DIBP -1    GR8+GR32_BSI -1    GR64_TC+GR64_TCW64 -1    GR8+LOW32_ADDR_ACCESS_with_sub_32bit -1    GR8+GR64_NOREX -1    GR64_TC -1    GR8+GR64_TCW64 -1    GR8+GR64_TC -1
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.26
Bottom Pressure:
FR32=2
FR32X=2
GR16=10
  GR32_BPSP: 1 <= 2(+ 0 livethru)
  GR32_DIBP+GR32_SIDI: 2 <= 4(+ 0 livethru)
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.29 ***
SU(0):   $rdi = MOV32ri64 @.str.26
SU(1):   $esi = COPY %112:gr32
SU(2):   $edx = COPY %113:gr32
SU(3):   $ecx = COPY %114:gr32
SU(4):   $r8d = COPY %115:gr32
SU(5):   $r9d = COPY %116:gr32
SU(6):   $xmm0 = COPY %117:fr64
SU(7):   $xmm1 = COPY %118:fr64

********** MI Scheduling **********
main:%bb.29 if.end81
  From: %112:gr32 = MOVSX32rm8 %stack.13.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
    To: ADJCALLSTACKDOWN64 88, 0, 88, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 8
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: FR32=2
FR32X=2
GR16=12
Live In: 
Live Out: %221 %118 %117 %116 %115 %114 %113 %112 
Live Thru: 
  LiveReg: %221
  LiveReg: %118
  LiveReg: %117
  LiveReg: %116
  LiveReg: %115
  LiveReg: %114
  LiveReg: %113
  LiveReg: %112
Top Pressure:

Bottom Pressure:
FR32=2
FR32X=2
GR16=12
Excess PSets: 
SU(0):   %112:gr32 = MOVSX32rm8 %stack.13.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(1):   %113:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(2):   %114:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(3):   %115:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(4):   %116:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(5):   %117:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(6):   %118:fr64 = MOVSDrm_alt %stack.7.mflops, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.mflops)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(7):   undef %221.sub_32bit:gr64_with_sub_8bit = MOV32rm %stack.12.verified, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.verified)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Pressure Diff      : GR16 -2
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 88, 0, 88, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 8
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(7): Ord  Latency=3 Artificial
    SU(6): Ord  Latency=3 Artificial
    SU(5): Ord  Latency=3 Artificial
    SU(4): Ord  Latency=3 Artificial
    SU(3): Ord  Latency=3 Artificial
    SU(2): Ord  Latency=3 Artificial
    SU(1): Ord  Latency=3 Artificial
    SU(0): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 6 5 4 3 2 1 0 
  Cand SU(7) ORDER                              
Pick Bot ORDER     
Scheduling SU(7) undef %221.sub_32bit:gr64_with_sub_8bit = MOV32rm %stack.12.verified, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.verified)
Bottom Pressure:
FR32=2
FR32X=2
GR16=10
  Ready @3c
  BotQ.A BotLatency SU(7) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 6 5 4 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) %118:fr64 = MOVSDrm_alt %stack.7.mflops, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.mflops)
Bottom Pressure:
FR32=1
FR32X=1
GR16=10
  Ready @3c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 5 4 3 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %117:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
Bottom Pressure:
GR16=10
  Ready @3c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 4 3 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %116:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
Bottom Pressure:
GR16=8
  Ready @3c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 3 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %115:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
Bottom Pressure:
GR16=6
  Ready @3c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %114:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
Bottom Pressure:
GR16=4
  Ready @3c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %113:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
Bottom Pressure:
GR16=2
  Ready @3c
BotQ.A @1c
  Retired: 7
  Executed: 1c
  Critical: 1c, 7 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %112:gr32 = MOVSX32rm8 %stack.13.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
Bottom Pressure:

  Ready @3c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 2c
  Critical: 2c, 8 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.29 ***
SU(0):   %112:gr32 = MOVSX32rm8 %stack.13.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
SU(1):   %113:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
SU(2):   %114:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
SU(3):   %115:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
SU(4):   %116:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
SU(5):   %117:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
SU(6):   %118:fr64 = MOVSDrm_alt %stack.7.mflops, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.mflops)
SU(7):   undef %221.sub_32bit:gr64_with_sub_8bit = MOV32rm %stack.12.verified, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.verified)

********** MI Scheduling **********
main:%bb.32 for.body86
  From: %181:fr64 = COPY killed $xmm0
    To: JMP_1 %bb.31
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %181:fr64 = COPY killed $xmm0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(2): Data Latency=0 Reg=%181
  Single Issue       : false;
SU(1):   %182:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 4
  Successors:
    SU(2): Data Latency=4 Reg=%182
    SU(3): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOVSDmr %stack.11.trecs, 8, %182:gr64_nosp, 0, $noreg, %181:fr64 :: (store 8 into %ir.arrayidx88)
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Data Latency=4 Reg=%182
    SU(0): Data Latency=0 Reg=%181
  Single Issue       : false;
SU(3):   INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Predecessors:
    SU(1): Ord  Latency=0 Memory
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   JMP_1 %bb.31
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 4
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
  Ready @3c
  BotQ.A BotLatency SU(3) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOVSDmr %stack.11.trecs, 8, %182:gr64_nosp, 0, $noreg, %181:fr64 :: (store 8 into %ir.arrayidx88)
  Ready @0c
  BotQ.A TopLatency SU(2) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) %182:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  Ready @4c
  BotQ.A BotLatency SU(1) 4c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %181:fr64 = COPY killed $xmm0
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.32 ***
SU(0):   %181:fr64 = COPY killed $xmm0
SU(1):   %182:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
SU(2):   MOVSDmr %stack.11.trecs, 8, %182:gr64_nosp, 0, $noreg, %181:fr64 :: (store 8 into %ir.arrayidx88)
SU(3):   INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)

********** MI Scheduling **********
main:%bb.33 for.end91
  From: %124:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
    To: JCC_1 %bb.35, 5, implicit $eflags
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %124:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=4 Reg=%124
  Single Issue       : false;
SU(1):   %125:fr64 = FsFLD0SD
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(2): Data Latency=1 Reg=%125
  Single Issue       : false;
SU(2):   UCOMISDrr %124:fr64, %125:fr64, implicit-def $eflags
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(1): Data Latency=1 Reg=%125
    SU(0): Data Latency=4 Reg=%124
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   JCC_1 %bb.35, 5, implicit $eflags
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 5
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) UCOMISDrr %124:fr64, %125:fr64, implicit-def $eflags
  Ready @1c
  BotQ.A TopLatency SU(2) 4c
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %125:fr64 = FsFLD0SD
  Ready @2c
  BotQ.A BotLatency SU(1) 2c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %124:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @5c
  BotQ.A BotLatency SU(0) 5c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.33 ***
SU(0):   %124:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
SU(1):   %125:fr64 = FsFLD0SD
SU(2):   UCOMISDrr %124:fr64, %125:fr64, implicit-def $eflags

********** MI Scheduling **********
main:%bb.34 if.then94
  From: %126:gr64 = MOV64ri 4607182418800017408
    To: End RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %126:gr64 = MOV64ri 4607182418800017408
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=1 Reg=%126
  Single Issue       : false;
SU(1):   MOV64mr %stack.9.tmax, 1, $noreg, 0, $noreg, %126:gr64 :: (store 8 into %ir.tmax)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(0): Data Latency=1 Reg=%126
  Single Issue       : false;
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) MOV64mr %stack.9.tmax, 1, $noreg, 0, $noreg, %126:gr64 :: (store 8 into %ir.tmax)
  Ready @0c
  BotQ.A TopLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %126:gr64 = MOV64ri 4607182418800017408
  Ready @1c
  BotQ.A BotLatency SU(0) 1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.34 ***
SU(0):   %126:gr64 = MOV64ri 4607182418800017408
SU(1):   MOV64mr %stack.9.tmax, 1, $noreg, 0, $noreg, %126:gr64 :: (store 8 into %ir.tmax)

********** MI Scheduling **********
main:%bb.35 if.end95
  From: MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
    To: End RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   %217:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
Critical Path(GS-RR ): 3
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %217:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
  Ready @3c
  BotQ.A BotLatency SU(1) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.35 ***
SU(0):   MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
SU(1):   %217:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)

********** MI Scheduling **********
main:%bb.35 if.end95
  From: $rdi = MOV32ri64 @.str.37
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.37
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.37
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.35 ***
SU(0):   $rdi = MOV32ri64 @.str.37
SU(1):   dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al

********** MI Scheduling **********
main:%bb.37 for.body100
  From: $rdi = MOV32ri64 @.str.38
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.38
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = COPY %134:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %135:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $xmm1 = COPY %137:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   $al = MOV8ri 2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) $al = MOV8ri 2
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $xmm1 = COPY %137:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $xmm0 = COPY %135:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $rsi = COPY %134:gr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.38
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.37 ***
SU(0):   $rdi = MOV32ri64 @.str.38
SU(1):   $rsi = COPY %134:gr64
SU(2):   $xmm0 = COPY %135:fr64
SU(3):   $xmm1 = COPY %137:fr64
SU(4):   $al = MOV8ri 2

********** MI Scheduling **********
main:%bb.37 for.body100
  From: %133:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %133:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 12
  Successors:
    SU(2): Data Latency=4 Reg=%133
    SU(1): Data Latency=4 Reg=%133
  Single Issue       : false;
SU(1):   %134:gr64 = MOV64rm %stack.14.t_names, 8, %133:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx102)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 3
  Predecessors:
    SU(0): Data Latency=4 Reg=%133
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
SU(2):   %135:fr64 = MOVSDrm_alt %stack.11.trecs, 8, %133:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx106)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 8
  Predecessors:
    SU(0): Data Latency=4 Reg=%133
  Successors:
    SU(3): Data Latency=4 Reg=%135
  Single Issue       : false;
SU(3):   %137:fr64 = COPY %135:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(2): Data Latency=4 Reg=%135
  Successors:
    SU(4): Data Latency=0 Reg=%137
    SU(4): Out  Latency=0
  Single Issue       : false;
SU(4):   %137:fr64 = MULSDrr %137:fr64(tied-def 0), %217:fr64
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(3): Data Latency=0 Reg=%137
    SU(3): Out  Latency=0
  Successors:
    SU(5): Data Latency=1 Reg=%137
    SU(5): Out  Latency=0
  Single Issue       : false;
SU(5):   %137:fr64 = DIVSDrm %137:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 9
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1 Reg=%137
    SU(4): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=3 Artificial
    SU(1): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 12
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 1 
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %137:fr64 = DIVSDrm %137:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @3c
  BotQ.A TopLatency SU(5) 9c
  BotQ.A BotLatency SU(5) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 4 
  Cand SU(1) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %137:fr64 = MULSDrr %137:fr64(tied-def 0), %217:fr64
  Ready @4c
  BotQ.A BotLatency SU(4) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 3 
  Cand SU(1) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %137:fr64 = COPY %135:fr64
  Ready @4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %135:fr64 = MOVSDrm_alt %stack.11.trecs, 8, %133:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx106)
  Ready @8c
  BotQ.A BotLatency SU(2) 8c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %134:gr64 = MOV64rm %stack.14.t_names, 8, %133:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx102)
  Ready @3c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %133:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  Ready @12c
  BotQ.A BotLatency SU(0) 12c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.37 ***
SU(0):   %133:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
SU(1):   %134:gr64 = MOV64rm %stack.14.t_names, 8, %133:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx102)
SU(2):   %135:fr64 = MOVSDrm_alt %stack.11.trecs, 8, %133:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx106)
SU(3):   %137:fr64 = COPY %135:fr64
SU(4):   %137:fr64 = MULSDrr %137:fr64(tied-def 0), %217:fr64
SU(5):   %137:fr64 = DIVSDrm %137:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)

********** MI Scheduling **********
main:%bb.38 if.then112
  From: $rdi = MOV32ri64 @.str.39
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.39
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.41
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %175:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $xmm1 = COPY %177:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   $al = MOV8ri 2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) $al = MOV8ri 2
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $xmm1 = COPY %177:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) $xmm0 = COPY %175:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.41
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.39
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.38 ***
SU(0):   $rdi = MOV32ri64 @.str.39
SU(1):   $rsi = MOV32ri64 @.str.41
SU(2):   $xmm0 = COPY %175:fr64
SU(3):   $xmm1 = COPY %177:fr64
SU(4):   $al = MOV8ri 2

********** MI Scheduling **********
main:%bb.38 if.then112
  From: %175:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx121)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %175:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx121)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 12
  Successors:
    SU(1): Data Latency=4 Reg=%175
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %175:fr64 = SUBSDrm %175:fr64(tied-def 0), %stack.10.t, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.t)
  # preds left       : 2
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 8
  Predecessors:
    SU(0): Data Latency=4 Reg=%175
    SU(0): Out  Latency=0
  Successors:
    SU(3): Data Latency=4 Reg=%175
    SU(2): Data Latency=4 Reg=%175
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %175:fr64 :: (store 8 into %ir.t)
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Data Latency=4 Reg=%175
    SU(1): Ord  Latency=0 Memory
  Single Issue       : false;
SU(3):   %177:fr64 = COPY %175:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(1): Data Latency=4 Reg=%175
  Successors:
    SU(4): Data Latency=0 Reg=%177
    SU(4): Out  Latency=0
  Single Issue       : false;
SU(4):   %177:fr64 = MULSDrr %177:fr64(tied-def 0), %217:fr64
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(3): Data Latency=0 Reg=%177
    SU(3): Out  Latency=0
  Successors:
    SU(5): Data Latency=1 Reg=%177
    SU(5): Out  Latency=0
  Single Issue       : false;
SU(5):   %177:fr64 = DIVSDrm %177:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 9
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1 Reg=%177
    SU(4): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 12
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 5 
  Cand SU(2) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %177:fr64 = DIVSDrm %177:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @3c
  BotQ.A TopLatency SU(5) 9c
  BotQ.A BotLatency SU(5) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 4 
  Cand SU(2) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %177:fr64 = MULSDrr %177:fr64(tied-def 0), %217:fr64
  Ready @4c
  BotQ.A BotLatency SU(4) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %177:fr64 = COPY %175:fr64
  Ready @4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %175:fr64 :: (store 8 into %ir.t)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %175:fr64 = SUBSDrm %175:fr64(tied-def 0), %stack.10.t, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.t)
  Ready @8c
  BotQ.A BotLatency SU(1) 8c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %175:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx121)
  Ready @12c
  BotQ.A BotLatency SU(0) 12c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.38 ***
SU(0):   %175:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx121)
SU(1):   %175:fr64 = SUBSDrm %175:fr64(tied-def 0), %stack.10.t, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.t)
SU(2):   MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %175:fr64 :: (store 8 into %ir.t)
SU(3):   %177:fr64 = COPY %175:fr64
SU(4):   %177:fr64 = MULSDrr %177:fr64(tied-def 0), %217:fr64
SU(5):   %177:fr64 = DIVSDrm %177:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)

********** MI Scheduling **********
main:%bb.38 if.then112
  From: $rdi = MOV32ri64 @.str.39
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.39
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.40
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %166:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $xmm1 = COPY %169:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   $al = MOV8ri 2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) $al = MOV8ri 2
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $xmm1 = COPY %169:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) $xmm0 = COPY %166:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.40
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.39
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.38 ***
SU(0):   $rdi = MOV32ri64 @.str.39
SU(1):   $rsi = MOV32ri64 @.str.40
SU(2):   $xmm0 = COPY %166:fr64
SU(3):   $xmm1 = COPY %169:fr64
SU(4):   $al = MOV8ri 2

********** MI Scheduling **********
main:%bb.38 if.then112
  From: %166:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 16, $noreg :: (dereferenceable load 8 from %ir.arrayidx113, align 16)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 7
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %166:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 16, $noreg :: (dereferenceable load 8 from %ir.arrayidx113, align 16)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 16
  Successors:
    SU(1): Data Latency=4 Reg=%166
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %166:fr64 = ADDSDrm %166:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx114)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 12
  Predecessors:
    SU(0): Data Latency=4 Reg=%166
    SU(0): Out  Latency=0
  Successors:
    SU(2): Data Latency=4 Reg=%166
    SU(2): Out  Latency=0
  Single Issue       : false;
SU(2):   %166:fr64 = ADDSDrm %166:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 32, $noreg :: (dereferenceable load 8 from %ir.arrayidx116, align 16)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 8
  Height             : 8
  Predecessors:
    SU(1): Data Latency=4 Reg=%166
    SU(1): Out  Latency=0
  Successors:
    SU(4): Data Latency=4 Reg=%166
    SU(3): Data Latency=4 Reg=%166
  Single Issue       : false;
SU(3):   MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %166:fr64 :: (store 8 into %ir.t)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(2): Data Latency=4 Reg=%166
  Single Issue       : false;
SU(4):   %169:fr64 = COPY %166:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 12
  Height             : 4
  Predecessors:
    SU(2): Data Latency=4 Reg=%166
  Successors:
    SU(5): Data Latency=0 Reg=%169
    SU(5): Out  Latency=0
  Single Issue       : false;
SU(5):   %169:fr64 = MULSDrr %169:fr64(tied-def 0), %217:fr64
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 4
  Predecessors:
    SU(4): Data Latency=0 Reg=%169
    SU(4): Out  Latency=0
  Successors:
    SU(6): Data Latency=1 Reg=%169
    SU(6): Out  Latency=0
  Single Issue       : false;
SU(6):   %169:fr64 = DIVSDrm %169:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 13
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1 Reg=%169
    SU(5): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 16
  Height             : 0
  Predecessors:
    SU(6): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 16
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 6 
  Cand SU(3) ORDER                              
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) %169:fr64 = DIVSDrm %169:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @3c
  BotQ.A TopLatency SU(6) 13c
  BotQ.A BotLatency SU(6) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 5 
  Cand SU(3) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %169:fr64 = MULSDrr %169:fr64(tied-def 0), %217:fr64
  Ready @4c
  BotQ.A BotLatency SU(5) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 4 
  Cand SU(3) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %169:fr64 = COPY %166:fr64
  Ready @4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %166:fr64 :: (store 8 into %ir.t)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %166:fr64 = ADDSDrm %166:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 32, $noreg :: (dereferenceable load 8 from %ir.arrayidx116, align 16)
  Ready @8c
  BotQ.A BotLatency SU(2) 8c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %166:fr64 = ADDSDrm %166:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx114)
  Ready @12c
  BotQ.A BotLatency SU(1) 12c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %166:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 16, $noreg :: (dereferenceable load 8 from %ir.arrayidx113, align 16)
  Ready @16c
  BotQ.A BotLatency SU(0) 16c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 16c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.38 ***
SU(0):   %166:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 16, $noreg :: (dereferenceable load 8 from %ir.arrayidx113, align 16)
SU(1):   %166:fr64 = ADDSDrm %166:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx114)
SU(2):   %166:fr64 = ADDSDrm %166:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 32, $noreg :: (dereferenceable load 8 from %ir.arrayidx116, align 16)
SU(3):   MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %166:fr64 :: (store 8 into %ir.t)
SU(4):   %169:fr64 = COPY %166:fr64
SU(5):   %169:fr64 = MULSDrr %169:fr64(tied-def 0), %217:fr64
SU(6):   %169:fr64 = DIVSDrm %169:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)

********** MI Scheduling **********
main:%bb.40 if.then129
  From: $rdi = MOV32ri64 @.str.39
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.39
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.42
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %157:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $xmm1 = COPY %159:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   $al = MOV8ri 2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) $al = MOV8ri 2
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $xmm1 = COPY %159:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) $xmm0 = COPY %157:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.42
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.39
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.40 ***
SU(0):   $rdi = MOV32ri64 @.str.39
SU(1):   $rsi = MOV32ri64 @.str.42
SU(2):   $xmm0 = COPY %157:fr64
SU(3):   $xmm1 = COPY %159:fr64
SU(4):   $al = MOV8ri 2

********** MI Scheduling **********
main:%bb.40 if.then129
  From: %157:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 64, $noreg :: (dereferenceable load 8 from %ir.arrayidx130, align 16)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 7
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %157:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 64, $noreg :: (dereferenceable load 8 from %ir.arrayidx130, align 16)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 16
  Successors:
    SU(1): Data Latency=4 Reg=%157
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %157:fr64 = SUBSDrm %157:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx131)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 12
  Predecessors:
    SU(0): Data Latency=4 Reg=%157
    SU(0): Out  Latency=0
  Successors:
    SU(2): Data Latency=4 Reg=%157
    SU(2): Out  Latency=0
  Single Issue       : false;
SU(2):   %157:fr64 = SUBSDrm %157:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx133, align 16)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 8
  Height             : 8
  Predecessors:
    SU(1): Data Latency=4 Reg=%157
    SU(1): Out  Latency=0
  Successors:
    SU(4): Data Latency=4 Reg=%157
    SU(3): Data Latency=4 Reg=%157
  Single Issue       : false;
SU(3):   MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %157:fr64 :: (store 8 into %ir.t)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(2): Data Latency=4 Reg=%157
  Single Issue       : false;
SU(4):   %159:fr64 = COPY %157:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 12
  Height             : 4
  Predecessors:
    SU(2): Data Latency=4 Reg=%157
  Successors:
    SU(5): Data Latency=0 Reg=%159
    SU(5): Out  Latency=0
  Single Issue       : false;
SU(5):   %159:fr64 = MULSDrr %159:fr64(tied-def 0), %217:fr64
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 4
  Predecessors:
    SU(4): Data Latency=0 Reg=%159
    SU(4): Out  Latency=0
  Successors:
    SU(6): Data Latency=1 Reg=%159
    SU(6): Out  Latency=0
  Single Issue       : false;
SU(6):   %159:fr64 = DIVSDrm %159:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 13
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1 Reg=%159
    SU(5): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 16
  Height             : 0
  Predecessors:
    SU(6): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 16
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 6 
  Cand SU(3) ORDER                              
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) %159:fr64 = DIVSDrm %159:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @3c
  BotQ.A TopLatency SU(6) 13c
  BotQ.A BotLatency SU(6) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 5 
  Cand SU(3) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %159:fr64 = MULSDrr %159:fr64(tied-def 0), %217:fr64
  Ready @4c
  BotQ.A BotLatency SU(5) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 4 
  Cand SU(3) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %159:fr64 = COPY %157:fr64
  Ready @4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %157:fr64 :: (store 8 into %ir.t)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %157:fr64 = SUBSDrm %157:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx133, align 16)
  Ready @8c
  BotQ.A BotLatency SU(2) 8c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %157:fr64 = SUBSDrm %157:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx131)
  Ready @12c
  BotQ.A BotLatency SU(1) 12c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %157:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 64, $noreg :: (dereferenceable load 8 from %ir.arrayidx130, align 16)
  Ready @16c
  BotQ.A BotLatency SU(0) 16c
BotQ.A @1c
  Retired: 6
  Executed: 1c
  Critical: 1c, 6 MOps
  ExpectedLatency: 16c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.40 ***
SU(0):   %157:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 64, $noreg :: (dereferenceable load 8 from %ir.arrayidx130, align 16)
SU(1):   %157:fr64 = SUBSDrm %157:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx131)
SU(2):   %157:fr64 = SUBSDrm %157:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx133, align 16)
SU(3):   MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %157:fr64 :: (store 8 into %ir.t)
SU(4):   %159:fr64 = COPY %157:fr64
SU(5):   %159:fr64 = MULSDrr %159:fr64(tied-def 0), %217:fr64
SU(6):   %159:fr64 = DIVSDrm %159:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)

********** MI Scheduling **********
main:%bb.42 if.then141
  From: $rdi = MOV32ri64 @.str.39
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str.39
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.43
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $xmm0 = COPY %148:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $xmm1 = COPY %150:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   $al = MOV8ri 2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 5
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Artificial
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 2 1 0 
  Cand SU(4) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(4) $al = MOV8ri 2
  Ready @1c
  BotQ.A BotLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 3 2 1 
  Cand SU(0) ORDER                              
  Cand SU(3) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(3) $xmm1 = COPY %150:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(2) $xmm0 = COPY %148:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str.43
  Ready @1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str.39
  Ready @1c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.42 ***
SU(0):   $rdi = MOV32ri64 @.str.39
SU(1):   $rsi = MOV32ri64 @.str.43
SU(2):   $xmm0 = COPY %148:fr64
SU(3):   $xmm1 = COPY %150:fr64
SU(4):   $al = MOV8ri 2

********** MI Scheduling **********
main:%bb.42 if.then141
  From: %148:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx142)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 6
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %148:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx142)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 12
  Successors:
    SU(1): Data Latency=4 Reg=%148
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %148:fr64 = ADDSDrm %148:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx143, align 16)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 8
  Predecessors:
    SU(0): Data Latency=4 Reg=%148
    SU(0): Out  Latency=0
  Successors:
    SU(3): Data Latency=4 Reg=%148
    SU(2): Data Latency=4 Reg=%148
  Single Issue       : false;
SU(2):   MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %148:fr64 :: (store 8 into %ir.t)
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Data Latency=4 Reg=%148
  Single Issue       : false;
SU(3):   %150:fr64 = COPY %148:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(1): Data Latency=4 Reg=%148
  Successors:
    SU(4): Data Latency=0 Reg=%150
    SU(4): Out  Latency=0
  Single Issue       : false;
SU(4):   %150:fr64 = MULSDrr %150:fr64(tied-def 0), %217:fr64
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(3): Data Latency=0 Reg=%150
    SU(3): Out  Latency=0
  Successors:
    SU(5): Data Latency=1 Reg=%150
    SU(5): Out  Latency=0
  Single Issue       : false;
SU(5):   %150:fr64 = DIVSDrm %150:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 9
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1 Reg=%150
    SU(4): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=3 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=3 Artificial
Critical Path(GS-RR ): 12
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 5 
  Cand SU(2) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %150:fr64 = DIVSDrm %150:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
  Ready @3c
  BotQ.A TopLatency SU(5) 9c
  BotQ.A BotLatency SU(5) 3c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 4 
  Cand SU(2) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %150:fr64 = MULSDrr %150:fr64(tied-def 0), %217:fr64
  Ready @4c
  BotQ.A BotLatency SU(4) 4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %150:fr64 = COPY %148:fr64
  Ready @4c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %148:fr64 :: (store 8 into %ir.t)
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %148:fr64 = ADDSDrm %148:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx143, align 16)
  Ready @8c
  BotQ.A BotLatency SU(1) 8c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 4 MOps
  ExpectedLatency: 8c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %148:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx142)
  Ready @12c
  BotQ.A BotLatency SU(0) 12c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 MOps
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.42 ***
SU(0):   %148:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx142)
SU(1):   %148:fr64 = ADDSDrm %148:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx143, align 16)
SU(2):   MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %148:fr64 :: (store 8 into %ir.t)
SU(3):   %150:fr64 = COPY %148:fr64
SU(4):   %150:fr64 = MULSDrr %150:fr64(tied-def 0), %217:fr64
SU(5):   %150:fr64 = DIVSDrm %150:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)

********** MI Scheduling **********
main:%bb.45 return
  From: %216:gr32 = MOV32rm %stack.0.retval, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.retval)
    To: RET 0, killed $eax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %216:gr32 = MOV32rm %stack.0.retval, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.retval)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 4
  Successors:
    SU(1): Data Latency=4 Reg=%216
  Single Issue       : false;
SU(1):   $eax = COPY %216:gr32
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(0): Data Latency=4 Reg=%216
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   RET 0, killed $eax
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 4
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) $eax = COPY %216:gr32
  Ready @0c
  BotQ.A TopLatency SU(1) 4c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %216:gr32 = MOV32rm %stack.0.retval, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.retval)
  Ready @4c
  BotQ.A BotLatency SU(0) 4c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 4c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.45 ***
SU(0):   %216:gr32 = MOV32rm %stack.0.retval, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.retval)
SU(1):   $eax = COPY %216:gr32

********** INTERVALS **********
DIL [0B,32r:0)[144r,176r:32)[528r,544r:31)[704r,736r:30)[816r,848r:29)[1040r,1072r:27)[1192r,1232r:26)[1344r,1360r:25)[1608r,1632r:24)[1744r,1760r:23)[2072r,2096r:22)[2192r,2208r:21)[2336r,2368r:28)[2624r,2704r:20)[2816r,2880r:19)[2944r,2976r:18)[3312r,3392r:9)[3456r,3488r:8)[3792r,3808r:1)[4304r,4320r:2)[4432r,4448r:7)[5040r,5088r:10)[5296r,5312r:6)[5360r,5376r:5)[5504r,5552r:4)[6576r,6896r:17)[7120r,7136r:3)[7488r,7520r:16)[7904r,7984r:15)[8256r,8336r:12)[8512r,8592r:11)[8896r,8976r:13)[9248r,9328r:14)  0@0B-phi 1@3792r 2@4304r 3@7120r 4@5504r 5@5360r 6@5296r 7@4432r 8@3456r 9@3312r 10@5040r 11@8512r 12@8256r 13@8896r 14@9248r 15@7904r 16@7488r 17@6576r 18@2944r 19@2816r 20@2624r 21@2192r 22@2072r 23@1744r 24@1608r 25@1344r 26@1192r 27@1040r 28@2336r 29@816r 30@704r 31@528r 32@144r
DIH [0B,32r:0)[144r,176r:32)[528r,544r:31)[704r,736r:30)[816r,848r:29)[1040r,1072r:27)[1192r,1232r:26)[1344r,1360r:25)[1608r,1632r:24)[1744r,1760r:23)[2072r,2096r:22)[2192r,2208r:21)[2336r,2368r:28)[2624r,2704r:20)[2816r,2880r:19)[2944r,2976r:18)[3312r,3392r:9)[3456r,3488r:8)[3792r,3808r:1)[4304r,4320r:2)[4432r,4448r:7)[5040r,5088r:10)[5296r,5312r:6)[5360r,5376r:5)[5504r,5552r:4)[6576r,6896r:17)[7120r,7136r:3)[7488r,7520r:16)[7904r,7984r:15)[8256r,8336r:12)[8512r,8592r:11)[8896r,8976r:13)[9248r,9328r:14)  0@0B-phi 1@3792r 2@4304r 3@7120r 4@5504r 5@5360r 6@5296r 7@4432r 8@3456r 9@3312r 10@5040r 11@8512r 12@8256r 13@8896r 14@9248r 15@7904r 16@7488r 17@6576r 18@2944r 19@2816r 20@2624r 21@2192r 22@2072r 23@1744r 24@1608r 25@1344r 26@1192r 27@1040r 28@2336r 29@816r 30@704r 31@528r 32@144r
HDI [0B,32r:0)[144r,176r:32)[528r,544r:31)[704r,736r:30)[816r,848r:29)[1040r,1072r:27)[1192r,1232r:26)[1344r,1360r:25)[1608r,1632r:24)[1744r,1760r:23)[2072r,2096r:22)[2192r,2208r:21)[2336r,2368r:28)[2624r,2704r:20)[2816r,2880r:19)[2944r,2976r:18)[3312r,3392r:9)[3456r,3488r:8)[3792r,3808r:1)[4304r,4320r:2)[4432r,4448r:7)[5040r,5088r:10)[5296r,5312r:6)[5360r,5376r:5)[5504r,5552r:4)[6576r,6896r:17)[7120r,7136r:3)[7488r,7520r:16)[7904r,7984r:15)[8256r,8336r:12)[8512r,8592r:11)[8896r,8976r:13)[9248r,9328r:14)  0@0B-phi 1@3792r 2@4304r 3@7120r 4@5504r 5@5360r 6@5296r 7@4432r 8@3456r 9@3312r 10@5040r 11@8512r 12@8256r 13@8896r 14@9248r 15@7904r 16@7488r 17@6576r 18@2944r 19@2816r 20@2624r 21@2192r 22@2072r 23@1744r 24@1608r 25@1344r 26@1192r 27@1040r 28@2336r 29@816r 30@704r 31@528r 32@144r
SIL [0B,16r:0)[160r,176r:16)[832r,848r:15)[1184r,1232r:14)[1584r,1632r:13)[2016r,2096r:12)[2640r,2704r:5)[2832r,2880r:4)[3328r,3392r:1)[5056r,5088r:2)[5520r,5552r:11)[6592r,6896r:3)[7920r,7984r:10)[8272r,8336r:7)[8528r,8592r:6)[8912r,8976r:8)[9264r,9328r:9)  0@0B-phi 1@3328r 2@5056r 3@6592r 4@2832r 5@2640r 6@8528r 7@8272r 8@8912r 9@9264r 10@7920r 11@5520r 12@2016r 13@1584r 14@1184r 15@832r 16@160r
SIH [0B,16r:0)[160r,176r:16)[832r,848r:15)[1184r,1232r:14)[1584r,1632r:13)[2016r,2096r:12)[2640r,2704r:5)[2832r,2880r:4)[3328r,3392r:1)[5056r,5088r:2)[5520r,5552r:11)[6592r,6896r:3)[7920r,7984r:10)[8272r,8336r:7)[8528r,8592r:6)[8912r,8976r:8)[9264r,9328r:9)  0@0B-phi 1@3328r 2@5056r 3@6592r 4@2832r 5@2640r 6@8528r 7@8272r 8@8912r 9@9264r 10@7920r 11@5520r 12@2016r 13@1584r 14@1184r 15@832r 16@160r
HSI [0B,16r:0)[160r,176r:16)[832r,848r:15)[1184r,1232r:14)[1584r,1632r:13)[2016r,2096r:12)[2640r,2704r:5)[2832r,2880r:4)[3328r,3392r:1)[5056r,5088r:2)[5520r,5552r:11)[6592r,6896r:3)[7920r,7984r:10)[8272r,8336r:7)[8528r,8592r:6)[8912r,8976r:8)[9264r,9328r:9)  0@0B-phi 1@3328r 2@5056r 3@6592r 4@2832r 5@2640r 6@8528r 7@8272r 8@8912r 9@9264r 10@7920r 11@5520r 12@2016r 13@1584r 14@1184r 15@832r 16@160r
%0 [32r,64r:0)  0@32r weight:0.000000e+00
%1 [16r,80r:0)  0@16r weight:0.000000e+00
%4 [208r,240r:0)  0@208r weight:0.000000e+00
%5 [496r,528r:0)  0@496r weight:0.000000e+00
%13 [880r,912r:0)  0@880r weight:0.000000e+00
%18 [2416r,2432r:0)  0@2416r weight:0.000000e+00
%19 [2448r,2464r:0)  0@2448r weight:0.000000e+00
%24 [1104r,1192r:0)  0@1104r weight:0.000000e+00
%26 [1152r,1200r:0)  0@1152r weight:0.000000e+00
%27 [1264r,1280r:0)  0@1264r weight:0.000000e+00
%28 [1312r,1344r:0)  0@1312r weight:0.000000e+00
%29 [1392r,1408r:0)  0@1392r weight:0.000000e+00
%31 [1472r,1608r:0)  0@1472r weight:0.000000e+00
%36 [1664r,1680r:0)  0@1664r weight:0.000000e+00
%37 [1712r,1744r:0)  0@1712r weight:0.000000e+00
%38 [1792r,1808r:0)  0@1792r weight:0.000000e+00
%40 [1872r,2072r:0)  0@1872r weight:0.000000e+00
%47 [2128r,2144r:0)  0@2128r weight:0.000000e+00
%48 [2160r,2192r:0)  0@2160r weight:0.000000e+00
%50 [2512r,2640r:0)  0@2512r weight:0.000000e+00
%51 [2528r,2656r:0)  0@2528r weight:0.000000e+00
%52 [2544r,2672r:0)  0@2544r weight:0.000000e+00
%57 [2736r,2832r:0)  0@2736r weight:0.000000e+00
%58 [2752r,2848r:0)  0@2752r weight:0.000000e+00
%79 [4544r,4560r:0)  0@4544r weight:0.000000e+00
%82 [5408r,5424r:0)  0@5408r weight:0.000000e+00
%83 [5440r,5504r:0)  0@5440r weight:0.000000e+00
%84 [5472r,5520r:0)  0@5472r weight:0.000000e+00
%85 [5488r,5536r:0)  0@5488r weight:0.000000e+00
%87 [5600r,5664r:0)  0@5600r weight:0.000000e+00
%88 [5616r,5776r:0)  0@5616r weight:0.000000e+00
%90 [5632r,5664r:0)[5664r,5728r:1)  0@5632r 1@5664r weight:0.000000e+00
%91 [5680r,5808r:0)  0@5680r weight:0.000000e+00
%93 [5696r,5728r:0)[5728r,5744r:1)  0@5696r 1@5728r weight:0.000000e+00
%95 [5584r,5776r:2)[5776r,5808r:0)[5808r,5824r:1)  0@5776r 1@5808r 2@5584r weight:0.000000e+00
%97 [5824r,5856r:0)[5856r,5872r:1)  0@5824r 1@5856r weight:0.000000e+00
%98 [5888r,5920r:0)  0@5888r weight:0.000000e+00
%99 [5904r,5920r:0)  0@5904r weight:0.000000e+00
%101 [6000r,6032r:0)[6032r,6288r:1)  0@6000r 1@6032r weight:0.000000e+00
%103 [6048r,6080r:0)[6080r,6192r:1)  0@6048r 1@6080r weight:0.000000e+00
%106 [6112r,6128r:2)[6128r,6160r:0)[6160r,6192r:1)[6192r,6256r:3)  0@6128r 1@6160r 2@6112r 3@6192r weight:0.000000e+00
%109 [6096r,6224r:2)[6224r,6256r:0)[6256r,6288r:1)[6288r,6320r:3)[6320r,6336r:4)  0@6224r 1@6256r 2@6096r 3@6288r 4@6320r weight:0.000000e+00
%112 [6416r,6592r:0)  0@6416r weight:0.000000e+00
%113 [6432r,6608r:0)  0@6432r weight:0.000000e+00
%114 [6448r,6624r:0)  0@6448r weight:0.000000e+00
%115 [6464r,6640r:0)  0@6464r weight:0.000000e+00
%116 [6480r,6656r:0)  0@6480r weight:0.000000e+00
%117 [6496r,6672r:0)  0@6496r weight:0.000000e+00
%118 [6512r,6688r:0)  0@6512r weight:0.000000e+00
%124 [7264r,7296r:0)  0@7264r weight:0.000000e+00
%125 [7280r,7296r:0)  0@7280r weight:0.000000e+00
%126 [7376r,7392r:0)  0@7376r weight:0.000000e+00
%133 [7776r,7808r:0)  0@7776r weight:0.000000e+00
%134 [7792r,7920r:0)  0@7792r weight:0.000000e+00
%135 [7808r,7936r:0)  0@7808r weight:0.000000e+00
%137 [7824r,7840r:2)[7840r,7872r:0)[7872r,7952r:1)  0@7840r 1@7872r 2@7824r weight:0.000000e+00
%148 [9104r,9136r:0)[9136r,9280r:1)  0@9104r 1@9136r weight:0.000000e+00
%150 [9168r,9184r:2)[9184r,9216r:0)[9216r,9296r:1)  0@9184r 1@9216r 2@9168r weight:0.000000e+00
%157 [8720r,8752r:2)[8752r,8784r:0)[8784r,8928r:1)  0@8752r 1@8784r 2@8720r weight:0.000000e+00
%159 [8816r,8832r:2)[8832r,8864r:0)[8864r,8944r:1)  0@8832r 1@8864r 2@8816r weight:0.000000e+00
%166 [8080r,8112r:2)[8112r,8144r:0)[8144r,8288r:1)  0@8112r 1@8144r 2@8080r weight:0.000000e+00
%169 [8176r,8192r:2)[8192r,8224r:0)[8224r,8304r:1)  0@8192r 1@8224r 2@8176r weight:0.000000e+00
%175 [8368r,8400r:0)[8400r,8544r:1)  0@8368r 1@8400r weight:0.000000e+00
%177 [8432r,8448r:2)[8448r,8480r:0)[8480r,8560r:1)  0@8448r 1@8480r 2@8432r weight:0.000000e+00
%180 [7088r,7120r:0)  0@7088r weight:0.000000e+00
%181 [7168r,7200r:0)  0@7168r weight:0.000000e+00
%182 [7184r,7200r:0)  0@7184r weight:0.000000e+00
%183 [4624r,4864r:0)  0@4624r weight:0.000000e+00
%186 [4672r,4688r:0)[4688r,4784r:1)  0@4672r 1@4688r weight:0.000000e+00
%192 [4656r,4736r:3)[4736r,4784r:0)[4784r,4816r:1)[4816r,4848r:2)  0@4736r 1@4784r 2@4816r 3@4656r weight:0.000000e+00
%194 [4848r,4864r:0)  0@4848r weight:0.000000e+00
%198 [4992r,5056r:0)  0@4992r weight:0.000000e+00
%205 [4272r,4304r:0)  0@4272r weight:0.000000e+00
%206 [3760r,3792r:0)  0@3760r weight:0.000000e+00
%207 [3200r,3328r:0)  0@3200r weight:0.000000e+00
%208 [3216r,3344r:0)  0@3216r weight:0.000000e+00
%209 [3232r,3360r:0)  0@3232r weight:0.000000e+00
%216 [9456r,9472r:0)  0@9456r weight:0.000000e+00
%217 [7568r,9408B:0)  0@7568r weight:0.000000e+00
%221 [6528r,6864r:0)  0@6528r weight:0.000000e+00
RegMasks: 176r 544r 736r 848r 1072r 1232r 1360r 1632r 1760r 2096r 2208r 2368r 2704r 2880r 2976r 3392r 3488r 3632r 3808r 3952r 4016r 4080r 4144r 4320r 4448r 5088r 5184r 5312r 5376r 5552r 6896r 7136r 7520r 7984r 8336r 8592r 8976r 9328r
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=4, align=4, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=4, align=4, at location [SP+8]
  fi#6: size=8, align=8, at location [SP+8]
  fi#7: size=8, align=8, at location [SP+8]
  fi#8: size=8, align=8, at location [SP+8]
  fi#9: size=8, align=8, at location [SP+8]
  fi#10: size=8, align=8, at location [SP+8]
  fi#11: size=96, align=16, at location [SP+8]
  fi#12: size=4, align=4, at location [SP+8]
  fi#13: size=1, align=1, at location [SP+8]
  fi#14: size=96, align=16, at location [SP+8]
  fi#15: size=8, align=8, at location [SP+8]
  fi#16: size=4, align=4, at location [SP+8]
Constant Pool:
  cp#0: 3.000000e+00, align=8
  cp#1: 0x3EB0C6F7A0B5ED8D, align=8
  cp#2: 3.478800e+03, align=8
  cp#3: -1.765570e+04, align=8
  cp#4: 2.802370e+04, align=8
  cp#5: 1.000000e+02, align=8
Function Live Ins: $edi in %0, $rsi in %1

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $edi, $rsi
16B	  %1:gr64 = COPY $rsi
32B	  %0:gr32 = COPY $edi
48B	  MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
64B	  MOV32mr %stack.1.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
80B	  MOV64mr %stack.2.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
96B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
144B	  $rdi = MOV32ri64 @.str
160B	  $rsi = MOV32ri64 @.str.1
176B	  CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %4:gr64 = COPY killed $rax
224B	  MOV64mr %stack.15.fp, 1, $noreg, 0, $noreg, %4:gr64 :: (store 8 into %ir.fp)
240B	  TEST64rr %4:gr64, %4:gr64, implicit-def $eflags
256B	  JCC_1 %bb.2, 4, implicit killed $eflags
272B	  JMP_1 %bb.1

288B	bb.1.if.then:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

304B	  MOV32mi $rip, 1, $noreg, @timeron, $noreg, 1 :: (store 4 into @timeron)
320B	  MOV64mi32 %stack.14.t_names, 1, $noreg, 8, $noreg, @.str.2 :: (store 8 into %ir.arrayidx)
336B	  MOV64mi32 %stack.14.t_names, 1, $noreg, 16, $noreg, @.str.3 :: (store 8 into %ir.arrayidx1, align 16)
352B	  MOV64mi32 %stack.14.t_names, 1, $noreg, 24, $noreg, @.str.4 :: (store 8 into %ir.arrayidx2)
368B	  MOV64mi32 %stack.14.t_names, 1, $noreg, 32, $noreg, @.str.5 :: (store 8 into %ir.arrayidx3, align 16)
384B	  MOV64mi32 %stack.14.t_names, 1, $noreg, 40, $noreg, @.str.6 :: (store 8 into %ir.arrayidx4)
400B	  MOV64mi32 %stack.14.t_names, 1, $noreg, 48, $noreg, @.str.7 :: (store 8 into %ir.arrayidx5, align 16)
416B	  MOV64mi32 %stack.14.t_names, 1, $noreg, 56, $noreg, @.str.8 :: (store 8 into %ir.arrayidx6)
432B	  MOV64mi32 %stack.14.t_names, 1, $noreg, 64, $noreg, @.str.9 :: (store 8 into %ir.arrayidx7, align 16)
448B	  MOV64mi32 %stack.14.t_names, 1, $noreg, 72, $noreg, @.str.10 :: (store 8 into %ir.arrayidx8)
464B	  MOV64mi32 %stack.14.t_names, 1, $noreg, 80, $noreg, @.str.11 :: (store 8 into %ir.arrayidx9, align 16)
480B	  MOV64mi32 %stack.14.t_names, 1, $noreg, 88, $noreg, @.str.12 :: (store 8 into %ir.arrayidx10)
496B	  %5:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
512B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
528B	  $rdi = COPY %5:gr64
544B	  CALL64pcrel32 @fclose, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
560B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
576B	  JMP_1 %bb.3

592B	bb.2.if.else:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

608B	  MOV32mi $rip, 1, $noreg, @timeron, $noreg, 0 :: (store 4 into @timeron)

624B	bb.3.if.end:
	; predecessors: %bb.2, %bb.1
	  successors: %bb.4(0x50000000), %bb.9(0x30000000); %bb.4(62.50%), %bb.9(37.50%)

640B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
704B	  $rdi = MOV32ri64 @.str.13
720B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
736B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
752B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
768B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
816B	  $rdi = MOV32ri64 @.str.14
832B	  $rsi = MOV32ri64 @.str.1
848B	  CALL64pcrel32 @fopen, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
864B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
880B	  %13:gr64 = COPY killed $rax
896B	  MOV64mr %stack.15.fp, 1, $noreg, 0, $noreg, %13:gr64 :: (store 8 into %ir.fp)
912B	  TEST64rr %13:gr64, %13:gr64, implicit-def $eflags
928B	  JCC_1 %bb.9, 4, implicit killed $eflags
944B	  JMP_1 %bb.4

960B	bb.4.if.then15:
	; predecessors: %bb.3
	  successors: %bb.5(0x80000000); %bb.5(100.00%)

976B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1040B	  $rdi = MOV32ri64 @.str.15
1056B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1072B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1088B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1104B	  %24:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
1120B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1152B	  %26:gr64 = LEA64r %stack.4.niter, 1, $noreg, 0, $noreg
1184B	  $rsi = MOV32ri64 @.str.16
1192B	  $rdi = COPY %24:gr64
1200B	  $rdx = COPY %26:gr64
1216B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1232B	  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1248B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1264B	  %27:gr32 = COPY killed $eax
1280B	  MOV32mr %stack.16.result, 1, $noreg, 0, $noreg, %27:gr32 :: (store 4 into %ir.result)

1296B	bb.5.while.cond:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

1312B	  %28:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
1328B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1344B	  $rdi = COPY %28:gr64
1360B	  CALL64pcrel32 @fgetc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1376B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1392B	  %29:gr32 = COPY killed $eax
1408B	  CMP32ri8 %29:gr32, 10, implicit-def $eflags
1424B	  JCC_1 %bb.5, 5, implicit killed $eflags
1440B	  JMP_1 %bb.6

1456B	bb.6.while.end:
	; predecessors: %bb.5
	  successors: %bb.7(0x80000000); %bb.7(100.00%)

1472B	  %31:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
1488B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1584B	  $rsi = MOV32ri64 @.str.17
1600B	  $rdx = MOV32ri64 @dt
1608B	  $rdi = COPY %31:gr64
1616B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
1632B	  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1648B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1664B	  %36:gr32 = COPY killed $eax
1680B	  MOV32mr %stack.16.result, 1, $noreg, 0, $noreg, %36:gr32 :: (store 4 into %ir.result)

1696B	bb.7.while.cond21:
	; predecessors: %bb.6, %bb.7
	  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)

1712B	  %37:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
1728B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1744B	  $rdi = COPY %37:gr64
1760B	  CALL64pcrel32 @fgetc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1776B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1792B	  %38:gr32 = COPY killed $eax
1808B	  CMP32ri8 %38:gr32, 10, implicit-def $eflags
1824B	  JCC_1 %bb.7, 5, implicit killed $eflags
1840B	  JMP_1 %bb.8

1856B	bb.8.while.end25:
	; predecessors: %bb.7
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1872B	  %40:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
1888B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2016B	  $rsi = MOV32ri64 @.str.18
2032B	  $rdx = MOV32ri64 @grid_points
2048B	  $rcx = MOV32ri64 @grid_points + 4
2064B	  $r8 = MOV32ri64 @grid_points + 8
2072B	  $rdi = COPY %40:gr64
2080B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
2096B	  CALL64pcrel32 @fscanf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $rdx, implicit killed $rcx, implicit killed $r8, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
2112B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2128B	  %47:gr32 = COPY killed $eax
2144B	  MOV32mr %stack.16.result, 1, $noreg, 0, $noreg, %47:gr32 :: (store 4 into %ir.result)
2160B	  %48:gr64 = MOV64rm %stack.15.fp, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.fp)
2176B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2192B	  $rdi = COPY %48:gr64
2208B	  CALL64pcrel32 @fclose, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
2224B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2240B	  JMP_1 %bb.10

2256B	bb.9.if.else28:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

2272B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2336B	  $rdi = MOV32ri64 @.str.19
2352B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
2368B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
2384B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2400B	  MOV32mi %stack.4.niter, 1, $noreg, 0, $noreg, 200 :: (store 4 into %ir.niter)
2416B	  %18:gr64 = MOV64ri 4554169646866313825
2432B	  MOV64mr $rip, 1, $noreg, @dt, $noreg, %18:gr64 :: (store 8 into @dt)
2448B	  %19:gr64 = MOV64ri 438086664294
2464B	  MOV64mr $rip, 1, $noreg, @grid_points, $noreg, %19:gr64 :: (store 8 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`, align 4)
2480B	  MOV32mi $rip, 1, $noreg, @grid_points + 8, $noreg, 102 :: (store 4 into `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)

2496B	bb.10.if.end30:
	; predecessors: %bb.9, %bb.8
	  successors: %bb.13(0x40000000), %bb.11(0x40000000); %bb.13(50.00%), %bb.11(50.00%)

2512B	  %50:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
2528B	  %51:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
2544B	  %52:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
2560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2624B	  $rdi = MOV32ri64 @.str.20
2640B	  $esi = COPY %50:gr32
2656B	  $edx = COPY %51:gr32
2672B	  $ecx = COPY %52:gr32
2688B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
2704B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
2720B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2736B	  %57:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
2752B	  %58:fr64 = MOVSDrm_alt $rip, 1, $noreg, @dt, $noreg :: (dereferenceable load 8 from @dt)
2768B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2816B	  $rdi = MOV32ri64 @.str.21
2832B	  $esi = COPY %57:gr32
2848B	  $xmm0 = COPY %58:fr64
2864B	  $al = MOV8ri 1
2880B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
2896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2912B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2944B	  $rdi = MOV32ri64 @.str.22
2960B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
2976B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
2992B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3008B	  CMP32mi8 $rip, 1, $noreg, @grid_points, $noreg, 102, implicit-def $eflags :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
3024B	  JCC_1 %bb.13, 15, implicit killed $eflags
3040B	  JMP_1 %bb.11

3056B	bb.11.lor.lhs.false:
	; predecessors: %bb.10
	  successors: %bb.13(0x40000000), %bb.12(0x40000000); %bb.13(50.00%), %bb.12(50.00%)

3072B	  CMP32mi8 $rip, 1, $noreg, @grid_points + 4, $noreg, 102, implicit-def $eflags :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
3088B	  JCC_1 %bb.13, 15, implicit killed $eflags
3104B	  JMP_1 %bb.12

3120B	bb.12.lor.lhs.false36:
	; predecessors: %bb.11
	  successors: %bb.13(0x40000000), %bb.14(0x40000000); %bb.13(50.00%), %bb.14(50.00%)

3136B	  CMP32mi8 $rip, 1, $noreg, @grid_points + 8, $noreg, 103, implicit-def $eflags :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
3152B	  JCC_1 %bb.14, 12, implicit killed $eflags
3168B	  JMP_1 %bb.13

3184B	bb.13.if.then38:
	; predecessors: %bb.10, %bb.11, %bb.12
	  successors: %bb.45(0x80000000); %bb.45(100.00%)

3200B	  %207:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
3216B	  %208:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
3232B	  %209:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
3248B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3312B	  $rdi = MOV32ri64 @.str.23
3328B	  $esi = COPY %207:gr32
3344B	  $edx = COPY %208:gr32
3360B	  $ecx = COPY %209:gr32
3376B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
3392B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
3408B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3424B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3456B	  $rdi = MOV32ri64 @.str.24
3472B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
3488B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
3504B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3520B	  MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)
3536B	  JMP_1 %bb.45

3552B	bb.14.if.end41:
	; predecessors: %bb.12
	  successors: %bb.15(0x80000000); %bb.15(100.00%)

3568B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3616B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
3632B	  CALL64pcrel32 @set_constants, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
3648B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3664B	  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

3680B	bb.15.for.cond:
	; predecessors: %bb.14, %bb.16
	  successors: %bb.16(0x7c000000), %bb.17(0x04000000); %bb.16(96.88%), %bb.17(3.12%)

3696B	  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 11, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
3712B	  JCC_1 %bb.17, 15, implicit killed $eflags
3728B	  JMP_1 %bb.16

3744B	bb.16.for.body:
	; predecessors: %bb.15
	  successors: %bb.15(0x80000000); %bb.15(100.00%)

3760B	  %206:gr32 = MOV32rm %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
3776B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3792B	  $edi = COPY %206:gr32
3808B	  CALL64pcrel32 @timer_clear, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
3824B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3840B	  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
3856B	  JMP_1 %bb.15

3872B	bb.17.for.end:
	; predecessors: %bb.15
	  successors: %bb.18(0x80000000); %bb.18(100.00%)

3888B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3936B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
3952B	  CALL64pcrel32 @initialize, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
3968B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3984B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4000B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
4016B	  CALL64pcrel32 @exact_rhs, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
4032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4048B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4064B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
4080B	  CALL64pcrel32 @adi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
4096B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4112B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4128B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
4144B	  CALL64pcrel32 @initialize, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
4160B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4176B	  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

4192B	bb.18.for.cond43:
	; predecessors: %bb.17, %bb.19
	  successors: %bb.19(0x7c000000), %bb.20(0x04000000); %bb.19(96.88%), %bb.20(3.12%)

4208B	  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 11, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
4224B	  JCC_1 %bb.20, 15, implicit killed $eflags
4240B	  JMP_1 %bb.19

4256B	bb.19.for.body45:
	; predecessors: %bb.18
	  successors: %bb.18(0x80000000); %bb.18(100.00%)

4272B	  %205:gr32 = MOV32rm %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
4288B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4304B	  $edi = COPY %205:gr32
4320B	  CALL64pcrel32 @timer_clear, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
4336B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4352B	  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
4368B	  JMP_1 %bb.18

4384B	bb.20.for.end48:
	; predecessors: %bb.18
	  successors: %bb.21(0x80000000); %bb.21(100.00%)

4400B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4432B	  $edi = MOV32ri 1
4448B	  CALL64pcrel32 @timer_start, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
4464B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4480B	  MOV32mi %stack.5.step, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.step)

4528B	bb.21.for.cond49:
	; predecessors: %bb.20, %bb.25
	  successors: %bb.22(0x7c000000), %bb.26(0x04000000); %bb.22(96.88%), %bb.26(3.12%)

4544B	  %79:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
4560B	  CMP32rm %79:gr32, %stack.4.niter, 1, $noreg, 0, $noreg, implicit-def $eflags :: (dereferenceable load 4 from %ir.niter)
4576B	  JCC_1 %bb.26, 15, implicit killed $eflags
4592B	  JMP_1 %bb.22

4608B	bb.22.for.body51:
	; predecessors: %bb.21
	  successors: %bb.24(0x30000000), %bb.23(0x50000000); %bb.24(37.50%), %bb.23(62.50%)

4624B	  %183:gr64_with_sub_8bit = MOVSX64rm32 %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
4656B	  %192:gr64_nosp = IMUL64rri32 %183:gr64_with_sub_8bit, 1717986919, implicit-def dead $eflags
4672B	  %186:gr64_with_sub_8bit = COPY %192:gr64_nosp
4688B	  %186:gr64_with_sub_8bit = SHR64ri %186:gr64_with_sub_8bit(tied-def 0), 63, implicit-def dead $eflags
4736B	  %192:gr64_nosp = SAR64ri %192:gr64_nosp(tied-def 0), 35, implicit-def dead $eflags
4784B	  %192.sub_32bit:gr64_nosp = ADD32rr %192.sub_32bit:gr64_nosp(tied-def 0), %186.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags
4816B	  %192.sub_32bit:gr64_nosp = SHL32ri %192.sub_32bit:gr64_nosp(tied-def 0), 2, implicit-def dead $eflags
4848B	  %194:gr32 = LEA64_32r %192:gr64_nosp, 4, %192:gr64_nosp, 0, $noreg
4864B	  CMP32rr %183.sub_32bit:gr64_with_sub_8bit, %194:gr32, implicit-def $eflags
4880B	  JCC_1 %bb.24, 4, implicit killed $eflags
4896B	  JMP_1 %bb.23

4912B	bb.23.lor.lhs.false53:
	; predecessors: %bb.22
	  successors: %bb.24(0x40000000), %bb.25(0x40000000); %bb.24(50.00%), %bb.25(50.00%)

4928B	  CMP32mi8 %stack.5.step, 1, $noreg, 0, $noreg, 1, implicit-def $eflags :: (dereferenceable load 4 from %ir.step)
4944B	  JCC_1 %bb.25, 5, implicit killed $eflags
4960B	  JMP_1 %bb.24

4976B	bb.24.if.then55:
	; predecessors: %bb.22, %bb.23
	  successors: %bb.25(0x80000000); %bb.25(100.00%)

4992B	  %198:gr32 = MOV32rm %stack.5.step, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.step)
5008B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5040B	  $rdi = MOV32ri64 @.str.25
5056B	  $esi = COPY %198:gr32
5072B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
5088B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
5104B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

5120B	bb.25.if.end57:
	; predecessors: %bb.23, %bb.24
	  successors: %bb.21(0x80000000); %bb.21(100.00%)

5136B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5168B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
5184B	  CALL64pcrel32 @adi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $al, implicit-def $rsp, implicit-def $ssp
5200B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5216B	  INC32m %stack.5.step, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.step), (dereferenceable load 4 from %ir.step)
5232B	  JMP_1 %bb.21

5248B	bb.26.for.end60:
	; predecessors: %bb.21
	  successors: %bb.27(0x50000000), %bb.28(0x30000000); %bb.27(62.50%), %bb.28(37.50%)

5264B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5296B	  $edi = MOV32ri 1
5312B	  CALL64pcrel32 @timer_stop, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
5328B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5344B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5360B	  $edi = MOV32ri 1
5376B	  CALL64pcrel32 @timer_read, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
5392B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5408B	  %82:fr64 = COPY killed $xmm0
5424B	  MOVSDmr %stack.9.tmax, 1, $noreg, 0, $noreg, %82:fr64 :: (store 8 into %ir.tmax)
5440B	  %83:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
5456B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5472B	  %84:gr64 = LEA64r %stack.13.Class, 1, $noreg, 0, $noreg
5488B	  %85:gr64 = LEA64r %stack.12.verified, 1, $noreg, 0, $noreg
5504B	  $edi = COPY %83:gr32
5520B	  $rsi = COPY %84:gr64
5536B	  $rdx = COPY %85:gr64
5552B	  CALL64pcrel32 @verify, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp
5568B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5584B	  %95:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
5600B	  %87:fr64 = CVTSI2SDrr %95:gr32
5616B	  %88:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
5632B	  %90:fr64 = CVTSI2SDrr %88:gr32
5664B	  %90:fr64 = MULSDrr %90:fr64(tied-def 0), %87:fr64
5680B	  %91:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
5696B	  %93:fr64 = CVTSI2SDrr %91:gr32
5728B	  %93:fr64 = MULSDrr %93:fr64(tied-def 0), %90:fr64
5744B	  MOVSDmr %stack.8.n3, 1, $noreg, 0, $noreg, %93:fr64 :: (store 8 into %ir.n3)
5776B	  %95:gr32 = nsw ADD32rr %95:gr32(tied-def 0), %88:gr32, implicit-def dead $eflags
5808B	  %95:gr32 = nsw ADD32rr %95:gr32(tied-def 0), %91:gr32, implicit-def dead $eflags
5824B	  %97:fr64 = CVTSI2SDrr %95:gr32
5856B	  %97:fr64 = DIVSDrm %97:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
5872B	  MOVSDmr %stack.6.navg, 1, $noreg, 0, $noreg, %97:fr64 :: (store 8 into %ir.navg)
5888B	  %98:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
5904B	  %99:fr64 = FsFLD0SD
5920B	  UCOMISDrr %98:fr64, %99:fr64, implicit-def $eflags
5936B	  JCC_1 %bb.27, 5, implicit $eflags
5952B	  JCC_1 %bb.27, 10, implicit killed $eflags
5968B	  JMP_1 %bb.28

5984B	bb.27.if.then70:
	; predecessors: %bb.26
	  successors: %bb.29(0x80000000); %bb.29(100.00%)

6000B	  %101:fr64 = CVTSI2SDrm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
6032B	  %101:fr64 = MULSDrm %101:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
6048B	  %103:fr64 = MOVSDrm_alt %stack.8.n3, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.n3)
6080B	  %103:fr64 = MULSDrm %103:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
6096B	  %109:fr64 = MOVSDrm_alt %stack.6.navg, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.navg)
6112B	  %106:fr64 = COPY %109:fr64
6128B	  %106:fr64 = MULSDrr %106:fr64(tied-def 0), %106:fr64
6160B	  %106:fr64 = MULSDrm %106:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
6192B	  %106:fr64 = ADDSDrr %106:fr64(tied-def 0), %103:fr64
6224B	  %109:fr64 = MULSDrm %109:fr64(tied-def 0), $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
6256B	  %109:fr64 = ADDSDrr %109:fr64(tied-def 0), %106:fr64
6288B	  %109:fr64 = MULSDrr %109:fr64(tied-def 0), %101:fr64
6320B	  %109:fr64 = DIVSDrm %109:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
6336B	  MOVSDmr %stack.7.mflops, 1, $noreg, 0, $noreg, %109:fr64 :: (store 8 into %ir.mflops)
6352B	  JMP_1 %bb.29

6368B	bb.28.if.else80:
	; predecessors: %bb.26
	  successors: %bb.29(0x80000000); %bb.29(100.00%)

6384B	  MOV64mi32 %stack.7.mflops, 1, $noreg, 0, $noreg, 0 :: (store 8 into %ir.mflops)

6400B	bb.29.if.end81:
	; predecessors: %bb.28, %bb.27
	  successors: %bb.30(0x50000000), %bb.44(0x30000000); %bb.30(62.50%), %bb.44(37.50%)

6416B	  %112:gr32 = MOVSX32rm8 %stack.13.Class, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.Class)
6432B	  %113:gr32 = MOV32rm $rip, 1, $noreg, @grid_points, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 0)`)
6448B	  %114:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 4, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 1)`)
6464B	  %115:gr32 = MOV32rm $rip, 1, $noreg, @grid_points + 8, $noreg :: (dereferenceable load 4 from `i32* getelementptr inbounds ([3 x i32], [3 x i32]* @grid_points, i64 0, i64 2)`)
6480B	  %116:gr32 = MOV32rm %stack.4.niter, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.niter)
6496B	  %117:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
6512B	  %118:fr64 = MOVSDrm_alt %stack.7.mflops, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.mflops)
6528B	  undef %221.sub_32bit:gr64_with_sub_8bit = MOV32rm %stack.12.verified, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.verified)
6544B	  ADJCALLSTACKDOWN64 88, 0, 88, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6576B	  $rdi = MOV32ri64 @.str.26
6592B	  $esi = COPY %112:gr32
6608B	  $edx = COPY %113:gr32
6624B	  $ecx = COPY %114:gr32
6640B	  $r8d = COPY %115:gr32
6656B	  $r9d = COPY %116:gr32
6672B	  $xmm0 = COPY %117:fr64
6688B	  $xmm1 = COPY %118:fr64
6704B	  PUSH64i32 @.str.36, implicit-def $rsp, implicit $rsp
6720B	  PUSH64i32 @.str.35, implicit-def $rsp, implicit $rsp
6736B	  PUSH64i32 @.str.34, implicit-def $rsp, implicit $rsp
6752B	  PUSH64i32 @.str.33, implicit-def $rsp, implicit $rsp
6768B	  PUSH64i32 @.str.32, implicit-def $rsp, implicit $rsp
6784B	  PUSH64i32 @.str.31, implicit-def $rsp, implicit $rsp
6800B	  PUSH64i32 @.str.30, implicit-def $rsp, implicit $rsp
6816B	  PUSH64i32 @.str.29, implicit-def $rsp, implicit $rsp
6832B	  PUSH64i32 @.str.28, implicit-def $rsp, implicit $rsp
6864B	  PUSH64r %221:gr64_with_sub_8bit, implicit-def $rsp, implicit $rsp
6880B	  PUSH64i32 @.str.27, implicit-def $rsp, implicit $rsp
6896B	  CALL64pcrel32 @print_results, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit killed $edx, implicit killed $ecx, implicit killed $r8d, implicit killed $r9d, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp
6912B	  ADJCALLSTACKUP64 88, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6928B	  CMP32mi8 $rip, 1, $noreg, @timeron, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from @timeron)
6944B	  JCC_1 %bb.44, 4, implicit killed $eflags
6960B	  JMP_1 %bb.30

6976B	bb.30.if.then82:
	; predecessors: %bb.29
	  successors: %bb.31(0x80000000); %bb.31(100.00%)

6992B	  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)

7008B	bb.31.for.cond83:
	; predecessors: %bb.30, %bb.32
	  successors: %bb.32(0x7c000000), %bb.33(0x04000000); %bb.32(96.88%), %bb.33(3.12%)

7024B	  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 11, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
7040B	  JCC_1 %bb.33, 15, implicit killed $eflags
7056B	  JMP_1 %bb.32

7072B	bb.32.for.body86:
	; predecessors: %bb.31
	  successors: %bb.31(0x80000000); %bb.31(100.00%)

7088B	  %180:gr32 = MOV32rm %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
7104B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
7120B	  $edi = COPY %180:gr32
7136B	  CALL64pcrel32 @timer_read, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
7152B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
7168B	  %181:fr64 = COPY killed $xmm0
7184B	  %182:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
7200B	  MOVSDmr %stack.11.trecs, 8, %182:gr64_nosp, 0, $noreg, %181:fr64 :: (store 8 into %ir.arrayidx88)
7216B	  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
7232B	  JMP_1 %bb.31

7248B	bb.33.for.end91:
	; predecessors: %bb.31
	  successors: %bb.34(0x50000000), %bb.35(0x30000000); %bb.34(62.50%), %bb.35(37.50%)

7264B	  %124:fr64 = MOVSDrm_alt %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
7280B	  %125:fr64 = FsFLD0SD
7296B	  UCOMISDrr %124:fr64, %125:fr64, implicit-def $eflags
7312B	  JCC_1 %bb.35, 5, implicit $eflags
7328B	  JCC_1 %bb.35, 10, implicit killed $eflags
7344B	  JMP_1 %bb.34

7360B	bb.34.if.then94:
	; predecessors: %bb.33
	  successors: %bb.35(0x80000000); %bb.35(100.00%)

7376B	  %126:gr64 = MOV64ri 4607182418800017408
7392B	  MOV64mr %stack.9.tmax, 1, $noreg, 0, $noreg, %126:gr64 :: (store 8 into %ir.tmax)

7408B	bb.35.if.end95:
	; predecessors: %bb.33, %bb.34
	  successors: %bb.36(0x80000000); %bb.36(100.00%)

7424B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
7488B	  $rdi = MOV32ri64 @.str.37
7504B	  dead $eax = MOV32r0 implicit-def dead $eflags, implicit-def $al
7520B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
7536B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
7552B	  MOV32mi %stack.3.i, 1, $noreg, 0, $noreg, 1 :: (store 4 into %ir.i)
7568B	  %217:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)

7696B	bb.36.for.cond97:
	; predecessors: %bb.35, %bb.43
	  successors: %bb.37(0x7c000000), %bb.44(0x04000000); %bb.37(96.88%), %bb.44(3.12%)

7712B	  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 11, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
7728B	  JCC_1 %bb.44, 15, implicit killed $eflags
7744B	  JMP_1 %bb.37

7760B	bb.37.for.body100:
	; predecessors: %bb.36
	  successors: %bb.38(0x40000000), %bb.39(0x40000000); %bb.38(50.00%), %bb.39(50.00%)

7776B	  %133:gr64_nosp = MOVSX64rm32 %stack.3.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
7792B	  %134:gr64 = MOV64rm %stack.14.t_names, 8, %133:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx102)
7808B	  %135:fr64 = MOVSDrm_alt %stack.11.trecs, 8, %133:gr64_nosp, 0, $noreg :: (load 8 from %ir.arrayidx106)
7824B	  %137:fr64 = COPY %135:fr64
7840B	  %137:fr64 = MULSDrr %137:fr64(tied-def 0), %217:fr64
7872B	  %137:fr64 = DIVSDrm %137:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
7888B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
7904B	  $rdi = MOV32ri64 @.str.38
7920B	  $rsi = COPY %134:gr64
7936B	  $xmm0 = COPY %135:fr64
7952B	  $xmm1 = COPY %137:fr64
7968B	  $al = MOV8ri 2
7984B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
8000B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8016B	  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 5, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
8032B	  JCC_1 %bb.39, 5, implicit killed $eflags
8048B	  JMP_1 %bb.38

8064B	bb.38.if.then112:
	; predecessors: %bb.37
	  successors: %bb.43(0x80000000); %bb.43(100.00%)

8080B	  %166:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 16, $noreg :: (dereferenceable load 8 from %ir.arrayidx113, align 16)
8112B	  %166:fr64 = ADDSDrm %166:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 24, $noreg :: (dereferenceable load 8 from %ir.arrayidx114)
8144B	  %166:fr64 = ADDSDrm %166:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 32, $noreg :: (dereferenceable load 8 from %ir.arrayidx116, align 16)
8160B	  MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %166:fr64 :: (store 8 into %ir.t)
8176B	  %169:fr64 = COPY %166:fr64
8192B	  %169:fr64 = MULSDrr %169:fr64(tied-def 0), %217:fr64
8224B	  %169:fr64 = DIVSDrm %169:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
8240B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8256B	  $rdi = MOV32ri64 @.str.39
8272B	  $rsi = MOV32ri64 @.str.40
8288B	  $xmm0 = COPY %166:fr64
8304B	  $xmm1 = COPY %169:fr64
8320B	  $al = MOV8ri 2
8336B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
8352B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8368B	  %175:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 40, $noreg :: (dereferenceable load 8 from %ir.arrayidx121)
8400B	  %175:fr64 = SUBSDrm %175:fr64(tied-def 0), %stack.10.t, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.t)
8416B	  MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %175:fr64 :: (store 8 into %ir.t)
8432B	  %177:fr64 = COPY %175:fr64
8448B	  %177:fr64 = MULSDrr %177:fr64(tied-def 0), %217:fr64
8480B	  %177:fr64 = DIVSDrm %177:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
8496B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8512B	  $rdi = MOV32ri64 @.str.39
8528B	  $rsi = MOV32ri64 @.str.41
8544B	  $xmm0 = COPY %175:fr64
8560B	  $xmm1 = COPY %177:fr64
8576B	  $al = MOV8ri 2
8592B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
8608B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8624B	  JMP_1 %bb.43

8640B	bb.39.if.else126:
	; predecessors: %bb.37
	  successors: %bb.40(0x40000000), %bb.41(0x40000000); %bb.40(50.00%), %bb.41(50.00%)

8656B	  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 8, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
8672B	  JCC_1 %bb.41, 5, implicit killed $eflags
8688B	  JMP_1 %bb.40

8704B	bb.40.if.then129:
	; predecessors: %bb.39
	  successors: %bb.43(0x80000000); %bb.43(100.00%)

8720B	  %157:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 64, $noreg :: (dereferenceable load 8 from %ir.arrayidx130, align 16)
8752B	  %157:fr64 = SUBSDrm %157:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx131)
8784B	  %157:fr64 = SUBSDrm %157:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx133, align 16)
8800B	  MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %157:fr64 :: (store 8 into %ir.t)
8816B	  %159:fr64 = COPY %157:fr64
8832B	  %159:fr64 = MULSDrr %159:fr64(tied-def 0), %217:fr64
8864B	  %159:fr64 = DIVSDrm %159:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
8880B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
8896B	  $rdi = MOV32ri64 @.str.39
8912B	  $rsi = MOV32ri64 @.str.42
8928B	  $xmm0 = COPY %157:fr64
8944B	  $xmm1 = COPY %159:fr64
8960B	  $al = MOV8ri 2
8976B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
8992B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
9008B	  JMP_1 %bb.43

9024B	bb.41.if.else138:
	; predecessors: %bb.39
	  successors: %bb.42(0x40000000), %bb.43(0x40000000); %bb.42(50.00%), %bb.43(50.00%)

9040B	  CMP32mi8 %stack.3.i, 1, $noreg, 0, $noreg, 10, implicit-def $eflags :: (dereferenceable load 4 from %ir.i)
9056B	  JCC_1 %bb.43, 5, implicit killed $eflags
9072B	  JMP_1 %bb.42

9088B	bb.42.if.then141:
	; predecessors: %bb.41
	  successors: %bb.43(0x80000000); %bb.43(100.00%)

9104B	  %148:fr64 = MOVSDrm_alt %stack.11.trecs, 1, $noreg, 72, $noreg :: (dereferenceable load 8 from %ir.arrayidx142)
9136B	  %148:fr64 = ADDSDrm %148:fr64(tied-def 0), %stack.11.trecs, 1, $noreg, 80, $noreg :: (dereferenceable load 8 from %ir.arrayidx143, align 16)
9152B	  MOVSDmr %stack.10.t, 1, $noreg, 0, $noreg, %148:fr64 :: (store 8 into %ir.t)
9168B	  %150:fr64 = COPY %148:fr64
9184B	  %150:fr64 = MULSDrr %150:fr64(tied-def 0), %217:fr64
9216B	  %150:fr64 = DIVSDrm %150:fr64(tied-def 0), %stack.9.tmax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.tmax)
9232B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
9248B	  $rdi = MOV32ri64 @.str.39
9264B	  $rsi = MOV32ri64 @.str.43
9280B	  $xmm0 = COPY %148:fr64
9296B	  $xmm1 = COPY %150:fr64
9312B	  $al = MOV8ri 2
9328B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit killed $xmm0, implicit killed $xmm1, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
9344B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

9360B	bb.43.if.end150:
	; predecessors: %bb.41, %bb.42, %bb.40, %bb.38
	  successors: %bb.36(0x80000000); %bb.36(100.00%)

9376B	  INC32m %stack.3.i, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (store 4 into %ir.i), (dereferenceable load 4 from %ir.i)
9392B	  JMP_1 %bb.36

9408B	bb.44.if.end154:
	; predecessors: %bb.29, %bb.36
	  successors: %bb.45(0x80000000); %bb.45(100.00%)

9424B	  MOV32mi %stack.0.retval, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.retval)

9440B	bb.45.return:
	; predecessors: %bb.44, %bb.13

9456B	  %216:gr32 = MOV32rm %stack.0.retval, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.retval)
9472B	  $eax = COPY %216:gr32
9488B	  RET 0, killed $eax

# End machine code for function main.

